{"version":3,"sources":["js/streaming/MediaPlayer.js","js/streaming/AbrController.js","js/streaming/BufferController.js","js/streaming/BufferExtensions.js","js/streaming/Capabilities.js","js/streaming/Config.js","js/streaming/Context.js","js/streaming/ContextManager.js","js/streaming/Debug.js","js/streaming/DebugController.js","js/streaming/ErrorHandler.js","js/streaming/EventBus.js","js/streaming/EventController.js","js/streaming/FragmentController.js","js/streaming/FragmentLoader.js","js/streaming/FragmentModel.js","js/streaming/FragmentInfoController.js","js/streaming/ManifestLoader.js","js/streaming/ManifestUpdater.js","js/streaming/ManifestModel.js","js/streaming/MediaSourceExtensions.js","js/streaming/MetricsExtensions.js","js/streaming/MetricsModel.js","js/streaming/Mp4Processor.js","js/streaming/Notifier.js","js/streaming/Parser.js","js/streaming/SourceBufferExtensions.js","js/streaming/Stream.js","js/streaming/StreamController.js","js/streaming/TokenAuthentication.js","js/streaming/URIQueryAndFragmentModel.js","js/streaming/VideoModel.js","js/streaming/VideoModelExtensions.js","js/streaming/XHRLoader.js","js/streaming/captioning/TTMLParser.js","js/streaming/captioning/TTMLRenderer.js","js/streaming/captioning/TextController.js","js/streaming/captioning/TextSourceBuffer.js","js/streaming/captioning/TextTTMLXMLMP4SourceBuffer.js","js/streaming/captioning/TextTrackExtensions.js","js/streaming/captioning/VTTParser.js","js/streaming/rules/AbandonRequestsRule.js","js/streaming/rules/BaseRulesCollection.js","js/streaming/rules/DownloadRatioRule.js","js/streaming/rules/DroppedFramesRule.js","js/streaming/rules/InsufficientBufferRule.js","js/streaming/rules/LimitSwitchesRule.js","js/streaming/rules/SwitchRequest.js","js/streaming/protection/ProtectionModel.js","js/streaming/vo/Error.js","js/streaming/vo/Event.js","js/streaming/vo/MetricsList.js","js/streaming/vo/Mp4Track.js","js/streaming/vo/SegmentRequest.js","js/streaming/vo/URIFragmentData.js","js/streaming/vo/metrics/BufferLevel.js","js/streaming/vo/metrics/BufferedSwitch.js","js/streaming/vo/metrics/Condition.js","js/streaming/vo/metrics/DVRInfo.js","js/streaming/vo/metrics/DroppedFrames.js","js/streaming/vo/metrics/HTTPRequest.js","js/streaming/vo/metrics/ManifestUpdate.js","js/streaming/vo/metrics/PlayList.js","js/streaming/vo/metrics/PlaybackQuality.js","js/streaming/vo/metrics/RepresentationSwitch.js","js/streaming/vo/metrics/Session.js","js/streaming/vo/metrics/State.js","js/streaming/vo/metrics/TCPConnection.js","js/streaming/vo/metrics/VideoResolution.js","js/dash/Dash.js","js/dash/BaseURLExtensions.js","js/dash/DashContext.js","js/dash/DashHandler.js","js/dash/DashManifestExtensions.js","js/dash/DashMetricsExtensions.js","js/dash/DashParser.js","js/dash/FragmentExtensions.js","js/dash/TimelineConverter.js","js/dash/vo/AdaptationSet.js","js/dash/vo/Event.js","js/dash/vo/EventStream.js","js/dash/vo/Mpd.js","js/dash/vo/Period.js","js/dash/vo/Representation.js","js/dash/vo/Segment.js","js/hls/Hls.js","js/hls/HlsStream.js","js/utils/CopyMethods.js","js/utils/DOMParser.js","js/utils/ObjectIron.js","js/streaming/protection/CommonEncryption.js","js/streaming/protection/ProtectionController.js","js/streaming/protection/ProtectionExtensions.js","js/streaming/protection/ProtectionModel_01b.js","js/streaming/protection/ProtectionModel_3Feb2014.js","js/streaming/protection/ProtectionModel_21Jan2015.js","js/streaming/protection/drm/KeySystem.js","js/streaming/protection/drm/KeySystem_Access.js","js/streaming/protection/drm/KeySystem_ClearKey.js","js/streaming/protection/drm/KeySystem_PlayReady.js","js/streaming/protection/drm/KeySystem_Widevine.js","js/streaming/protection/servers/ClearKey.js","js/streaming/protection/servers/DRMToday.js","js/streaming/protection/servers/LicenseServer.js","js/streaming/protection/servers/PlayReady.js","js/streaming/protection/servers/Widevine.js","js/streaming/protection/vo/ClearKeyKeySet.js","js/streaming/protection/vo/KeyError.js","js/streaming/protection/vo/KeyMessage.js","js/streaming/protection/vo/KeyPair.js","js/streaming/protection/vo/KeySystemAccess.js","js/streaming/protection/vo/KeySystemConfiguration.js","js/streaming/protection/vo/LicenseRequestComplete.js","js/streaming/protection/vo/MediaCapability.js","js/streaming/protection/vo/NeedKey.js","js/streaming/protection/vo/ProtectionData.js","js/streaming/protection/vo/SessionToken.js","js/hls/AES128Decrypter.js","js/hls/HlsDemux.js","js/hls/HlsFragmentController.js","js/hls/HlsHandler.js","js/hls/HlsParser.js","js/mss/Mss.js","js/mss/MssParser.js","js/mss/MssHandler.js","js/mss/MssFragmentController.js","lib/base64.js","lib/dijon.js","lib/long.js","lib/Math.js","lib/objectiron.js","lib/q.js","lib/xml2json.js","lib/mp4lib/mp4lib.js","lib/mp4lib/mp4lib-fields.js","lib/mp4lib/mp4lib-boxes.js","lib/mpegts/mpegts.js","lib/mpegts/psi.js","lib/mpegts/aac.js","lib/mpegts/adaptationField.js","lib/mpegts/binary.js","lib/mpegts/h264.js","lib/mpegts/pat.js","lib/mpegts/pes.js","lib/mpegts/pmt.js","lib/mpegts/pts.js","lib/mpegts/ts.js","lib/fingerprint/fp_browser.js","lib/fingerprint/fp_os.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACruDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChsDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACndA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9jCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACz7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACztCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1uBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACj8BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACveA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7pBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7oBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5qBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5mBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACt7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"hasplayer.js","sourcesContent":["/**\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * @constructs MediaPlayer\n *\n */\n/*jshint -W020 */\n\n/**\n * @class\n * @classdesc MediaPlayer is the object used by the webapp to instanciante and control hasplayer.\n */\nMediaPlayer = function () {\n\n//#region Private attributes/properties\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////////////// PRIVATE ////////////////////////////////////////////\n    var VERSION_DASHJS = '1.2.0',\n        VERSION = 'DEV',\n        GIT_TAG = '@@REVISION',\n        BUILD_DATE = '@@TIMESTAMP',\n        context = new MediaPlayer.di.Context(), // default context\n        system = new dijon.System(), // dijon system instance\n        initialized = false,\n        debugController = null, // use to handle key pressed and download debug file\n        videoModel, // model to manipulate the domVideoNode\n        videoBitrates = null, //bitrates list of video\n        audioBitrates = null,\n        videoQualityChanged = [],\n        audioQualityChanged = [],\n        error = null,\n        warning = null,\n        defaultAudioLang = 'und',\n        defaultSubtitleLang = 'und',\n        subtitlesEnabled = false,\n        initialQuality = {\n            video: -1,\n            audio: -1\n        },\n        streamController = null,\n        resetting = false,\n        playing = false,\n        autoPlay = true,\n        source = null, // current source played\n        scheduleWhilePaused = false, // should we buffer while in pause\n        isSafari = (fingerprint_browser().name === \"Safari\"),\n        plugins = {};\n//#endregion\n\n//#region Private methods\n    var _isPlayerInitialized = function () {\n        if (!initialized) {\n            throw new Error('MediaPlayer not initialized !!!');\n        }\n    };\n\n    var _isVideoModelInitialized = function () {\n        if (!videoModel.getElement()) {\n            throw new Error('MediaPlayer.play(): Video element not attached to MediaPlayer');\n        }\n    };\n\n    var _isSourceInitialized = function () {\n        if (!source) {\n            throw new Error('MediaPlayer.play(): Source not attached to MediaPlayer');\n        }\n    };\n\n    var _play = function () {\n        var plugin,\n            pluginsInitDefer = [],\n            pluginsLoadDefer = [];\n\n        _isPlayerInitialized();\n        _isVideoModelInitialized();\n        _isSourceInitialized();\n\n        // Check MSE support\n        // (except in case of HLS streams on Safari for which we do not use MSE)\n        if (!(isSafari && source.protocol === 'HLS') && !MediaPlayer.hasMediaSourceExtension()) {\n            this.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.CAPABILITY_ERR_MEDIASOURCE, \"MediaSource extension not supported by the browser\");\n            return;\n        }\n\n        // Wait for plugins completely intialized before starting a new session\n        for(var name in  plugins) {\n            pluginsInitDefer.push(plugins[name].deferInit.promise);\n        }\n        Q.all(pluginsInitDefer).then((function () {\n            // Notify plugins a new stream is loaded\n            for (var name in plugins) {\n                plugin = plugins[name];\n                plugin.deferLoad = Q.defer();\n                pluginsLoadDefer.push(plugin.deferLoad.promise);\n                plugin.load(source, function () {\n                    this.deferLoad.resolve();\n                }.bind(plugin));\n            }\n\n            Q.all(pluginsLoadDefer).then((function () {\n                // Once all plugins are ready, we load the stream\n                playing = true;\n\n                this.metricsModel.addSession(null, source.url, videoModel.getElement().loop, null, \"MediaPlayer.js_\" + this.getVersion());\n\n                this.debug.log(\"[MediaPlayer] Version: \" + this.getVersionFull() + \" - \" + this.getBuildDate());\n                this.debug.log(\"[MediaPlayer] user-agent: \" + navigator.userAgent);\n                this.debug.log(\"[MediaPlayer] Load stream:\\n\", JSON.stringify(source, null, '  '));\n\n                // streamController Initialization\n                if (!streamController) {\n                    streamController = system.getObject('streamController');\n                    streamController.setVideoModel(videoModel);\n                    streamController.setAutoPlay(autoPlay);\n                }\n\n                streamController.setDefaultAudioLang(defaultAudioLang);\n                streamController.setDefaultSubtitleLang(defaultSubtitleLang);\n                streamController.enableSubtitles(subtitlesEnabled);\n                streamController.load(source);\n                system.mapValue(\"scheduleWhilePaused\", scheduleWhilePaused);\n                system.mapOutlet(\"scheduleWhilePaused\", \"stream\");\n\n            }).bind(this));\n        }).bind(this));\n    };\n\n    // player state and intitialization\n    var _isReady = function () {\n        return initialized && videoModel.getElement() && source && !resetting;\n    };\n\n    var _doAutoPlay = function () {\n        if (_isReady()) {\n            _play.call(this);\n        }\n    };\n\n    // event disptach\n    var _dispatchBitrateEvent = function (type, value) {\n        var event = document.createEvent(\"CustomEvent\");\n        event.initCustomEvent(type, false, false, {\n            type: value.streamType,\n            bitrate: value.switchedQuality,\n            representationId: value.representationId,\n            time: videoModel.getCurrentTime(),\n            width: value.width,\n            height: value.height\n        });\n        videoModel.getElement().dispatchEvent(event);\n    };\n\n    var _metricAdded = function (e) {\n        var event;\n        switch (e.data.metric) {\n            case \"ManifestReady\":\n                _isPlayerInitialized();\n                this.debug.log(\"[MediaPlayer] ManifestReady\");\n                videoBitrates = this.metricsExt.getBitratesForType('video');\n                this.debug.log(\"[MediaPlayer] video bitrates: \" + JSON.stringify(videoBitrates));\n                event = document.createEvent(\"CustomEvent\");\n                event.initCustomEvent('manifest_loaded', false, false, {});\n                videoModel.getElement().dispatchEvent(event);\n                break;\n            case \"RepresentationSwitch\":\n                _isPlayerInitialized();\n                if (e.data.stream == \"video\") {\n                    videoBitrates = this.metricsExt.getBitratesForType(e.data.stream);\n                    if (videoBitrates) {\n                        _dispatchBitrateEvent('download_bitrate', {\n                            streamType: e.data.stream,\n                            switchedQuality: videoBitrates[e.data.value.lto],\n                            representationId: e.data.value.to,\n                            width: this.metricsExt.getVideoWidthForRepresentation(e.data.value.to),\n                            height: this.metricsExt.getVideoHeightForRepresentation(e.data.value.to)\n                        });\n                        this.debug.log(\"[MediaPlayer][\" + e.data.stream + \"] send download_bitrate - b=\" + videoBitrates[e.data.value.lto]);\n                    }\n                } else if (e.data.stream == \"audio\") {\n                    audioBitrates = this.metricsExt.getBitratesForType(e.data.stream);\n                    if (audioBitrates) {\n                        _dispatchBitrateEvent('download_bitrate', {\n                            streamType: e.data.stream,\n                            switchedQuality: audioBitrates[e.data.value.lto],\n                            representationId: e.data.value.to,\n                            width: this.metricsExt.getVideoWidthForRepresentation(e.data.value.to),\n                            height: this.metricsExt.getVideoHeightForRepresentation(e.data.value.to)\n                        });\n                        this.debug.log(\"[MediaPlayer][\" + e.data.stream + \"] send download_bitrate - b=\" + videoBitrates[e.data.value.lto]);\n                    }\n                }\n                break;\n            case \"BufferedSwitch\":\n                _isPlayerInitialized();\n                if (e.data.stream == \"video\") {\n                    videoQualityChanged.push({\n                        streamType: e.data.stream,\n                        mediaStartTime: e.data.value.mt,\n                        switchedQuality: videoBitrates[e.data.value.lto],\n                        representationId: e.data.value.to,\n                        width: this.metricsExt.getVideoWidthForRepresentation(e.data.value.to),\n                        height: this.metricsExt.getVideoHeightForRepresentation(e.data.value.to)\n                    });\n                } else if (e.data.stream == \"audio\") {\n                    audioQualityChanged.push({\n                        streamType: e.data.stream,\n                        mediaStartTime: e.data.value.mt,\n                        switchedQuality: audioBitrates[e.data.value.lto],\n                        representationId: e.data.value.to,\n                        width: this.metricsExt.getVideoWidthForRepresentation(e.data.value.to),\n                        height: this.metricsExt.getVideoHeightForRepresentation(e.data.value.to)\n                    });\n                }\n                break;\n            case \"BufferLevel\":\n                //this.debug.log(\"[MediaPlayer] BufferLevel = \"+e.data.value.level+\" for type = \"+e.data.stream);\n                event = document.createEvent(\"CustomEvent\");\n                event.initCustomEvent('bufferLevel_updated', false, false, {\n                    type: e.data.stream,\n                    level: e.data.value.level\n                });\n                videoModel.getElement().dispatchEvent(event);\n                break;\n            case \"State\":\n                //this.debug.log(\"[MediaPlayer] State = \"+e.data.value.current+\" for type = \"+e.data.stream);\n                event = document.createEvent(\"CustomEvent\");\n                event.initCustomEvent('state_changed', false, false, {\n                    type: e.data.stream,\n                    state: e.data.value.current\n                });\n                videoModel.getElement().dispatchEvent(event);\n                break;\n        }\n    };\n\n    var _onError = function (e) {\n        error = e.data;\n        this.reset(2);\n    };\n\n    var _onWarning = function (e) {\n        warning = e.data;\n    };\n\n    var _cleanStreamTab = function (streamTab, idToRemove) {\n        var i = 0;\n\n        for (i = idToRemove.length - 1; i >= 0; i -= 1) {\n            streamTab.splice(i, 1);\n        }\n    };\n\n    var _detectPlayBitrateChange = function (streamTab) {\n        var currentTime = videoModel.getCurrentTime(),\n            currentSwitch = null,\n            idToRemove = [],\n            i = 0;\n\n        for (i = 0; i < streamTab.length; i += 1) {\n            currentSwitch = streamTab[i];\n            if (currentTime >= currentSwitch.mediaStartTime) {\n                _dispatchBitrateEvent('play_bitrate', currentSwitch);\n                this.debug.log(\"[MediaPlayer][\" + currentSwitch.streamType + \"] send play_bitrate - b=\" + currentSwitch.switchedQuality + \", t=\" + currentSwitch.mediaStartTime + \"(\" + videoModel.getPlaybackRate() + \")\");\n                // And remove when it's played\n                idToRemove.push(i);\n            }\n        }\n\n        _cleanStreamTab(streamTab, idToRemove);\n    };\n\n    // Usefull to dispatch event of quality changed\n    var _onTimeupdate = function () {\n        // If not in playing state, then do not send 'play_bitrate' events, wait for 'loadeddata' event first\n        if (videoModel.getPlaybackRate() === 0) {\n            return;\n        }\n        // Check for video playing quality change\n        _detectPlayBitrateChange.call(this, videoQualityChanged);\n        // Check for audio playing quality change\n        _detectPlayBitrateChange.call(this, audioQualityChanged);\n    };\n\n    // event connection\n    var _connectEvents = function () {\n        this.addEventListener('metricAdded', _metricAdded.bind(this));\n        this.addEventListener('error', _onError.bind(this));\n        this.addEventListener('warning', _onWarning.bind(this));\n        this.addEventListener('timeupdate', _onTimeupdate.bind(this));\n    };\n\n    // Keyboard handler to display version\n    var _handleKeyPressedEvent = function(e) {\n        // If Ctrl+Alt+Shift+d is pressed then display MediaPlayer version and plugins versions\n        if (e.altKey === true && e.ctrlKey === true && e.shiftKey === true && e.keyCode === 86) {\n            console.log('[MediaPlayer] Version: ' + this.getVersion() + ' - ' + this.getBuildDate());\n            for (var plugin in plugins) {\n                console.log('[' + plugins[plugin].getName() + '] Version: ' + plugins[plugin].getVersion() + ' - ' + plugins[plugin].getBuildDate());\n            }\n            \n        }\n    };\n\n    /// Private playback functions ///\n    var _resetAndPlay = function (reason) {\n        if (playing && streamController) {\n            if (!resetting) {\n                resetting = true;\n\n                var teardownComplete = {};\n                teardownComplete[MediaPlayer.dependencies.StreamController.eventList.ENAME_TEARDOWN_COMPLETE] = (function () {\n\n                    // Notify plugins that player is reset\n                    for (var plugin in plugins) {\n                        plugins[plugin].reset();\n                    }\n\n                    // Finish rest of shutdown process\n                    streamController = null;\n                    playing = false;\n\n                    resetting = false;\n\n                    this.debug.log(\"[MediaPlayer] Player is stopped\");\n\n                    if (_isReady.call(this)) {\n                        _doAutoPlay.call(this);\n                    }\n                }).bind(this);\n                streamController.subscribe(MediaPlayer.dependencies.StreamController.eventList.ENAME_TEARDOWN_COMPLETE, teardownComplete, undefined, true);\n                streamController.reset(reason);\n            }\n        } else {\n            if (_isReady.call(this)) {\n                _doAutoPlay.call(this);\n            }\n        }\n    };\n\n    var _toMediaPlayerTrack = function (track) {\n        if (!track) {\n            return null;\n        }\n        var _track = {};\n        if (track.id) {\n            _track.id = track.id;\n        }\n        if (track.lang) {\n            _track.lang = track.lang;\n        }\n        if (track.subType) {\n            _track.subType = track.subType;\n        }\n        return _track;\n    };\n\n    var _getTracksFromType = function (_type) {\n        if (!streamController) {\n            return null;\n        }\n        switch (_type) {\n            case MediaPlayer.TRACKS_TYPE.AUDIO:\n                return streamController.getAudioTracks();\n            case MediaPlayer.TRACKS_TYPE.TEXT:\n                return streamController.getSubtitleTracks();\n        }\n        return null;\n    };\n\n    var _getSelectedTrackFromType = function (_type) {\n        if (!streamController) {\n            return null;\n        }\n        switch (_type) {\n            case MediaPlayer.TRACKS_TYPE.AUDIO:\n                return streamController.getSelectedAudioTrack();\n            case MediaPlayer.TRACKS_TYPE.TEXT:\n                return streamController.getSelectedSubtitleTrack();\n        }\n        return null;\n    };\n\n    var _selectTrackFromType = function (_type, _track) {\n        if (!streamController) {\n            return null;\n        }\n        switch (_type) {\n            case MediaPlayer.TRACKS_TYPE.AUDIO:\n                streamController.setAudioTrack(_track);\n                break;\n            case MediaPlayer.TRACKS_TYPE.TEXT:\n                streamController.setSubtitleTrack(_track);\n                break;\n        }\n        return null;\n    };\n\n    var _isEqual = function (prop1, prop2) {\n        if (!prop1 && !prop2) {\n            // let's consider in this case that null and undefined are equal\n            return true;\n        }\n        return prop1 === prop2;\n    };\n\n    var _isSameTrack = function (track1, track2) {\n        return (_isEqual(track1.id, track2.id) && _isEqual(track1.lang, track2.lang) && _isEqual(track1.subType, track2.subType));\n    };\n\n    // parse the arguments of load function to make an object\n    var _parseLoadArguments = function () {\n        if (arguments && arguments.length > 0) {\n            var params = {};\n            // restaure url\n            if (typeof arguments[0] === 'string') {\n                params.url = arguments[0];\n            }\n            //restaure protData\n            if (arguments[1]) {\n                params.protData = arguments[1];\n            }\n            return params;\n        }\n\n    };\n\n    var _getDVRInfoMetric = function () {\n        var metrics = this.metricsModel.getReadOnlyMetricsFor('video'),\n            dvrInfo = metrics ? this.metricsExt.getCurrentDVRInfo(metrics) : null;\n        return dvrInfo;\n    };\n\n//#endregion\n\n//#region DIJON initialization\n    system.mapValue('system', system);\n    system.mapOutlet('system');\n    system.injectInto(context);\n//#endregion\n\n    return {\n        ///////////////////////////////////////////////////////////////////////////////////////////////\n        ////////////////////////////////////////// PUBLIC /////////////////////////////////////////////\n//#region dependencies\n        notifier: undefined,\n        debug: undefined,\n        eventBus: undefined,\n        metricsExt: undefined,\n        abrController: undefined,\n        metricsModel: undefined,\n        errHandler: undefined,\n        config: undefined,\n//#endregion\n\n//#region VERSION\n        /**\n         * Returns the version of the player.\n         * @method getVersion\n         * @access public\n         * @memberof MediaPlayer#\n         * @return {string} the version of the player\n         */\n        getVersion: function () {\n            return VERSION;\n        },\n\n        /**\n         * Returns the full version of the player (including git tag).\n         * @method getVersionFull\n         * @access public\n         * @memberof MediaPlayer#\n         * @return {string} the version of the player including git tag\n         */\n        getVersionFull: function () {\n            if (GIT_TAG.indexOf(\"@@\") === -1) {\n                return VERSION + '_' + GIT_TAG;\n            } else {\n                return VERSION;\n            }\n        },\n\n        /**\n         * Returns the version of dash.js from which this player has been built.\n         * @method getVersionDashJS\n         * @access public\n         * @memberof MediaPlayer#\n         * @return {string} the dash.js version\n         */\n        getVersionDashJS: function () {\n            return VERSION_DASHJS;\n        },\n\n        /**\n         * Returns the date at which this player has been built.\n         * @access public\n         * @memberof MediaPlayer#\n         * @return {string} the date at which this player has been built\n         */\n        getBuildDate: function () {\n            if (BUILD_DATE.indexOf(\"@@\") === -1) {\n                return BUILD_DATE;\n            } else {\n                return 'Not a builded version';\n            }\n        },\n//#endregion\n\n//#region INIT\n        /**\n         * Initialize the player.\n         * @method init\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {Object} video - the HTML5 video element used to decode and render the media data\n         */\n        init: function (video) {\n            if (!video) {\n                throw new Error('MediaPlayer.init(): Invalid Argument');\n            }\n            if (!initialized) {\n                system.injectInto(this);\n                initialized = true;\n                this.debug.log(\"[MediaPlayer] Version: \" + this.getVersionFull() + \" - \" + this.getBuildDate());\n                this.debug.log(\"[MediaPlayer] user-agent: \" + navigator.userAgent);\n            }\n            videoModel = system.getObject('videoModel');\n            videoModel.setElement(video);\n\n            // in case of init is called another time\n            /*if (playing && streamController) {\n                streamController.reset();\n                playing = false;\n            }*/\n\n            // connect default events\n            _connectEvents.call(this);\n            //debugController.init();\n\n            // create DebugController\n            debugController = system.getObject('debugController');\n            debugController.init(VERSION);\n\n            window.addEventListener('keydown', _handleKeyPressedEvent.bind(this));            \n        },\n//#endregion\n\n//#region LISTENERS\n        /**\n         * Registers a listener on the specified event.\n         * The possible event types are:\n         * <li>'error' (see [error]{@link MediaPlayer#event:error} event specification)\n         * <li>'warning' (see [warning]{@link MediaPlayer#event:warning} event specification)\n         * <li>'manifestUrlUpdate' (see [manifestUrlUpdate]{@link MediaPlayer#event:manifestUrlUpdate} event specification)\n         * <li>'play_bitrate' (see [play_bitrate]{@link MediaPlayer#event:play_bitrate} event specification)\n         * <li>'download_bitrate' (see [download_bitrate]{@link MediaPlayer#event:download_bitrate} event specification)\n         * <li>'bufferLevel_updated' (see [bufferLevel_updated]{@link MediaPlayer#event:bufferLevel_updated} event specification)\n         * <li>'state_changed' (see [state_changed]{@link MediaPlayer#event:state_changed} event specification)\n         * <li>'cueEnter' (see [cueEnter]{@link MediaPlayer#event:cueEnter} event specification)\n         * <li>'cueExit' (see [cueExit]{@link MediaPlayer#event:cueExit} event specification)\n         * @method addEventListener\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {string} type - the event type for listen to, either any HTML video element event or player event.\n         * @param {callback} listener - the callback which is called when an event of the specified type occurs\n         * @param {boolean} useCapture - see HTML DOM addEventListener() method specification\n         */\n        addEventListener: function (type, listener, useCapture) {\n            _isPlayerInitialized();\n            if (MediaPlayer.PUBLIC_EVENTS[type] === 'hasplayer') {\n                this.eventBus.addEventListener(type, listener, useCapture);\n            } else {\n                videoModel.listen(type, listener, useCapture);\n            }\n        },\n\n        /**\n         * Unregisters the listener previously registered with the addEventListener() method.\n         * @method removeEventListener\n         * @access public\n         * @memberof MediaPlayer#\n         * @see [addEventListener]{@link MediaPlayer#addEventListener}\n         * @param {string} type - the event type on which the listener was registered\n         * @param {callback} listener - the callback which was registered to the event type\n         */\n        removeEventListener: function (type, listener) {\n            _isPlayerInitialized();\n            if (MediaPlayer.PUBLIC_EVENTS[type] === 'hasplayer') {\n                this.eventBus.removeEventListener(type, listener);\n            } else {\n                videoModel.unlisten(type, listener);\n            }\n        },\n//#endregion\n\n//#region COMPONENTS GETTER\n        /**\n         * Returns the video model object.\n         * @access public\n         * @memberof MediaPlayer#\n         * @return {object} the video model object\n         */\n        getVideoModel: function() {\n            return videoModel;\n        },\n\n        /**\n         * Returns the debug object.\n         * @access public\n         * @memberof MediaPlayer#\n         * @return {object} the debug object\n         */\n        getDebug: function () {\n            return this.debug;\n        },\n\n        /**\n         * Returns the metrics extension object.\n         * @access public\n         * @memberof MediaPlayer#\n         * @return {object} the metrics extension object\n         */\n        getMetricsExt: function () {\n            return this.metricsExt;\n        },\n//#endregion\n\n//#region CONFIG\n        /**\n         * Sets player configuration parameters.\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {MediaPlayer#PlayerParams} params - parameter(s) value(s) to set.\n         */\n        setConfig: function (params) {\n            if (this.config && params) {\n                this.debug.log(\"[MediaPlayer] set config: \" + JSON.stringify(params, null, '\\t'));\n                this.config.setParams(params);\n            }\n        },\n        setParams: function (params) {\n            this.setConfig(params);\n        },\n\n        /**\n         * Enables or disables debug information in the browser console.\n         * @method setDebug\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {boolean} value - true to enable debug information, false to disable\n         */\n        setDebug: function (value) {\n            _isPlayerInitialized();\n            if (typeof value !== 'boolean') {\n                throw new Error('MediaPlayer.setDebug(): Invalid Arguments');\n            }\n            if (value === true) {\n                this.debug.setLevel(4);\n            } else {\n                this.debug.setLevel(0);\n            }\n        },\n\n        /**\n         * Returns the autoplay state.\n         * @access public\n         * @memberof MediaPlayer#\n         * @return {boolean} the autoplay state\n         */\n        getAutoPlay: function () {\n            return autoPlay;\n        },\n\n        /**\n         * Sets the autoplay state.\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {boolean} value - true to activate autoplay, false to disable autoplay\n         */\n        setAutoPlay: function (value) {\n            autoPlay = value;\n        },\n\n        /**\n         * Sets the initial quality to be downloaded for the given track type.\n         * This method has to be used before each call to load() method to set the initial quality.\n         * Otherwise, the initial quality is set according to previous bandwidth condition.\n         * @access public\n         * @memberof MediaPlayer#\n         * @see [setConfig]{@link MediaPlayer#setConfig} to set quality boundaries\n         * @param {string} type - the track type ('video' or 'audio')\n         * @param {number} value - the new initial quality index (starting from 0) to be downloaded\n         */\n        setInitialQualityFor: function (type, value) {\n            initialQuality[type] = value;\n        },\n\n        /**\n         * Returns the current quality for a stream type.\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {string} type - stream type, 'video' or 'audio'\n         * @return {number} the current quality level as an index of the quality (in bitrate ascending order)\n         */\n        getQualityFor: function (type) {\n            _isPlayerInitialized();\n            return this.abrController.getQualityFor(type);\n        },\n\n        /**\n         * Selects the quality for a stream type.\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {string} type - stream type, 'video' or 'audio'\n         * @param {number} value - the selected quality level as an index of the quality (in bitrate ascending order)\n         */\n        setQualityFor: function (type, value) {\n            _isPlayerInitialized();\n            if (typeof value !== 'number') {\n                throw new Error('MediaPlayer.setQualityFor(): Invalid Arguments');\n            }\n            this.abrController.setQualityFor(type, value);\n        },\n\n        /**\n         * Returns the auto switch quality state.\n         * @access public\n         * @memberof MediaPlayer#\n         * @return {boolean} the auto switch quality state\n         */\n        getAutoSwitchQuality: function() {\n            _isPlayerInitialized();\n            return this.abrController.getAutoSwitchBitrate();\n        },\n\n        /**\n         * Sets the auto switch quality state.\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {boolean} value - the new auto switch quality state\n         */\n        setAutoSwitchQuality: function(value) {\n            _isPlayerInitialized();\n            if (typeof value !== 'boolean') {\n                throw new Error('MediaPlayer.setAutoSwitchQuality(): Invalid Arguments');\n            }\n            this.abrController.setAutoSwitchBitrate(value);\n        },\n\n        /**\n         * Returns the buffering behaviour while the player is in pause.\n         * @access public\n         * @memberof MediaPlayer#\n         * @return {boolean} true if the player still buffers stream while in pause\n         */\n        getScheduleWhilePaused: function () {\n            return scheduleWhilePaused;\n        },\n\n        /**\n         * Sets the buffering behaviour while player is in pause.\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {boolean} value - true if the player has to buffer stream while in pause\n         */\n        setScheduleWhilePaused: function (value) {\n            if (typeof value !== 'boolean') {\n                throw new Error('MediaPlayer.setScheduleWhilePaused(): Invalid Arguments');\n            }\n            scheduleWhilePaused = value;\n        },\n\n        /**\n         * Sets the default audio language. If the default language is available in the stream,\n         * the corresponding audio track is selected. Otherwise, the first declared audio track in the manifest is selected.\n         * @method setDefaultAudioLang\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {string} lang - the default audio language based on ISO 3166-2\n         */\n        setDefaultAudioLang: function (language) {\n            if (typeof language !== 'string') {\n                throw new Error('MediaPlayer.setDefaultAudioLang(): Invalid Arguments');\n            }\n            defaultAudioLang = language;\n        },\n\n        /**\n         * Gets the default audio language.\n         * @method getDefaultAudioLang\n         * @access public\n         * @memberof MediaPlayer#\n         * @return {string} lang - the default audio language based on ISO 3166-2\n         */\n        getDefaultAudioLang: function(){\n            return defaultAudioLang;\n        },\n\n        /**\n         * Sets the default subtitle language. If the default language is available in the stream,\n         * the corresponding subtitle track is selected. Otherwise, the first declared subtitle track in the manifest is selected.\n         * @method setDefaultSubtitleLang\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {string} lang - the default subtitle language based on ISO 3166-2\n         */\n        setDefaultSubtitleLang: function (language) {\n            if (typeof language !== 'string') {\n                throw new Error('MediaPlayer.setDefaultSubtitleLang(): Invalid Arguments');\n            }\n            defaultSubtitleLang = language;\n        },\n\n        /**\n         * Gets the default subtitle language.\n         * @method getDefaultSubtitleLang\n         * @access public\n         * @memberof MediaPlayer#\n         * @return {string} lang - the default subtitle language based on ISO 3166-2\n         */\n        getDefaultSubtitleLang: function () {\n            return defaultSubtitleLang;\n        },\n//#endregion\n\n//#region PLAYBACK\n        /**\n         * Load/open a video stream.\n         * @method load\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {object} stream - video stream properties object such url, startTime, prodData ...\n            <pre>\n            {\n                url : \"[manifest url]\",\n                startTime : [start time in seconds (optional, only for static streams)],\n                startOver : [true if start-over DVR stream (optional)],\n                protocol : \"[protocol type]\", // 'HLS' to activate native support on Safari/OSx\n                protData : {\n                    // one entry for each key system ('com.microsoft.playready' or 'com.widevine.alpha')\n                    \"[key_system_name]\": {\n                        laURL: \"[licenser url (optional)]\",\n                        withCredentials: \"[license_request_withCredentials_value (true or false, optional)]\",\n                        pssh: \"[base64 pssh box (as Base64 string, optional)]\", // Considered for Widevine key system only\n                        cdmData: \"[CDM data (optional)]\", // Supported by PlayReady key system (using MS-prefixed EME API) only\n                        serverCertificate: \"[license_server_certificate (as Base64 string, optional)]\",\n                        audioRobustness: \"[audio_robustness_level (optional)]\", // Considered for Widevine key system only\n                        videoRobustness: \"[video_robustness_level (optional)]\" // Considered for Widevine key system only\n                    },\n                    ...\n               }\n               ...\n            }\n            </pre>\n        */\n        load: function (stream) {\n            var config = {\n                    video: {\n                        \"ABR.keepBandwidthCondition\": true\n                    },\n                    audio: {\n                        \"ABR.keepBandwidthCondition\": true\n                    }\n                };\n\n            // patch to be retro compatible with old syntax\n            if (arguments && arguments.length > 0 && typeof arguments[0] !== 'object') {\n                console.warn('You are using \"deprecated\" call of the method load, please refer to the documentation to change prameters call');\n                stream = _parseLoadArguments.apply(null, arguments);\n            }\n\n            if(!stream || !stream.url){\n                 throw new Error('MediaPlayer.load(): stream has no url.');\n            }\n\n            videoQualityChanged = [];\n            audioQualityChanged = [];\n\n            _isPlayerInitialized();\n\n            // Reset the player\n            this.reset(0);\n\n            // Set initial quality if first stream\n            if (initialQuality.video >= 0) {\n                this.abrController.setQualityFor('video', initialQuality.video);\n                config.video[\"ABR.keepBandwidthCondition\"] = false;\n                initialQuality.video = -1;\n            }\n\n            if (initialQuality.audio >= 0) {\n                this.abrController.setQualityFor('audio', initialQuality.audio);\n                config.audio[\"ABR.keepBandwidthCondition\"] = false;\n                initialQuality.audio = -1;\n            }\n\n            // Set config to set 'keepBandwidthCondition' parameter\n            this.setConfig(config);\n\n            // Reset last error and warning\n            error = null;\n            warning = null;\n\n            source = stream;\n            _resetAndPlay.call(this, 0);\n        },\n\n        /**\n        * Plays/resumes playback of the media.\n        * @method play\n        * @access public\n        * @memberof MediaPlayer#\n        */\n        play: function () {\n            _isPlayerInitialized();\n            videoModel.play();\n        },\n\n        /**\n         * Seeks the media to the new time. For LIVE streams, this function can be used to perform seeks within the DVR window if available.\n         * @method seek\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {number} time - the new time value in seconds\n         */\n        seek: function (time) {\n            var range = null,\n                liveDelay = 0;\n\n            _isPlayerInitialized();\n\n            if (typeof time !== 'number') {\n                throw new Error('MediaPlayer.seek(): Invalid Arguments');\n            }\n\n            if (!this.isLive()) {\n                if (time < 0 || time > videoModel.getDuration()) {\n                    throw new Error('MediaPlayer.seek(): seek value outside available time range');\n                } else {\n                    videoModel.setCurrentTime(time);\n                }\n            } else {\n                range = this.getDVRWindowRange();\n                liveDelay = streamController.getLiveDelay();\n                if (range === null) {\n                    throw new Error('MediaPlayer.seek(): impossible for live stream');\n                } else if (time < range.start || time > range.end) {\n                    throw new Error('MediaPlayer.seek(): seek value outside available time range');\n                } else {\n                    // Ensure we keep enough buffer\n                    if (time > (range.end - liveDelay)) {\n                        time = range.end - liveDelay;\n                    }\n                    streamController.seek(time, true);\n                }\n            }\n        },\n\n        /**\n         * Pauses the media playback.\n         * @method pause\n         * @access public\n         * @memberof MediaPlayer#\n         */\n        pause: function () {\n            _isPlayerInitialized();\n            videoModel.pause();\n        },\n\n        /**\n         * Stops the media playback and seek back to start of stream and media. Subsequently call to play() method will restart streaming and playing from beginning.\n         * @method stop\n         * @access public\n         * @memberof MediaPlayer#\n         */\n        stop: function () {\n            _isPlayerInitialized();\n            videoModel.pause();\n            //test if player is in VOD mode\n            if (!this.isLive()) {\n                videoModel.setCurrentTime(0);\n            }\n\n            // Notify plugins that current stream is stopped\n            for (var plugin in plugins) {\n                plugins[plugin].stop();\n            }\n        },\n\n        /**\n         * Stops and resets the player.\n         * @method reset\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {number} reason - the reason for stopping the player.\n         * Possible values are:\n         * <li>0 : stop during streaming at user request\n         * <li>1 : stop when all streams are completed\n         * <li>2 : stop after an error\n         */\n        reset: function (reason) {\n            _isPlayerInitialized();\n\n            // Reset ABR controller\n            this.setQualityFor('video', 0);\n            this.setQualityFor('audio', 0);\n\n            source = null;\n\n            _resetAndPlay.call(this, reason);\n        },\n\n        /**\n        * Updates the manifest URL. This method is used to provide an update of the manifest URL when the original\n        * URL provided in load() method is no more valid (for example if it has expired when signed)\n        * (see [manifestUrlUpdate]{@link MediaPlayer#event:manifestUrlUpdate} event specification).\n        * @method refeshManifest\n        * @access public\n        * @memberof MediaPlayer#\n        * param {string} url - the updated video stream's manifest URL\n        */\n        refreshManifest: function (url) {\n            _isPlayerInitialized();\n            streamController.refreshManifest(url);\n        },\n//#endregion\n\n//#region STREAM METADATA\n        /**\n         * Returns the media duration.\n         * @method getDuration\n         * @access public\n         * @memberof MediaPlayer#\n         * @return {number} the media duration in seconds, <i>Infinity</i> for live content\n         */\n        getDuration: function () {\n            _isPlayerInitialized();\n            return videoModel.getDuration();\n        },\n\n        /**\n         * Returns true if the current stream is a live stream.\n         * @method isLive\n         * @access public\n         * @memberof MediaPlayer#\n         * @return {boolean} true if current stream is a live stream, false otherwise\n         */\n        isLive: function () {\n            _isPlayerInitialized();\n            return videoModel.getDuration() !== Number.POSITIVE_INFINITY ? false : true;\n        },\n\n        /**\n         * Returns the current playback time/position.\n         * @method getPosition\n         * @access public\n         * @memberof MediaPlayer#\n         * @return {number} the current playback time/position in seconds\n         */\n        getPosition: function () {\n            _isPlayerInitialized();\n            return videoModel.getCurrentTime();\n        },\n\n        /**\n         * Return the available DVR window range in case of live streams.\n         * @method getDVRWindowRange\n         * @access public\n         * @memberOf MediaPlayer#\n         * @return {object} range - the DVR window range\n         * @return {number} range.start - the DVR window range start time\n         * @return {number} range.end - the DVR window range end time\n         * @return {number} range.programStart - the DVR window range absolute program start date/time (if available, may be undefined)\n         * @return {number} range.programEnd - the DVR window range absolute program end date/time (if available, may be undefined)\n         */\n        getDVRWindowRange: function () {\n            _isPlayerInitialized();\n            if (!this.isLive()) {\n                return null;\n            }\n            var dvrInfo = _getDVRInfoMetric.call(this);\n            return dvrInfo ? dvrInfo.range : null;\n        },\n\n        /**\n         * Returns the DVR window size.\n         * @method getDVRWindowSize\n         * @access public\n         * @memberof MediaPlayer#\n         * @return {number} the DVR window size in seconds\n         */\n        getDVRWindowSize: function () {\n            _isPlayerInitialized();\n            if (!this.isLive()) {\n                return null;\n            }\n            // TODO: get timeShiftBufferDepth\n            return null;\n            // var dvrInfo = _getDVRInfoMetric();\n            // return dvrInfo ? dvrInfo.mpd.timeShiftBufferDepth : null;;\n        },\n\n        /**\n         * TBD\n         * @method getDVRSeekOffset\n         * @access public\n         * @memberof MediaPlayer#\n         * @param  value\n         * @return DVR seek offset\n         */\n        getDVRSeekOffset: function (value) {\n            _isPlayerInitialized();\n            if (!this.isLive()) {\n                return null;\n            }\n            var dvrInfo = _getDVRInfoMetric.call(this),\n                val = dvrInfo ? dvrInfo.range.start + value : null;\n\n            if (val && val > dvrInfo.range.end) {\n                val = dvrInfo.range.end;\n            }\n\n            return val;\n        },\n\n        /**\n         * Returns the list of available bitrates (in bitrate ascending order).\n         * @method getVideoBitrates\n         * @access public\n         * @memberof MediaPlayer#\n         * @return {Array<Number>} array of bitrate values\n         */\n        getVideoBitrates: function () {\n            _isPlayerInitialized();\n            return videoBitrates.slice();\n        },\n\n        /**\n         * Returns the metrics for stream type.\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {string} type - stream type, 'video' or 'audio'\n         * @return {Array} the metrics array for the selected type\n         */\n        getMetricsFor: function(type) {\n            var metrics = this.metricsModel.getReadOnlyMetricsFor(type);\n            return metrics;\n        },\n//#endregion\n\n//#region TRICK MODE\n        /////////// TRICK MODE\n        /**\n         * Returns the current trick mode speed.\n         * @method setTrickModeSpeed\n         * @access public\n         * @memberof MediaPlayer#\n         * @return {number} the current trick mode speed\n         */\n        getTrickModeSpeed: function () {\n            if (streamController) {\n                return streamController.getTrickModeSpeed();\n            }\n\n            return 0;\n        },\n\n        /**\n         * Sets the trick mode speed.\n         * @method setTrickModeSpeed\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {number} speed - the new trick mode speed (0 corresponds to normal playback, i.e. playbackRate = 1)\n         */\n        setTrickModeSpeed: function (speed) {\n            _isPlayerInitialized();\n            if (streamController) {\n                streamController.setTrickModeSpeed(speed);\n            }\n        },\n//#endregion\n\n//#region ERROR/WARNING\n        /**\n         * Returns the Error object for the most recent error.\n         * @method getError\n         * @access public\n         * @memberof MediaPlayer#\n         * @return {object} the Error object for the most recent error, or null if there has not been an error\n        */\n        getError: function () {\n            return error;\n        },\n\n        /**\n         * Returns the Warning object for the most recent warning.\n         * @method getWarning\n         * @access public\n         * @memberof MediaPlayer#\n         * @return {object} the Warning object for the most recent warning, or null if there has not been a warning\n         */\n        getWarning: function () {\n            return warning;\n        },\n//#endregion\n\n//#region TRACKS\n        /**\n         * Returns the list of available tracks for the stream type (as specified in the stream manifest).\n         * The tracks list can be retrieved once the video 'loadeddata' event has been fired.\n         * @method getTracks\n         * @access public\n         * @param {String} type - the stream type according to MediaPlayer.TRACKS_TYPE (see @link MediaPlayer#TRACKS_TYPE)\n         * @memberof MediaPlayer#\n         * @return {Array<Track>} the available tracks for the stream type\n         */\n        getTracks: function (type) {\n\n            _isPlayerInitialized();\n\n            if (!type || (type !== MediaPlayer.TRACKS_TYPE.AUDIO && type !== MediaPlayer.TRACKS_TYPE.TEXT)) {\n                throw new Error('MediaPlayer Invalid Argument - \"type\" should be defined and shoud be kind of MediaPlayer.TRACKS_TYPE');\n            }\n\n            var _tracks = _getTracksFromType(type);\n\n            if (!_tracks) {\n                return [];\n            }\n\n            var tracks = [];\n            for (var i = 0; i < _tracks.length; i += 1) {\n                tracks.push(_toMediaPlayerTrack(_tracks[i]));\n            }\n\n            return tracks;\n        },\n\n        /**\n         * Selects the track to be playbacked for the stream type.\n         * @method selectTrack\n         * @access public\n         * @memberof MediaPlayer#\n         * @see [getTracks]{@link MediaPlayer#getTracks}\n         * @param {String} type - the stream type according to MediaPlayer.TRACKS_TYPE (see @link MediaPlayer#TRACKS_TYPE)\n         * @param {Track} track - the track to select, as returned by the [getTracks]{@link MediaPlayer#getTracks} method\n         *\n         */\n        selectTrack: function (type, track) {\n\n            _isPlayerInitialized();\n\n            if (!type || (type !== MediaPlayer.TRACKS_TYPE.AUDIO && type !== MediaPlayer.TRACKS_TYPE.TEXT)) {\n                throw new Error('MediaPlayer Invalid Argument - \"type\" should be defined and shoud be kind of MediaPlayer.TRACKS_TYPE');\n            }\n\n            if (!track || !(track.id || track.lang || track.subType)) {\n                throw new Error('MediaPlayer.selectTrack(): track parameter is not in valid');\n            }\n\n            var _tracks = _getTracksFromType(type);\n\n            if (!_tracks) {\n                this.debug.error(\"[MediaPlayer] No available track for type \" + type);\n                return;\n            }\n            var selectedTrack = _getSelectedTrackFromType(type);\n\n            if (selectedTrack && _isSameTrack(selectedTrack, track)) {\n                this.debug.log(\"[MediaPlayer] \" + type + \" track [\" + track.id + \" - \" + track.lang + \"] is already selected\");\n                return;\n            }\n\n            for (var i = 0; i < _tracks.length; i += 1) {\n                if (_isSameTrack(_tracks[i], track)) {\n                    _selectTrackFromType(type, _tracks[i]);\n                    return;\n                }\n            }\n        },\n\n        /**\n         * Returns the selected track for the stream type.\n         * @method getSelectedTrack\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {String} type - the stream type according to MediaPlayer.TRACKS_TYPE (see @link MediaPlayer#TRACKS_TYPE)\n         * @return {Track} the selected track\n         */\n        getSelectedTrack: function (type) {\n            _isPlayerInitialized();\n\n            if (!type || (type !== MediaPlayer.TRACKS_TYPE.AUDIO && type !== MediaPlayer.TRACKS_TYPE.TEXT)) {\n                throw new Error('MediaPlayer Invalid Argument - \"type\" should be defined and shoud be kind of MediaPlayer.TRACKS_TYPE');\n            }\n\n            return _toMediaPlayerTrack(_getSelectedTrackFromType(type));\n        },\n//#endregion\n\n//#region SUBTITLES DISPLAY\n        /**\n         * Enable or disables subtitles processing.\n         * @method enableSubtitles\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {boolean} value - true to enable subtitles, false to disables subtitles processing (by default subtitles are disabled)\n         */\n        enableSubtitles: function (value) {\n            _isPlayerInitialized();\n            if (typeof value !== 'boolean') {\n                throw new Error('MediaPlayer.enableSubtitles(): Invalid Arguments');\n            }\n            subtitlesEnabled = value;\n            if (streamController) {\n                streamController.enableSubtitles(subtitlesEnabled);\n            }\n        },\n\n        /**\n        * Returns the subtitles processing state.\n        * @method isSubtitlesEnabled\n        * @access public\n        * @memberof MediaPlayer#\n        * @return {boolean} true if subtitles are enabled, false otherwise\n        */\n        isSubtitlesEnabled: function () {\n            _isPlayerInitialized();\n            return subtitlesEnabled;\n        },\n\n        /**\n         * Enables or disables subtitles display in a div outside video player.\n         * @method enableSubtitleExternDisplay\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {boolean} mode - true if subtitles are displayed in a div outside video player\n         */\n        enableSubtitleExternDisplay: function (value) {\n            if (typeof value !== 'boolean') {\n                throw new Error('MediaPlayer.enableSubtitleExternDisplay(): Invalid Arguments');\n            }\n            this.config.setParams({'TextTrackExtensions.displayModeExtern': value});\n        },\n\n        /**\n         * Returns the HTML div element previously attached (@see [attachTTMLRenderingDiv]{@link MediaPlayer#attachTTMLRenderingDiv})\n         * @method getTTMLRenderingDiv\n         * @access public\n         * @memberof MediaPlayer#\n         * @returns {HTMLDivElement} the HTML div object previously attached\n         */\n        getTTMLRenderingDiv: function() {\n            return videoModel ? videoModel.getTTMLRenderingDiv() : null;\n        },\n\n        /**\n         * Attaches an HTML div element to be used to render rich TTML subtitles.\n         * @method attachTTMLRenderingDiv\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {HTMLDivElement} div - An unstyled div element placed after the video element. It will be styled to match the video size and overlay z-order\n         */\n        attachTTMLRenderingDiv: function(div) {\n            _isPlayerInitialized();\n            videoModel.setTTMLRenderingDiv(div);\n        },\n//#endregion\n\n//#region AUDIO VOLUME\n        /**\n         * Returns the audio mute state.\n         * @method getMute\n         * @access public\n         * @memberof MediaPlayer#\n         * @return {boolean} true if the audio is muted, false otherwise\n         */\n        getMute: function () {\n            _isPlayerInitialized();\n            return videoModel.getMute();\n        },\n\n        /**\n         * Sets the audio mute state.\n         * @method setMute\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {boolean} value - true to mute audio, false otherwise\n         */\n        setMute: function (value) {\n            _isPlayerInitialized();\n            if (typeof value !== 'boolean') {\n                throw new Error('MediaPlayer.setMute(): Invalid Arguments');\n            }\n            videoModel.setMute(value);\n        },\n\n        /**\n         * Returns the audio volume level.\n         * @method getVolume\n         * @access public\n         * @memberof MediaPlayer#\n         * @return {number} the current audio volume level, from 0.0 (silent) to 1.0 (loudest)\n         */\n        getVolume: function () {\n            _isPlayerInitialized();\n            return videoModel.getVolume();\n        },\n\n        /**\n         * Sets the audio volume level.\n         * @method setVolume\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {number} level - the audio volume level, from 0.0 (silent) to 1.0 (loudest)\n         */\n        setVolume: function (level) {\n            _isPlayerInitialized();\n            if ((typeof level !== 'number') || level < 0 || level > 1) {\n                throw new Error('MediaPlayer.setVolume(): Invalid Arguments');\n            }\n\n            videoModel.setVolume(level);\n        },\n//#endregion\n\n//#region TERMINAL ID\n        /**\n         * Returns the terminal ID.\n         * @method getTerminalId\n         * @access public\n         * @memberof MediaPlayer#\n         * @return {string} the terminal ID (<OS name>-<OS bits>-<browser name>)\n         */\n        getTerminalId: function () {\n            var browser = fingerprint_browser(),\n                os = fingerprint_os();\n\n            return os.name + \"-\" + os.bits + \"-\" + browser.name;\n        },\n//#endregion\n\n//#region PLUGINS\n        /**\n         * Adds a MediaPlayer plugin.\n         * @method addPlugin\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {object} plugin - the plugin instance\n         */\n        addPlugin: function (plugin) {\n            _isPlayerInitialized();\n\n            if (plugin === undefined) {\n                throw new Error('MediaPlayer.addPlugin(): plugin undefined');\n            }\n\n            // Check plugin API\n            if (typeof(plugin.getName) !== 'function' ||\n                typeof(plugin.getVersion) !== 'function' ||\n                typeof(plugin.init) !== 'function' ||\n                typeof(plugin.load) !== 'function' ||\n                typeof(plugin.stop) !== 'function' ||\n                typeof(plugin.reset) !== 'function') {\n                throw new Error('MediaPlayer.addPlugin(): plugin API not compliant');\n            }\n\n            if (plugins[plugin.getName()]) {\n                // Destroy plugin already loaded\n                plugins[plugin.getName()].destroy();\n            }\n\n            this.debug.log(\"[MediaPlayer] Add plugin '\" + plugin.getName() + \"' (v\" + plugin.getVersion() + \")\");\n\n            // Store plugin\n            plugins[plugin.getName()] = plugin;\n\n            // Initialize plugin (if player initialized)\n            plugin.deferInit = Q.defer();\n            if (initialized) {\n                plugin.init(this, function () {\n                    this.deferInit.resolve();\n                }.bind(plugin));\n            }\n        },\n\n        /**\n         * Removes a MediaPlayer plugin.\n         * @method removePlugin\n         * @access public\n         * @memberof MediaPlayer#\n         * @param {object|string} plugin - the plugin instance (or name) to remove\n         */\n        removePlugin: function (plugin) {\n            var name;\n\n            if (plugin === undefined) {\n                throw new Error('MediaPlayer.removePlugin(): plugin undefined');\n            }\n\n            if (typeof(plugin) === 'string') {\n                name = plugin;\n            } else {\n                if (typeof(plugin.getName) !== 'function') {\n                    throw new Error('MediaPlayer.removePlugin(): plugin API not compliant');\n                }\n                name = plugin.getName();\n            }\n\n            if (plugins[name]) {\n                this.debug.log(\"[MediaPlayer] Remove plugin '\" + name);\n                // Reset plugin\n                plugins[name].destroy();\n                // delete it\n                plugins[name] = null;\n                delete plugins[name];\n            }\n        }\n//#endregion\n    };\n};\n\nMediaPlayer.prototype = {\n    constructor: MediaPlayer\n};\n\n//#region Packages\n/**\n * Packages declaration\n */\nMediaPlayer.dependencies = {};\nMediaPlayer.dependencies.protection = {};\nMediaPlayer.dependencies.protection.servers = {};\nMediaPlayer.utils = {};\nMediaPlayer.models = {};\nMediaPlayer.modules = {};\nMediaPlayer.vo = {};\nMediaPlayer.vo.metrics = {};\nMediaPlayer.vo.protection = {};\nMediaPlayer.rules = {};\nMediaPlayer.rules.o = {};\nMediaPlayer.di = {};\n//#endregion\n\n//#region Enums\n/**\n * ENUMS\n */\nMediaPlayer.PUBLIC_EVENTS = {\n    /**\n     * The error event is fired when an error occurs.\n     * When the error event is fired, the application shall stop the player.\n     *\n     * @event MediaPlayer#error\n     * @param {object} event - the event\n     * @param {object} event.type - the event type ('error')\n     * @param {object} event.data - the event data\n     * @param {string} event.data.code - error code\n     * @param {string} event.data.message - error message\n     * @param {object} event.data.data - error additionnal data\n     */\n    'error': 'hasplayer',\n\n    /**\n    * The warning event is fired when a warning occurs.\n    *\n    * @event MediaPlayer#warning\n    * @param {object} event - the event\n    * @param {object} event.type - the event type ('warning')\n    * @param {object} event.data - the event data\n    * @param {string} event.data.code - warning code\n    * @param {string} event.data.message - warning message\n    * @param {object} event.data.data - warning additionnal data\n    */\n    'warning': 'hasplayer',\n\n    /**\n     * The manifestUrlUpdate event is fired when the URL of the manifest may have to be refreshed,\n     * since the player failed to download the manifest file (URL expiration for example).\n     * The application shall therefore provide an updated manifest URL by using the method [refreshManifest]{@link MediaPlayer#refreshManifest}\n     *\n     * @event MediaPlayer#manifestUrlUpdate\n     * @param {object} event - the event\n     * @param {object} event.type - the event type ('manifestUrlUpdate')\n     * @param {object} event.data - the event data\n     * @param {object} event.data.url - the current manifest url\n     */\n    'manifestUrlUpdate': 'hasplayer',\n\n    /**\n     * The metricAdded event is fired when a new metric has been added,\n     * TBD\n     */\n    'metricAdded' : 'hasplayer',\n\n    /**\n     * The metricChanged event is fired when a metric has been updated,\n     * TBD\n     */\n    'metricChanged' : 'hasplayer',\n\n    /**\n     * The cueEnter event is fired when a subtitle cue needs to be displayed.\n     *\n     * @event MediaPlayer#cueEnter\n     * @param {object} event - the event\n     * @param {object} event.type - the event type ('cueEnter')\n     * @param {object} event.data - the event data\n     * @param {object} event.data.text - the subtitle text\n     * @param {string} event.data.style.backgroundColor - the background color\n     * @param {string} event.data.style.color - the font color\n     * @param {string} event.data.style.fontFamily - the font family\n     * @param {string} event.data.style.fontSize - the font size\n     */\n    'cueEnter': 'hasplayer',\n\n    /**\n     * The cueExit event is fired when a subtitle cue needs to be erased.\n     *\n     * @event MediaPlayer#cueExit\n     * @param {object} event - the event\n     * @param {object} event.type - the event type ('cueExit')\n     * @param {object} event.data - the event data\n     * @param {object} event.data.text - the subtitle text\n     * @param {string} event.data.style.backgroundColor - the background color\n     * @param {string} event.data.style.color - the font color\n     * @param {string} event.data.style.fontFamily - the font family\n     * @param {string} event.data.style.fontSize - the font size\n     */\n    'cueExit': 'hasplayer',\n\n    /**\n     * The 'play_bitrate' event is fired when the current played bitrate has changed.\n     *\n     * @event MediaPlayer#play_bitrate\n     * @param {CustomEvent} event - the event\n     * @param {object} event.detail - the event data\n     * @param {string} event.detail.type - the stream type ('audio' or 'video')\n     * @param {number} event.detail.bitrate - the new bitrate\n     * @param {string} event.detail.representationId - the corresponding representation id (from manifest)\n     * @param {number} event.detail.time - the current video time\n     * @param {number} event.detail.width - in case of video stream, the video width of the representation\n     * @param {number} event.detail.height - in case of video stream, the video height of the representation\n     */\n    'play_bitrate': 'video',\n\n    /**\n     * The download_bitrate event is fired when the current downloaded bitrate has changed.\n     *\n     * @event MediaPlayer#download_bitrate\n     * @param {CustomEvent} event - the event\n     * @param {object} event.detail - the event data\n     * @param {string} event.detail.type - the stream type ('audio' or 'video')\n     * @param {number} event.detail.bitrate - the new bitrate\n     * @param {string} event.detail.representationId - the corresponding representation id (from manifest)\n     * @param {number} event.detail.time - the current video time\n     * @param {number} event.detail.width - in case of video stream, the video width of the representation\n     * @param {number} event.detail.height - in case of video stream, the video height of the representation\n     */\n    'download_bitrate': 'video',\n\n    /**\n     * The bufferLevel_updated event is fired when the buffer level changed.\n     *\n     * @event MediaPlayer#bufferLevel_updated\n     * @param {CustomEvent} event - the event\n     * @param {object} event.detail - the event data\n     * @param {string} event.detail.type - the stream type ('audio' or 'video')\n     * @param {number} event.detail.level - the buffer level (in seconds)\n     */\n    'bufferLevel_updated': 'video',\n\n    /**\n     * The state_changed event is fired when the player state changed.\n     *\n     * @event MediaPlayer#state_changed\n     * @param {CustomEvent} event - the event\n     * @param {object} event.detail - the event data\n     * @param {string} event.detail.type - the stream type ('audio' or 'video')\n     * @param {string} event.detail.state - the current state ('stopped', 'buffering', 'seeking' or 'playing')\n     */\n    'state_changed': 'video'\n};\n\n/**\n * Exposes the available tracks types used to manage tracks (language) switching.\n * @see [getTracks]{@link MediaPlayer#getTracks}\n * @see [getSelectedTrack]{@link MediaPlayer#getSelectedTrack}\n * @see [selectTrack]{@link MediaPlayer#selectTrack}\n * @enum\n */\nMediaPlayer.TRACKS_TYPE = {\n    AUDIO: \"audio\",\n    TEXT: \"text\"\n};\n//#endregion\n\n//#region Player parameters\n/**\n * Player parameters object.\n * All parameters values are applied for any stream type. Parameters can be overriden specifically for audio and video track by setting\n * parameters values in the params.audio and params.video objects.\n * @typedef MediaPlayer#PlayerParams\n * @type Object\n * @property {number}   BufferController.minBufferTimeForPlaying - Minimum buffer level before playing, in seconds (default value = 0)\n * @property {number}   BufferController.minBufferTime - Minimum buffer size (in seconds), if set to '-1' the maximum value between the manifest's minBufferTime and 16 sec. is considered (default value = -1)\n * @property {number}   BufferController.bufferToKeep - The buffer size (in seconds) to keep anterior to current playing time (default value = 30)\n * @property {number}   BufferController.liveDelay - The delay (in seconds) between the live edge and playing time, if set to '-1' the live delay is set according to minBufferTime (default value = -1)\n * @property {number}   ABR.minBandwidth - Minimum bandwidth to be playbacked (default value = -1)\n * @property {number}   ABR.maxBandwidth - Maximum bandwidth to be playbacked (default value = -1)\n * @property {number}   ABR.minQuality - Minimum quality index (start from 0) to be playbacked (default value = -1)\n * @property {number}   ABR.maxQuality - Maximum quality index (start from 0) to be playbacked (default value = -1)\n * @property {boolean}  ABR.switchUpIncrementally - Switch up quality incrementally, or not (default value = false)\n * @property {number}   ABR.switchUpRatioSafetyFactor - Switch up bandwith ratio safety factor (default value = 1.5)\n * @property {boolean}  ABR.latencyInBandwidth - Include (or not) latency in bandwidth (default value = true)\n * @property {number}   ABR.switchLowerBufferTime - Buffer level (in seconds) under which switching down to lowest quality occurs (default value = -1)\n * @property {number}   ABR.switchLowerBufferRatio - Buffer level (as percentage of buffer size) under which switching down to lowest quality occurs (default value = 0.25)\n * @property {number}   ABR.switchDownBufferTime - Buffer level (in seconds) under which switching down quality occur, if unsufficient bandwidth (default value = -1)\n * @property {number}   ABR.switchDownBufferRatio - Buffer level (as percentage of buffer size) under which switching down quality occurs, if unsufficient bandwidth (default value = 0.5)\n * @property {number}   ABR.switchUpBufferTime - Buffer level (in seconds) upper which switching up quality occurs, if sufficient bandwidth (default value = -1)\n * @property {number}   ABR.switchUpBufferRatio - Buffer level (as percentage of buffer size) upper which switching up quality occurs, if sufficient bandwidth (default value = 0.75)\n * @property {number}   ManifestLoader.RetryAttempts - Number of retry attempts for downloading manifest file when it fails (default value = 2)\n * @property {number}   ManifestLoader.RetryInterval - Interval (in milliseconds) between each retry attempts for downloading manifest file (default value = 500)\n * @property {number}   FragmentLoader.RetryAttempts - Number of retry attempts for downloading segment files when it fails (default value = 2)\n * @property {number}   FragmentLoader.RetryInterval - Interval (in milliseconds) between each retry attempts for downloading segment files (default value = 500)\n * @property {boolean}  Protection.licensePersistence - Provides or not license persistence at application level, in case no persistence is provided by the CDM (default value = false)\n * @property {Object}   video - Video parameters (parameters for video track)\n * @property {Object}   audio - audio parameters (parameters for audio track)\n */\n//#endregion\n\n//#region Static functions\n/**\n * Static functions\n */\n/**\n* Returns the current browser status on MSE support.\n* @method hasMediaSourceExtension\n* @static\n* @return true if MSE is supported, false otherwise\n*/\nMediaPlayer.hasMediaSourceExtension = function () {\n    return new MediaPlayer.utils.Capabilities().supportsMediaSource();\n};\n\n/**\n * Returns the current browser status on EME support.\n * @method hasMediaKeysExtension\n * @static\n * @return true if EME is supported, false otherwise\n */\nMediaPlayer.hasMediaKeysExtension = function () {\n    return new MediaPlayer.utils.Capabilities().supportsMediaKeys();\n};\n//#endregion\n","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.dependencies.AbrController = function() {\n    \"use strict\";\n\n    var autoSwitchBitrate = true,\n        autoSwitchDic = {},\n        qualityDict = {},\n        qualityMaxDict = {},\n        confidenceDict = {},\n        playerState = \"\",\n\n        getInternalAutoSwitch = function(type) {\n            if (!autoSwitchDic.hasOwnProperty(type)) {\n                autoSwitchDic[type] = true;\n            }\n            return autoSwitchDic[type];\n        },\n\n        setInternalAutoSwitch = function(type, value) {\n            autoSwitchDic[type] = value;\n        },\n\n        getInternalQuality = function(type) {\n            var quality;\n\n            if (!qualityDict.hasOwnProperty(type)) {\n                qualityDict[type] = 0;\n            }\n\n            quality = qualityDict[type];\n\n            return quality;\n        },\n\n        setInternalQuality = function(type, value) {\n            qualityDict[type] = value;\n        },\n\n        getInternalConfidence = function(type) {\n            var confidence;\n\n            if (!confidenceDict.hasOwnProperty(type)) {\n                confidenceDict[type] = 0;\n            }\n\n            confidence = confidenceDict[type];\n\n            return confidence;\n        },\n\n        setInternalConfidence = function(type, value) {\n            confidenceDict[type] = value;\n        },\n\n        getRulesRequestQuality = function(type, data) {\n            var self = this,\n                autoSwitch = getInternalAutoSwitch(type),\n                quality = getInternalQuality(type),\n                confidence = getInternalConfidence(type),\n                newQuality = MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE,\n                newConfidence = MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE,\n                qualityMax = MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE,\n                i,\n                len,\n                results = [],\n                metrics,\n                req,\n                values = {},\n                rules,\n                max;\n\n            if (!autoSwitchBitrate || !autoSwitch) {\n                self.debug.log(\"[AbrController][\" + type + \"] ABR disabled\");\n                return {\n                    quality: quality,\n                    confidence: confidence\n                };\n            }\n\n            self.debug.log(\"[AbrController][\" + type + \"] Check rules....\");\n\n            metrics = self.getMetricsFor(data);\n            rules = self.abrRulesCollection.getRules(MediaPlayer.rules.BaseRulesCollection.prototype.QUALITY_SWITCH_RULES);\n            for (i = 0, len = rules.length; i < len; i += 1) {\n                results.push(rules[i].checkIndex(quality, metrics, data, playerState));\n            }\n\n            values[MediaPlayer.rules.SwitchRequest.prototype.STRONG] = MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE;\n            values[MediaPlayer.rules.SwitchRequest.prototype.WEAK] = MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE;\n            values[MediaPlayer.rules.SwitchRequest.prototype.DEFAULT] = MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE;\n\n            for (i = 0, len = results.length; i < len; i += 1) {\n                req = results[i];\n                if (req.quality !== MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE) {\n                    self.debug.log(\"[AbrController][\" + type + \"] Request for quality \" + req.quality + \", priority = \" + req.priority + \" (\" + rules[i].name + \")\");\n                    values[req.priority] = Math.min(values[req.priority], req.quality);\n                }\n\n                if (req.max === true) {\n                    qualityMax = Math.min(qualityMax, req.quality);\n                }\n            }\n\n            if (values[MediaPlayer.rules.SwitchRequest.prototype.WEAK] !== MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE) {\n                newConfidence = MediaPlayer.rules.SwitchRequest.prototype.WEAK;\n                newQuality = values[MediaPlayer.rules.SwitchRequest.prototype.WEAK];\n            }\n\n            if (values[MediaPlayer.rules.SwitchRequest.prototype.DEFAULT] !== MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE) {\n                newConfidence = MediaPlayer.rules.SwitchRequest.prototype.DEFAULT;\n                newQuality = values[MediaPlayer.rules.SwitchRequest.prototype.DEFAULT];\n            }\n\n            if (values[MediaPlayer.rules.SwitchRequest.prototype.STRONG] !== MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE) {\n                newConfidence = MediaPlayer.rules.SwitchRequest.prototype.STRONG;\n                newQuality = values[MediaPlayer.rules.SwitchRequest.prototype.STRONG];\n            }\n\n            if (newQuality !== MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE && newQuality !== undefined) {\n                quality = newQuality;\n            }\n\n            if (newConfidence !== MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE && newConfidence !== undefined) {\n                confidence = newConfidence;\n            }\n\n            if (qualityMax !== MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE) {\n                qualityMaxDict[type] = qualityMax;\n            }\n\n            max = self.manifestExt.getRepresentationCount(data);\n            // Ensure valid quality index\n            if (quality < 0) {\n                quality = 0;\n            }\n            if (quality >= max) {\n                quality = max - 1;\n            }\n\n            if (confidence !== MediaPlayer.rules.SwitchRequest.prototype.STRONG &&\n                confidence !== MediaPlayer.rules.SwitchRequest.prototype.WEAK) {\n                confidence = MediaPlayer.rules.SwitchRequest.prototype.DEFAULT;\n            }\n\n            self.debug.info(\"[AbrController][\" + type + \"] Request quality: \" + quality);\n\n            return {\n                quality: quality,\n                confidence: confidence\n            };\n        },\n\n        getQualityBoundaries = function(type, data) {\n            var bitrates = this.metricsExt.getBitratesForType(type, data),\n                qualityMin = this.config.getParamFor(type, \"ABR.minQuality\", \"number\", -1),\n                qualityMax = this.config.getParamFor(type, \"ABR.maxQuality\", \"number\", -1),\n                bandwidthMin = this.config.getParamFor(type, \"ABR.minBandwidth\", \"number\", -1),\n                bandwidthMax = this.config.getParamFor(type, \"ABR.maxBandwidth\", \"number\", -1),\n                i,\n                count = bitrates.length;\n\n            if (bandwidthMin !== -1) {\n                for (i = 0; i < bitrates.length; i++) {\n                    if (bitrates[i] >= bandwidthMin) {\n                        qualityMin = (qualityMin === -1) ? i : Math.max(i, qualityMin);\n                        break;\n                    }\n                }\n            }\n\n            if (bandwidthMax !== -1) {\n                for (i = bitrates.length - 1; i >= 0; i--) {\n                    if (bitrates[i] <= bandwidthMax) {\n                        qualityMax = (qualityMax === -1) ? i : Math.min(i, qualityMax);\n                        break;\n                    }\n                }\n            }\n\n            qualityMin = (qualityMin >= count) ? (count - 1) : qualityMin;\n            qualityMin = (qualityMin < 0) ? 0 : qualityMin;\n            qualityMax = (qualityMax >= count || qualityMax < 0) ? (count - 1) : qualityMax;\n\n            return {\n                min: qualityMin,\n                max: qualityMax\n            };\n\n        };\n\n    return {\n        debug: undefined,\n        abrRulesCollection: undefined,\n        manifestExt: undefined,\n        metricsModel: undefined,\n        metricsExt: undefined,\n        config: undefined,\n\n        getAutoSwitchBitrate: function() {\n            return autoSwitchBitrate;\n        },\n\n        setAutoSwitchBitrate: function(value) {\n            this.debug.log(\"[AbrController] Set auto switch: \" + value);\n            autoSwitchBitrate = value;\n        },\n\n        getMetricsFor: function(data) {\n            var isVideo,\n                isAudio;\n\n            isVideo = this.manifestExt.getIsVideo(data);\n            if (isVideo) {\n                return this.metricsModel.getMetricsFor(\"video\");\n            } else {\n                isAudio = this.manifestExt.getIsAudio(data);\n                if (isAudio) {\n                    return this.metricsModel.getMetricsFor(\"audio\");\n                } else {\n                    return this.metricsModel.getMetricsFor(\"stream\");\n                }\n            }\n        },\n\n        getPlaybackQuality: function(type, data) {\n            var self = this,\n                previousQuality = this.getQualityFor(type),\n                qualityMin = -1,\n                qualityMax = -1,\n                quality,\n                confidence,\n                switchUpIncrementally = this.config.getParamFor(type, \"ABR.switchUpIncrementally\", \"boolean\", false),\n                result;\n\n            result = getRulesRequestQuality.call(this, type, data);\n            quality = result.quality;\n            confidence = result.confidence;\n\n            if (self.getAutoSwitchBitrate()) {\n                // Check incremental switch\n                if (switchUpIncrementally && (quality > previousQuality)) {\n                    self.debug.log(\"[AbrController][\" + type + \"] Incremental switch => quality: \" + quality);\n                    quality = previousQuality + 1;\n                }\n\n                // Check representation boundaries\n                var qualityBoundaries = getQualityBoundaries.call(self, type, data);\n                qualityMin = qualityBoundaries.min;\n                qualityMax = qualityBoundaries.max;\n\n                if (quality < qualityMin) {\n                    quality = qualityMin;\n                    self.debug.log(\"[AbrController][\" + type + \"] New quality < min => \" + quality);\n                }\n\n                if (quality > qualityMax) {\n                    quality = qualityMax;\n                    self.debug.log(\"[AbrController][\" + type + \"] New quality > max => \" + quality);\n                }\n\n                // Check max quality allowed by the rules (see DroppedFramesRule for example)\n                if (quality > qualityMaxDict[type]) {\n                    quality = qualityMaxDict[type];\n                    self.debug.log(\"[AbrController][\" + type + \"] Max allowed quality = \" + quality);\n                }\n            }\n\n            setInternalQuality.call(self, type, quality);\n            setInternalConfidence.call(self, type, confidence);\n\n            self.debug.info(\"[AbrController][\" + type + \"] Set quality: \" + quality);\n            return {\n                quality: quality,\n                confidence: confidence\n            };\n        },\n\n        getAutoSwitchFor: function(type) {\n            return getInternalAutoSwitch(type);\n        },\n\n        setAutoSwitchFor: function(type, value) {\n            var autoSwitch = getInternalAutoSwitch(type);\n            if (value !== autoSwitch) {\n                this.debug.log(\"[AbrController][\" + type + \"] Set auto switch: \" + value);\n                setInternalAutoSwitch(type, value);\n            }\n        },\n\n        getQualityFor: function(type) {\n            return getInternalQuality(type);\n        },\n\n        setQualityFor: function(type, value) {\n            var quality = getInternalQuality(type);\n            if (value !== quality) {\n                this.debug.log(\"[AbrController][\" + type + \"] Set playback quality: \" + value);\n                setInternalQuality(type, value);\n            }\n        },\n\n        isMinQuality: function(type, data, value) {\n            var qualityBoundaries = getQualityBoundaries.call(this, type, data);\n            return value <= qualityBoundaries.min;\n        },\n\n        setPlayerState: function(state) {\n            playerState = state;\n        }\n    };\n};\n\nMediaPlayer.dependencies.AbrController.prototype = {\n    constructor: MediaPlayer.dependencies.AbrController\n};\n\nMediaPlayer.dependencies.AbrController.BANDWIDTH_SAFETY = 0.9;","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.dependencies.BufferController = function() {\n    \"use strict\";\n    var READY = \"READY\",\n        state = READY,\n        ready = false,\n        started = false,\n        waitingForBuffer = false,\n        initialPlayback = true,\n        initializationData = [],\n        seeking = false,\n        seekTarget = -1,\n        dataChanged = true,\n        trackChanged = false,\n        overrideBuffer = false,\n        availableRepresentations,\n        _currentRepresentation,\n        currentBufferedQuality = -1,\n        currentDownloadQuality = -1,\n        stalled = false,\n        isDynamic = false,\n        isBufferingCompleted = false,\n        deferredRejectedDataAppend = null,\n        periodInfo = null,\n        fragmentsToLoad = 0,\n        fragmentModel = null,\n        bufferLevel = 0,\n        isQuotaExceeded = false,\n        rejectedBytes = null,\n        appendingRejectedData = false,\n        mediaSource,\n        type,\n        data = null,\n        buffer = null,\n        minBufferTime,\n        minBufferTimeAtStartup,\n        bufferToKeep,\n        liveDelay,\n        bufferTimeout,\n        bufferStateTimeout,\n        trickModeEnabled = false,\n        trickModePreviousQuality = 0,\n        trickModePreviousAutoSwitch = true,\n        trickModeForward = false,\n\n        playListMetrics = null,\n        playListTraceMetrics = null,\n        playListTraceMetricsClosed = true,\n\n        inbandEventFound = false,\n\n        // Buffering state\n        INIT = -1,\n        BUFFERING = 0,\n        PLAYING = 1,\n        htmlVideoState = INIT,\n        htmlVideoTime = -1,\n\n        deferredFragmentBuffered = null,\n\n        // Segment download failure recovery\n        SEGMENT_DOWNLOAD_ERROR_MAX = 3,\n        segmentDownloadErrorCount = 0,\n        segmentRequestOnError = null,\n\n        // HLS chunk sequence number\n        currentSequenceNumber = -1,\n        playlistRefreshTimeout = null,\n\n        segmentDuration = NaN,\n\n        // Patch for Safari: do not remove past buffer in live use case since it generates MEDIA_ERROR_DECODE while appending new segment (see hasEnoughSpaceToAppend())\n        isSafari = (fingerprint_browser().name === \"Safari\"),\n\n        // Patch for Firefox: set buffer timestampOffset since on Firefox timestamping is based on CTS (see OnMediaLoaded())\n        isFirefox = (fingerprint_browser().name === \"Firefox\"),\n\n        sendRequest = function() {\n\n            if (!isRunning.call(this)) {\n                return;\n            }\n\n            if (fragmentModel !== null) {\n                this.fragmentController.onBufferControllerStateChange();\n            }\n        },\n\n        clearPlayListTraceMetrics = function(endTime, stopreason) {\n            var duration = 0,\n                startTime = null;\n\n            if (playListTraceMetricsClosed === false) {\n                startTime = playListTraceMetrics.start;\n                duration = endTime.getTime() - startTime.getTime();\n\n                playListTraceMetrics.duration = duration;\n                playListTraceMetrics.stopreason = stopreason;\n\n                playListTraceMetricsClosed = true;\n            }\n        },\n\n        setStalled = function(value) {\n            if (type === \"text\") {\n                return;\n            }\n\n            this.debug.info(\"[BufferController][\" + type + \"] stalled = \" + value);\n            stalled = value;\n            this.videoModel.stallStream(type, stalled);\n\n            // Notify ABR controller we start buffering in order to adapt ABR rules (see InsufficientbufferRule)\n            this.abrController.setPlayerState(stalled ? \"buffering\" : \"playing\");\n        },\n\n        startPlayback = function() {\n            if (!ready || !started) {\n                return;\n            }\n\n            this.debug.info(\"[BufferController][\" + type + \"] startPlayback\");\n\n            // Set media type to stalled state\n            setStalled.call(this, true);\n\n            // Start buffering process\n            checkIfSufficientBuffer.call(this);\n        },\n\n        doStart = function() {\n            var currentTime;\n\n            if (started === true) {\n                return;\n            }\n\n            // We check also if buffering process is not already started\n            // This may happen if doStart is called by Stream on 'play' event after a seek\n            if (deferredFragmentBuffered !== null) {\n                return;\n            }\n\n            if (seeking === false) {\n                currentTime = new Date();\n                clearPlayListTraceMetrics(currentTime, MediaPlayer.vo.metrics.PlayList.Trace.USER_REQUEST_STOP_REASON);\n                playListMetrics = this.metricsModel.addPlayList(type, currentTime, 0, MediaPlayer.vo.metrics.PlayList.INITIAL_PLAY_START_REASON);\n            }\n\n            if (isBufferingCompleted) {\n                if (data.mimeType === \"application/ttml+xml\") {\n                    return;\n                }\n                isBufferingCompleted = false;\n            }\n\n            started = true;\n\n            this.debug.info(\"[BufferController][\" + type + \"] START\");\n\n            waitingForBuffer = true;\n\n            // Reset htmlVideoState in order to update it after a pause or seek command in UpdateBufferState function\n            if (htmlVideoState === INIT) {\n                // At first playback start, set state to BUFFERING\n                this.metricsModel.addState(type, \"buffering\", this.videoModel.getCurrentTime());\n            }\n            htmlVideoState = BUFFERING;\n            htmlVideoTime = -1;\n            segmentRequestOnError = null;\n\n            // Clear executed requests from fragment controller. In case the browser has cleared the buffer itslef silently,\n            // then FragmentController will not state that the cleared segments have been already loaded.\n            this.fragmentController.clearExecutedRequests(fragmentModel);\n\n            startPlayback.call(this);\n        },\n\n        doSeek = function(time) {\n            var self = this;\n\n            // Avoid identical successive seeks\n            if ((seeking === true) && (seekTarget === time)) {\n                // We are already seeking at the given time\n                return;\n            }\n\n            this.debug.info(\"[BufferController][\" + type + \"] SEEK: \" + time);\n\n            // Do stop since <video>'s stop command may not be called before seek one\n            if (started === true) {\n                doStop.call(this);\n            }\n\n            seeking = true;\n            seekTarget = time;\n\n            // Wait for current buffering process to be completed before restarting\n            Q.when(deferredFragmentBuffered ? deferredFragmentBuffered.promise : true).then(\n                function() {\n                    // self.debug.log(\"[BufferController][\"+type+\"] SEEK: do start\");\n                    doStart.call(self);\n                }\n            );\n        },\n\n        doSeeked = function() {\n            this.debug.info(\"[BufferController][\" + type + \"] SEEKED\");\n            seeking = false;\n            seekTarget = -1;\n        },\n\n        doStop = function() {\n            if (!started) {\n                return;\n            }\n            this.debug.info(\"[BufferController][\" + type + \"] STOP\");\n\n            // Stop buffering process\n            clearTimeout(bufferTimeout);\n            clearTimeout(bufferStateTimeout);\n            started = false;\n            waitingForBuffer = false;\n\n            seeking = false;\n            seekTarget = -1;\n\n            // Stop buffering process and cancel loaded request\n            clearPlayListTraceMetrics(new Date(), MediaPlayer.vo.metrics.PlayList.Trace.USER_REQUEST_STOP_REASON);\n\n            this.fragmentController.abortRequestsForModel(fragmentModel);\n        },\n\n\n        getRepresentationForQuality = function(quality) {\n            return availableRepresentations[quality];\n        },\n\n        onBytesLoadingStart = function(request) {\n            this.debug.info(\"[BufferController][\" + type + \"] Load request \", (request.url !== null) ? request.url : request.quality);\n        },\n\n        onBytesLoaded = function(request, response) {\n            // Store current segment sequence number for next segment request (HLS use case)\n            if (request.sequenceNumber !== undefined) {\n                currentSequenceNumber = request.sequenceNumber;\n            }\n\n            if (this.fragmentController.isInitializationRequest(request)) {\n                onInitializationLoaded.call(this, request, response);\n            } else {\n                onMediaLoaded.call(this, request, response);\n            }\n        },\n\n        onInitializationLoaded = function(request, response) {\n\n            if (!isRunning.call(this)) {\n                return;\n            }\n\n            var initData = response.data,\n                quality = request.quality,\n                self = this;\n\n            this.debug.log(\"[BufferController][\" + type + \"] Initialization loaded \", quality);\n\n            try {\n                this.fragmentController.process(initData).then(function(data) {\n                    if (data) {\n                        // Cache the initialization data to use it next time the quality has changed\n                        initializationData[quality] = data;\n\n                        self.debug.info(\"[BufferController][\" + type + \"] Buffer initialization segment \", (request.url !== null) ? request.url : request.quality);\n                        //console.saveBinArray(data, type + \"_init_\" + request.quality + \".mp4\");\n                        appendToBuffer.call(self, data, request.quality).then(\n                            function() {\n                                // Load next media segment\n                                if (isRunning.call(self)) {\n                                    loadNextFragment.call(self);\n                                }\n                            }\n                        );\n                    } else {\n                        // ORANGE : For HLS Stream, init segment are pushed with media (@see HlsFragmentController)\n                        loadNextFragment.call(self);\n                    }\n                },\n                function (e) {\n                    signalSegmentBuffered.call(self);\n                    if (e.name) {\n                        self.errHandler.sendError(e.name, e.message, e.data);\n                    } else {\n                        self.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.INTERNAL_ERROR, \"Internal error while processing media segment\", e.message);\n                    }\n                });\n            } catch (e) {\n                signalSegmentBuffered.call(self);\n                if (e.name) {\n                    self.errHandler.sendError(e.name, e.message, e.data);\n                } else {\n                    self.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.INTERNAL_ERROR, \"Internal error while processing media segment\", e.message);\n                }\n            }\n        },\n\n        onMediaLoaded = function(request, response) {\n\n            if (!isRunning.call(this)) {\n                return;\n            }\n\n            var eventStreamAdaption = this.manifestExt.getEventStreamForAdaptationSet(this.getData()),\n                eventStreamRepresentation = this.manifestExt.getEventStreamForRepresentation(this.getData(), _currentRepresentation),\n                events,\n                self = this;\n\n            segmentDuration = request.duration;\n\n            // Reset segment download error status\n            segmentDownloadErrorCount = 0;\n\n            this.debug.log(\"[BufferController][\" + type + \"] Media loaded \", request.url);\n\n            if (this.chunkAborted === true) {\n                this.chunkAborted = false;\n            }\n\n            if (this.chunkMissingCount === 1) {\n                this.chunkMissingCount = 0;\n            }\n\n            try {\n                this.fragmentController.process(response.data, request, _currentRepresentation).then(function(data) {\n                    if (data) {\n                        if (eventStreamAdaption.length > 0 || eventStreamRepresentation.length > 0) {\n                            events = handleInbandEvents.call(self, data, request, eventStreamAdaption, eventStreamRepresentation);\n                            self.eventController.addInbandEvents(events);\n                        }\n\n                        self.debug.info(\"[BufferController][\" + type + \"] Buffer segment from url \", request.url);\n\n                        /*if (trickModeEnabled) {\n                                var filename = type + \"_\" + request.index + \"_\" + request.quality + \".mp4\",\n                                    blob = new Blob([data], {\n                                        type: 'data/mp4'\n                                    });\n\n                                if (navigator.msSaveBlob) { // For IE10+ and edge\n                                    navigator.msSaveBlob(blob, filename);\n                                }\n                            }*/\n\n                        //console.saveBinArray(data, request.url.substring(request.url.lastIndexOf('/') + 1));\n                        data = deleteInbandEvents.call(self, data);\n\n                        // Check if we need to override the current buffered segments (in case of language switch for example)\n                        Q.when(overrideBuffer ? removeBuffer.call(self) : true).then(\n                            function() {\n                                /*if (overrideBuffer) {\n                                    debugBufferRange.call(self);\n                                }*/\n                                overrideBuffer = false;\n\n                                // If firefox, set buffer timestampOffset since timestamping (MSE buffer range and <video> currentTime) is based on CTS (and not DTS like in other browsers)\n                                if (isFirefox) {\n                                    buffer.timestampOffset = -getSegmentTimestampOffset(data, request);\n                                }\n\n                                appendToBuffer.call(self, data, request.quality, request).then(\n                                    function() {\n                                        // Check if a new quality is being appended,\n                                        // then add a metric to enable MediaPlayer to detect playback quality changes\n                                        if (currentBufferedQuality !== request.quality) {\n                                            self.debug.log(\"[BufferController][\" + type + \"] Buffered quality changed: \" + request.quality);\n                                            self.metricsModel.addBufferedSwitch(type, request.startTime, _currentRepresentation.id, request.quality);\n                                            currentBufferedQuality = request.quality;\n                                        }\n\n                                        // Signal end of buffering process\n                                        signalSegmentBuffered.call(self);\n                                        // Check buffer level\n                                        checkIfSufficientBuffer.call(self);\n                                    }\n                                );\n                            }\n                        );\n                    } else {\n                        self.debug.error(\"[BufferController][\" + type + \"] Error with segment data, no bytes to push\");\n                        // Signal end of buffering process\n                        signalSegmentBuffered.call(self);\n                        // Check buffer level\n                        checkIfSufficientBuffer.call(self);\n                    }\n                },\n                function (e) {\n                    signalSegmentBuffered.call(self);\n                    if (e.name) {\n                        self.errHandler.sendError(e.name, e.message, e.data);\n                    } else {\n                        self.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.INTERNAL_ERROR, \"Internal error while processing media segment\", e.message);\n                    }\n                });\n            } catch (e) {\n                signalSegmentBuffered.call(self);\n                if (e.name) {\n                    self.errHandler.sendError(e.name, e.message, e.data);\n                } else {\n                    self.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.INTERNAL_ERROR, \"Internal error while processing media segment\", e.message);\n                }\n            }\n        },\n\n        appendToBuffer = function(data, quality, request) {\n            var deferred = Q.defer(),\n                currentVideoTime = this.videoModel.getCurrentTime(),\n                currentTime = new Date(),\n                self = this;\n\n            // this.debug.log(\"Push (\" + type + \") bytes: \" + data.byteLength);\n\n            if (playListTraceMetricsClosed === true) {\n                playListTraceMetricsClosed = false;\n                playListTraceMetrics = this.metricsModel.appendPlayListTrace(playListMetrics, _currentRepresentation.id, null, currentTime, currentVideoTime, null, 1.0, null);\n            }\n\n            if (!hasData()) {\n                return;\n            }\n\n            hasEnoughSpaceToAppend.call(this).then(\n                function() {\n                    if (!hasData()) {\n                        return;\n                    }\n                    self.debug.log(\"[BufferController][\" + type + \"] Buffering segment\");\n                    self.sourceBufferExt.append(buffer, data, request).then(\n                        function( /*appended*/ ) {\n                            self.debug.log(\"[BufferController][\" + type + \"] Segment buffered\");\n\n                            isQuotaExceeded = false;\n\n                            // Patch for Safari: do not remove past buffer since it generates MEDIA_ERROR_DECODE while appending new segment\n                            if (bufferLevel > 1 && !isSafari) {\n                                // Remove outdated buffer parts and requests\n                                // (checking bufferLevel ensure buffer is not empty or back to current time)\n                                removeBuffer.call(self, -1, getWorkingTime.call(self) - bufferToKeep).then(\n                                    function() {\n                                        debugBufferRange.call(self);\n                                        deferred.resolve();\n                                    }\n                                );\n                            } else if (trickModeEnabled) {\n                                // In case of trick play, remove outdated buffer parts according to trick play direction\n                                var start = trickModeForward ? -1 : (getWorkingTime.call(self) + segmentDuration);\n                                var end = trickModeForward ? (getWorkingTime.call(self) - segmentDuration) : -1;\n                                removeBuffer.call(self, start, end).then(\n                                    function() {\n                                        debugBufferRange.call(self);\n                                        deferred.resolve();\n                                    }\n                                );\n                            } else {\n                                debugBufferRange.call(self);\n                                deferred.resolve();\n                            }\n\n                            self.system.notify(\"bufferUpdated\");\n                        },\n                        function(result) {\n                            if (type === 'text') {\n                                // if text, do nt raise an error (the stream would stop)\n                                // just log th error\n                                self.debug.error(\"[BufferController][\" + type + \"] Failed to append data in source buffer : \" + result.err.message);\n                                deferred.resolve();\n                            } else {\n                                self.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_APPEND_SOURCEBUFFER, \"Failed to append data into \" + type + \" source buffer\",\n                                                          new MediaPlayer.vo.Error(result.err.code, result.err.name, result.err.message));\n                                // if the append has failed because the buffer is full we should store the data\n                                // that has not been appended and stop request scheduling. We also need to store\n                                // the promise for this append because the next data can be appended only after\n                                // this promise is resolved.\n                                if (result.err.code === MediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_QUOTA_EXCEEDED) {\n                                    rejectedBytes = {\n                                        data: data,\n                                        quality: quality/*,\n                                    index: index*/\n                                    };\n                                    deferredRejectedDataAppend = deferred;\n                                    isQuotaExceeded = true;\n                                    fragmentsToLoad = 0;\n                                    // stop scheduling new requests\n                                    doStop.call(self);\n                                } else {\n                                    // promise has to be resolved\n                                    deferred.resolve();\n                                }\n                            }\n                        }\n                    );\n                }\n            );\n\n            return deferred.promise;\n        },\n\n        debugBufferRange = function() {\n            var ranges = null,\n                i,\n                len;\n\n            if (this.debug.getLevel() >= this.debug.INFO) {\n                if (buffer) {\n                    ranges = this.sourceBufferExt.getAllRanges(buffer);\n                    if ((ranges === null) || (ranges.length === 0)) {\n                        return;\n                    }\n                    for (i = 0, len = ranges.length; i < len; i += 1) {\n                        this.debug.info(\"[BufferController][\" + type + \"] Buffered range [\" + i + \"]: \" + ranges.start(i) + \" - \" + ranges.end(i) + \" (\" + this.getVideoModel().getCurrentTime() + \")\");\n                    }\n                }\n            }\n        },\n\n        getSegmentTimestampOffset = function (data, request) {\n            var fragment = mp4lib.deserialize(data),\n                moov = fragment.getBoxByType(\"moov\"),\n                moof = fragment.getBoxByType(\"moof\"),\n                traf = moof === null ? null : moof.getBoxByType(\"traf\"),\n                trun = traf === null ? null : traf.getBoxByType(\"trun\"),\n                ctsOffset,\n                timescale;\n\n            if (trun === null || trun.samples_table.length === 0) {\n                return 0;\n            }\n\n            ctsOffset = trun.samples_table[0].sample_composition_time_offset;\n            if (ctsOffset ===  undefined) {\n                return 0;\n            }\n\n            // Try to get timescale from moov\n            if (moov) {\n                var mvhd = moov.getBoxByType(\"mvhd\");\n                timescale = mvhd.timescale;\n            } else {\n                timescale = request.timescale;\n            }\n\n            return (ctsOffset / timescale);\n        },\n\n        handleInbandEvents = function(data, request, adaptionSetInbandEvents, representationInbandEvents) {\n            var events = [],\n                i = 0,\n                identifier,\n                size,\n                expTwo = Math.pow(256, 2),\n                expThree = Math.pow(256, 3),\n                segmentStarttime = Math.max(isNaN(request.startTime) ? 0 : request.startTime, 0),\n                eventStreams = [],\n                inbandEvents;\n\n            inbandEventFound = false;\n            /* Extract the possible schemeIdUri : If a DASH client detects an event message box with a scheme that is not defined in MPD, the client is expected to ignore it */\n            inbandEvents = adaptionSetInbandEvents.concat(representationInbandEvents);\n            for (var loop = 0; loop < inbandEvents.length; loop++) {\n                eventStreams[inbandEvents[loop].schemeIdUri] = inbandEvents[loop];\n            }\n            while (i < data.length) {\n                identifier = String.fromCharCode(data[i + 4], data[i + 5], data[i + 6], data[i + 7]); // box identifier\n                size = data[i] * expThree + data[i + 1] * expTwo + data[i + 2] * 256 + data[i + 3] * 1; // size of the box\n                if (identifier === \"moov\" || identifier === \"moof\") {\n                    break;\n                } else if (identifier === \"emsg\") {\n                    inbandEventFound = true;\n                    var eventBox = [\"\", \"\", 0, 0, 0, 0, \"\"],\n                        arrIndex = 0,\n                        j = i + 12; //fullbox header is 12 bytes, thats why we start at 12\n\n                    while (j < size + i) {\n                        /* == string terminates with 0, this indicates end of attribute == */\n                        if (arrIndex === 0 || arrIndex === 1 || arrIndex === 6) {\n                            if (data[j] !== 0) {\n                                eventBox[arrIndex] += String.fromCharCode(data[j]);\n                            } else {\n                                arrIndex += 1;\n                            }\n                            j += 1;\n                        } else {\n                            eventBox[arrIndex] = data[j] * expThree + data[j + 1] * expTwo + data[j + 2] * 256 + data[j + 3] * 1;\n                            j += 4;\n                            arrIndex += 1;\n                        }\n                    }\n                    var schemeIdUri = eventBox[0],\n                        value = eventBox[1],\n                        timescale = eventBox[2],\n                        presentationTimeDelta = eventBox[3],\n                        duration = eventBox[4],\n                        id = eventBox[5],\n                        messageData = eventBox[6],\n                        presentationTime = segmentStarttime * timescale + presentationTimeDelta;\n\n                    if (eventStreams[schemeIdUri]) {\n                        var event = new Dash.vo.Event();\n                        event.eventStream = eventStreams[schemeIdUri];\n                        event.eventStream.value = value;\n                        event.eventStream.timescale = timescale;\n                        event.duration = duration;\n                        event.id = id;\n                        event.presentationTime = presentationTime;\n                        event.messageData = messageData;\n                        event.presentationTimeDelta = presentationTimeDelta;\n                        events.push(event);\n                    }\n                }\n                i += size;\n            }\n            return events;\n        },\n\n        deleteInbandEvents = function(data) {\n            if (!inbandEventFound) {\n                return data;\n            }\n\n            var length = data.length,\n                i = 0,\n                j = 0,\n                l = 0,\n                identifier,\n                size,\n                expTwo = Math.pow(256, 2),\n                expThree = Math.pow(256, 3),\n                modData = new Uint8Array(data.length);\n\n            while (i < length) {\n\n                identifier = String.fromCharCode(data[i + 4], data[i + 5], data[i + 6], data[i + 7]);\n                size = data[i] * expThree + data[i + 1] * expTwo + data[i + 2] * 256 + data[i + 3] * 1;\n\n\n                if (identifier !== \"emsg\") {\n                    for (l = i; l < i + size; l++) {\n                        modData[j] = data[l];\n                        j += 1;\n                    }\n                }\n                i += size;\n\n            }\n\n            return modData.subarray(0, j);\n        },\n\n        isRunning = function() {\n            if (started) {\n                return true;\n            }\n\n            // If buffering process is running, then we interrupt it\n            signalSegmentBuffered.call(this);\n\n            return false;\n        },\n\n        signalSegmentBuffered = function() {\n            if (deferredFragmentBuffered) {\n                //self.debug.log(\"[BufferController][\"+type+\"] End of buffering process\");\n                deferredFragmentBuffered.resolve();\n                deferredFragmentBuffered = null;\n            }\n        },\n\n        hasEnoughSpaceToAppend = function() {\n            var deferred = Q.defer(),\n                removedTime = 0,\n                fragmentDuration,\n                startClearing;\n\n            // do not remove any data until the quota is exceeded\n            if (!isQuotaExceeded) {\n                return Q.when(true);\n            }\n\n            startClearing = function() {\n                var currentTime = this.videoModel.getCurrentTime(),\n                    removeStart = 0,\n                    removeEnd,\n                    req;\n\n                // we need to remove data that is more than one segment before the video currentTime\n                req = this.fragmentController.getExecutedRequestForTime(fragmentModel, currentTime);\n                removeEnd = (req && !isNaN(req.startTime)) ? req.startTime : Math.floor(currentTime);\n                fragmentDuration = (req && !isNaN(req.duration)) ? req.duration : 1;\n\n                removeBuffer.call(this, removeStart, removeEnd).then(\n                    function(removedTimeValue) {\n                        removedTime += removedTimeValue;\n                        if (removedTime >= fragmentDuration) {\n                            deferred.resolve();\n                        } else {\n                            setTimeout(startClearing, fragmentDuration * 1000);\n                        }\n                    }\n                );\n            };\n\n            startClearing.call(this);\n\n            return deferred.promise;\n        },\n\n        removeBuffer = function(start, end) {\n            var deferred = Q.defer(),\n                removeStart,\n                removeEnd,\n                self = this;\n\n            if (buffer.buffered.length === 0) {\n                deferred.resolve(0);\n                return deferred.promise;\n            }\n\n            removeStart = ((start !== undefined) && (start !== -1)) ? start : buffer.buffered.start(0);\n            removeEnd = ((end !== undefined) && (end !== -1)) ? end : buffer.buffered.end(buffer.buffered.length - 1);\n\n            if (removeEnd <= removeStart) {\n                deferred.resolve(0);\n                return deferred.promise;\n            }\n\n            this.debug.info(\"[BufferController][\" + type + \"] Remove from \" + removeStart + \" to \" + removeEnd + \" (\" + this.getVideoModel().getCurrentTime() + \")\");\n\n            // Abort on buffer\n            if (type !== \"text\") {\n                // no need to abort for text buffer. remove call do the same thing\n                this.sourceBufferExt.abort(mediaSource, buffer);\n            }\n\n            // Wait for buffer update completed\n            this.sourceBufferExt.remove(buffer, removeStart, removeEnd, periodInfo.duration, mediaSource).then(\n                function() {\n                    // Remove all requests from the list of the executed requests\n                    self.fragmentController.removeExecutedRequestsBeforeTime(fragmentModel, removeEnd + 1); // +1 for rounding issues\n                    self.fragmentController.cancelPendingRequestsForModel(fragmentModel);\n                    deferred.resolve(removeEnd - removeStart);\n                }, function(ex) {\n                    self.errHandler.sendWarning(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_REMOVE_SOURCEBUFFER, \"Failed to remove data from \" + type + \" source buffer\",\n                        new MediaPlayer.vo.Error(ex.code, ex.name, ex.message));\n                    deferred.resolve(0);\n                }\n            );\n\n            return deferred.promise;\n        },\n\n        onBytesError = function(e) {\n\n            if (!isRunning.call(this)) {\n                return;\n            }\n\n            signalSegmentBuffered.call(this);\n\n            // Abandonned request => load segment at lowest quality\n            if (e.aborted) {\n                // if (e.quality !== 0) {\n                // this.debug.info(\"[BufferController][\" + type + \"] Segment download abandonned => Retry segment download at lowest quality\");\n                // this.abrController.setAutoSwitchFor(type, false);\n                // this.abrController.setQualityFor(type, 0);\n                bufferFragment.call(this);\n                // }\n                return;\n            }\n\n            // Ignore in case of text track, this will not stop playing\n            if (type === \"text\") {\n\n                this.errHandler.sendWarning(MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_CONTENT,\n                    \"Failed to download media segment\", {\n                        url: e.url,\n                        status: e.status\n                    });\n\n                return;\n            }\n\n            // Segment download failed\n            segmentDownloadErrorCount += 1;\n\n            if (segmentDownloadErrorCount === SEGMENT_DOWNLOAD_ERROR_MAX) {\n                // If failed consecutively SEGMENT_DOWNLOAD_ERROR_MAX times, then raise an error\n                this.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_CONTENT,\n                    \"Failed to download media segment\", {\n                        url: e.url,\n                        status: e.status\n                    });\n            } else {\n                // Raise a warning\n                this.errHandler.sendWarning(MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_CONTENT,\n                    \"Failed to download media segment\", {\n                        url: e.url,\n                        status: e.status\n                    });\n\n                // Store segment request that failed to load\n                segmentRequestOnError = e;\n                if (htmlVideoState === BUFFERING) {\n                    // If already in buffering state (i.e. empty buffer) then signal to stream that segment loading failed\n                    // Else signal it when entering in buffering state (see updateBufferState())\n                    signalSegmentLoadingFailed.call(this);\n                }\n            }\n        },\n\n        signalStreamComplete = function( /*request*/ ) {\n            this.debug.log(\"[BufferController][\" + type + \"] Stream is complete.\");\n\n            isBufferingCompleted = true;\n            clearPlayListTraceMetrics(new Date(), MediaPlayer.vo.metrics.PlayList.Trace.END_OF_CONTENT_STOP_REASON);\n\n            signalSegmentBuffered.call(this);\n\n            doStop.call(this);\n\n            this.system.notify(\"bufferingCompleted\");\n        },\n\n        loadInitialization = function(quality) {\n\n            if (!isRunning.call(this)) {\n                return Q.when(null);\n            }\n\n            var self = this;\n\n            // Check if initialization segment for current quality has already been loaded and stored\n            if (initializationData[quality]) {\n                this.debug.info(\"[BufferController][\" + type + \"] Buffer initialization segment, quality = \", quality);\n                appendToBuffer.call(this, initializationData[quality], quality).then(\n                    function() {\n                        self.debug.log(\"[BufferController][\" + type + \"] Initialization segment buffered\");\n                        // Load next media segment\n                        if (isRunning.call(self)) {\n                            loadNextFragment.call(self);\n                        }\n                    }\n                );\n                return Q.when(null);\n            } else {\n                // Get init segment request for the current\n                return this.indexHandler.getInitRequest(availableRepresentations[quality]);\n            }\n        },\n\n        loadNextFragment = function() {\n\n            if (!isRunning.call(this)) {\n                return;\n            }\n\n            var time = getWorkingTime.call(this),\n                range,\n                segmentTime,\n                self = this;\n\n\n            // If we override buffer (in case of language for example), then consider current video time for the next segment time\n            if (overrideBuffer) {\n                segmentTime = time;\n            } else {\n                // Get buffer range that includes working time\n                range = this.sourceBufferExt.getBufferRange(buffer, time);\n\n                // Get next segment time\n                segmentTime = range ? range.end : time;\n            }\n\n            // currentSequenceNumber used in HLS\n            if ((currentSequenceNumber !== -1) && !seeking && !overrideBuffer) {\n                this.debug.log(\"[BufferController][\" + type + \"] loadNextFragment for sequence number: \" + currentSequenceNumber);\n                this.indexHandler.getNextSegmentRequestFromSN(_currentRepresentation, currentSequenceNumber).then(onFragmentRequest.bind(this));\n            } else {\n                this.debug.log(\"[BufferController][\" + type + \"] loadNextFragment for time: \" + segmentTime);\n                this.indexHandler.getSegmentRequestForTime(_currentRepresentation, segmentTime).then(onFragmentRequest.bind(this), function() {\n                    currentDownloadQuality = -1;\n                    signalStreamComplete.call(self);\n                });\n            }\n        },\n\n        onFragmentRequest = function(request) {\n\n            if (!isRunning.call(this)) {\n                return;\n            }\n\n            var manifest = this.manifestModel.getValue();\n\n            // Check if current request signals end of stream\n            if ((request !== null) && (request.action === request.ACTION_COMPLETE)) {\n                signalStreamComplete.call(this);\n                return;\n            }\n\n            if (request !== null) {\n                //if trick mode enbaled, get the request to get I Frame data.\n                if (trickModeEnabled) {\n                    request = this.indexHandler.getIFrameRequest(request);\n                }\n\n                // If we have already loaded the given fragment ask for the next one. Otherwise prepare it to get loaded\n                if (this.fragmentController.isFragmentLoadedOrPending(this, request)) {\n                    this.debug.log(\"[BufferController][\" + type + \"] new fragment request => already loaded or pending \" + request.url);\n                    this.indexHandler.getNextSegmentRequest(_currentRepresentation).then(onFragmentRequest.bind(this));\n                } else {\n                    // Download the segment\n                    this.fragmentController.prepareFragmentForLoading(this, request, onBytesLoadingStart, onBytesLoaded, onBytesError, null /*signalStreamComplete*/ );\n                    sendRequest.call(this);\n                }\n            } else {\n                // No more fragment in current list\n                this.debug.log(\"[BufferController][\" + type + \"] loadNextFragment failed\");\n                signalSegmentBuffered.call(this);\n\n                if (isDynamic) {\n                    // If live HLS, then check buffer since playlist should be updated\n                    if (manifest.name === \"M3U\") {\n                        updateCheckBufferTimeout.call(this);\n                    }\n                } else {\n                    // For VOD streams, signal end of stream\n                    signalStreamComplete.call(this);\n                }\n            }\n        },\n\n        hasData = function() {\n            return !!data && !!buffer;\n        },\n\n        getTimeToEnd = function() {\n            var currentTime = this.videoModel.getCurrentTime();\n\n            return ((periodInfo.start + periodInfo.duration) - currentTime);\n        },\n\n        getWorkingTime = function() {\n            var time = -1,\n                videoTime = this.videoModel.getCurrentTime();\n\n            if (seeking) {\n                time = seekTarget;\n                //this.debug.log(\"[BufferController][\" + type + \"] Working time = \" + time + \" (seeking = \" + seeking + \", video time = \" + videoTime + \")\");\n            } else {\n                time = videoTime;\n                //this.debug.log(\"[BufferController][\" + type + \"] Working time = \" + time);\n            }\n\n            return time;\n        },\n\n        getLiveEdgeTime = function() {\n            var deferred = Q.defer(),\n                startTime,\n                // Get live edge time from manifest as the last segment time\n                liveEdgeTime = _currentRepresentation.segmentAvailabilityRange.end,\n                self = this;\n\n            this.debug.log(\"[BufferController][\" + type + \"] Manifest live edge = \" + liveEdgeTime);\n\n            // Step back from a found live edge time to be able to buffer some data\n            startTime = Math.max((liveEdgeTime - liveDelay), _currentRepresentation.segmentAvailabilityRange.start);\n\n            // Get the request corresponding to the start time\n            this.indexHandler.getSegmentRequestForTime(_currentRepresentation, startTime).then(\n                function(request) {\n                    // Set live edge to be the start time of the founded segment\n                    periodInfo.liveEdge = request.startTime;\n                    self.debug.log(\"[BufferController][\" + type + \"] Live edge = \" + periodInfo.liveEdge);\n\n                    deferred.resolve(periodInfo.liveEdge);\n                }\n            );\n\n            return deferred.promise;\n        },\n\n        updateBufferLevel = function(sendMetric) {\n            if (!hasData()) {\n                return;\n            }\n\n            var workingTime = getWorkingTime.call(this);\n\n            bufferLevel = this.sourceBufferExt.getBufferLength(buffer, workingTime);\n            this.debug.log(\"[BufferController][\" + type + \"] Working time = \" + workingTime + \", Buffer level = \" + bufferLevel.toFixed(3));\n            if (sendMetric) {\n                this.metricsModel.addBufferLevel(type, new Date(), bufferLevel);\n            }\n            this.updateBufferState();\n        },\n\n        checkIfSufficientBuffer = function() {\n\n            if (!isRunning.call(this)) {\n                return;\n            }\n\n            var timeToEnd,\n                delay;\n\n            this.debug.log(\"[BufferController][\" + type + \"] Check buffer...\");\n\n            updateBufferLevel.call(this, true);\n\n            // Check stalled mode of video model\n            if (stalled) {\n                if (bufferLevel > minBufferTimeAtStartup) {\n                    setStalled.call(this, false);\n                }\n            }\n\n            timeToEnd = getTimeToEnd.call(this);\n            this.debug.log(\"[BufferController][\" + type + \"] time to end = \" + timeToEnd);\n\n            // In trick mode state, always fills buffer\n            if (trickModeEnabled) {\n                if (bufferLevel < 1) {\n                    bufferFragment.call(this);\n                }\n            } else {\n                if (trackChanged || overrideBuffer ||\n                    ((bufferLevel < minBufferTime) &&\n                        ((minBufferTime < timeToEnd) || (minBufferTime >= timeToEnd && !isBufferingCompleted)))) {\n                    // Buffer needs to be filled\n                    bufferFragment.call(this);\n                } else {\n                    // Determine the timeout delay before checking again the buffer\n                    delay = bufferLevel - minBufferTime + 0.5; // + 0.5 to ensure buffer level will be inferior to minBufferTime\n                    updateCheckBufferTimeout.call(this, delay);\n                }\n            }\n        },\n\n        updateCheckBufferTimeout = function(delay) {\n            var self = this;\n\n            delay = delay ? delay : 1;\n\n            this.debug.log(\"[BufferController][\" + type + \"] Check buffer in = \" + delay.toFixed(3) + \" ms (bufferLevel = \" + bufferLevel + \")\");\n\n            clearTimeout(bufferTimeout);\n            bufferTimeout = setTimeout(function() {\n                bufferTimeout = null;\n                checkIfSufficientBuffer.call(self);\n            }, (delay * 1000));\n        },\n\n        bufferFragment = function() {\n            var now = new Date(),\n                currentVideoTime = this.videoModel.getCurrentTime(),\n                manifest = this.manifestModel.getValue(),\n                loadInit = false,\n                quality,\n                playlistUpdated = null,\n                self = this;\n\n            if (deferredFragmentBuffered !== null) {\n                this.debug.error(\"[BufferController][\" + type + \"] deferredFragmentBuffered has not been resolved, create a new one is not correct.\");\n            }\n\n            deferredFragmentBuffered = Q.defer();\n\n            this.debug.log(\"[BufferController][\" + type + \"] Start buffering process...\");\n\n            // Check if data has changed\n            doUpdateData.call(this);\n\n            // If initialization data has been changed (track changed), then load initialization segment\n            loadInit = (initializationData.length === 0) && (manifest.name !== \"M3U\");\n\n            // Get current quality\n            quality = this.abrController.getPlaybackQuality(type, data).quality;\n\n            // Get corresponding representation\n            _currentRepresentation = getRepresentationForQuality.call(this, quality);\n\n            // Quality changed?\n            if (quality !== currentDownloadQuality) {\n                this.debug.log(\"[BufferController][\" + type + \"] currentDownloadQuality changed : \" + quality);\n                currentDownloadQuality = quality;\n                // Load initialization segment\n                loadInit = true;\n\n                clearPlayListTraceMetrics(new Date(), MediaPlayer.vo.metrics.PlayList.Trace.REPRESENTATION_SWITCH_STOP_REASON);\n                this.debug.log(\"[BufferController][\" + type + \"] Send RepresentationSwitch with quality = \" + quality);\n                this.metricsModel.addRepresentationSwitch(type, now, currentVideoTime, _currentRepresentation.id, quality);\n\n                // HLS use case => download playlist for new representation\n                playlistUpdated = updatePlayListForRepresentation.call(this);\n            }\n\n            Q.when(playlistUpdated ? playlistUpdated : true).then(\n                function() {\n                    if (loadInit === true) {\n                        // Load initialization segment request\n                        loadInitialization.call(self, quality).then(\n                            function(request) {\n                                if (request !== null) {\n                                    self.fragmentController.prepareFragmentForLoading(self, request, onBytesLoadingStart, onBytesLoaded, onBytesError, null /*signalStreamComplete*/ );\n                                    sendRequest.call(self);\n                                }\n                            }, function(e) {\n                                signalSegmentBuffered.call(self);\n                                if (e.name === MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CODEC_UNSUPPORTED) {\n                                    self.errHandler.sendError(e.name, e.message, e.data);\n                                } else {\n                                    self.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.INTERNAL_ERROR, \"Internal error while processing initialization segment\", e.message);\n                                }\n                            }\n                        );\n                    } else {\n                        // Load next fragment\n                        // Notes: 1 - Next fragment is download in // with initialization segment\n                        //        2 - Buffer level is checked once next fragment data has been pushed into buffer (@see checkIfSufficientBuffer())\n                        loadNextFragment.call(self);\n                    }\n                },\n                function(err) {\n                    signalSegmentBuffered.call(self);\n                    if (err) {\n                        self.errHandler.sendError(err.name, err.message, err.data);\n                    }\n                }\n            );\n\n        },\n\n        updatePlayListForRepresentation = function() {\n            var manifest = this.manifestModel.getValue(),\n                deferred,\n                representation,\n                idx,\n                self = this;\n\n            if (manifest.name !== \"M3U\") {\n                return Q.when(true);\n            }\n\n            // In static use case, do not update playlist if already downloaded\n            if (!isDynamic) {\n                if (_currentRepresentation.segmentInfoType === \"SegmentList\") {\n                    return Q.when(true);\n                }\n            }\n\n            if (playlistRefreshTimeout) {\n                clearTimeout(playlistRefreshTimeout);\n                playlistRefreshTimeout = null;\n            }\n\n            deferred = Q.defer();\n\n            idx = this.manifestExt.getDataIndex(data, manifest, periodInfo.index);\n            representation = manifest.Period_asArray[periodInfo.index].AdaptationSet_asArray[idx].Representation_asArray[currentDownloadQuality];\n\n            this.debug.log(\"[BufferController][\" + type + \"] Update playlist for representation \" + representation.id);\n\n            this.parser.hlsParser.updatePlaylist(representation, data).then(\n                function() {\n                    availableRepresentations = updateRepresentations.call(self, data, periodInfo);\n                    _currentRepresentation = getRepresentationForQuality.call(self, currentDownloadQuality);\n                    representation = manifest.Period_asArray[periodInfo.index].AdaptationSet_asArray[idx].Representation_asArray[currentDownloadQuality];\n\n                    // Refresh playlist according to last segment duration\n                    var segments = representation.SegmentList.SegmentURL_asArray;\n                    var segment = segments[segments.length-1];\n                    playlistRefreshTimeout = setTimeout(function() {\n                        updatePlayListForRepresentation.call(self);\n                    }, ((segment.duration - 1) * 1000));\n\n                    deferred.resolve();\n                },\n                function(err) {\n                    if (err) {\n                        self.errHandler.sendWarning(err.name, err.message, err.data);\n                    }\n                    deferred.reject(err);\n                }\n            );\n\n            return deferred.promise;\n        },\n\n        updateRepresentations = function(data, periodInfo) {\n            var manifest = this.manifestModel.getValue(),\n                idx,\n                adaptations;\n\n            idx = this.manifestExt.getDataIndex(data, manifest, periodInfo.index);\n            adaptations = this.manifestExt.getAdaptationsForPeriod(manifest, periodInfo);\n\n            return this.manifestExt.getRepresentationsForAdaptation(manifest, adaptations[idx]);\n        },\n\n        doUpdateData = function() {\n            if (dataChanged === false) {\n                return false;\n            }\n\n            this.debug.log(\"[BufferController][\" + type + \"] Data changed\");\n\n            // Update representations\n            availableRepresentations = updateRepresentations.call(this, data, periodInfo);\n            _currentRepresentation = getRepresentationForQuality.call(this, this.abrController.getPlaybackQuality(type, data).quality);\n\n            this.bufferExt.updateData(data, type);\n\n            if (trackChanged) {\n                // Reset stored initialization segments\n                initializationData = [];\n\n                // Clear the executed requests\n                this.fragmentController.clearExecutedRequests(fragmentModel);\n\n                // Signal to override current buffering segments to switch as soon as possible to new track\n                overrideBuffer = true;\n\n                // For xml subtitles file, reset cues since there is no media segment\n                if (type === 'text') {\n                    buffer.UpdateLang(data.id, data.lang);\n                    if (data.mimeType === 'application/ttml+xml') {\n                        removeBuffer.call(this);\n                    }\n                }\n            }\n\n            dataChanged = false;\n            trackChanged = false;\n        },\n\n        onFragmentLoadProgress = function(evt) {\n            var currentQuality = this.abrController.getQualityFor(type),\n                i,\n                rules;\n\n            // Check only if not at lowest quality\n            if (this.abrController.isMinQuality(type, data, currentQuality)) {\n                return;\n            }\n\n            rules = this.abrRulesCollection.getRules(MediaPlayer.rules.BaseRulesCollection.prototype.ABANDON_FRAGMENT_RULES);\n            var callback = function(switchRequest) {\n                if (switchRequest.quality < currentQuality) {\n                    this.fragmentController.abortRequestsForModel(fragmentModel);\n                    this.debug.info(\"[BufferController][\" + type + \"] Abandon current segment download\");\n                }\n            };\n\n            for (i = 0; i < rules.length; i++) {\n                rules[i].execute(evt.data.request, callback.bind(this));\n            }\n        },\n\n        signalSegmentLoadingFailed = function() {\n            if (segmentRequestOnError === null) {\n                return;\n            }\n            this.debug.log(\"[BufferController][\" + type + \"] Signal segment loading failed\");\n            this.system.notify(\"segmentLoadingFailed\", segmentRequestOnError);\n            segmentRequestOnError = null;\n        };\n\n    return {\n        videoModel: undefined,\n        metricsModel: undefined,\n        manifestExt: undefined,\n        manifestModel: undefined,\n        bufferExt: undefined,\n        sourceBufferExt: undefined,\n        abrController: undefined,\n        parser: undefined,\n        fragmentExt: undefined,\n        indexHandler: undefined,\n        debug: undefined,\n        system: undefined,\n        errHandler: undefined,\n        config: undefined,\n        abrRulesCollection: undefined,\n\n        initialize: function(type, newPeriodInfo, newData, buffer, fragmentController, source, eventController) {\n            var manifest = this.manifestModel.getValue();\n\n            this.debug.log(\"[BufferController][\" + type + \"] Initialize\");\n\n            this[MediaPlayer.dependencies.FragmentLoader.eventList.ENAME_LOADING_PROGRESS] = onFragmentLoadProgress;\n\n            isDynamic = this.manifestExt.getIsDynamic(manifest);\n            this.setMediaSource(source);\n            this.setType(type);\n            this.setBuffer(buffer);\n            this.setFragmentController(fragmentController);\n            this.setEventController(eventController);\n            minBufferTime = this.config.getParamFor(type, \"BufferController.minBufferTime\", \"number\", -1);\n            minBufferTimeAtStartup = this.config.getParamFor(type, \"BufferController.minBufferTimeForPlaying\", \"number\", 0);\n            bufferToKeep = this.config.getParamFor(type, \"BufferController.bufferToKeep\", \"number\", MediaPlayer.dependencies.BufferExtensions.DEFAULT_MIN_BUFFER_TIME);\n            liveDelay = this.config.getParamFor(type, \"BufferController.liveDelay\", \"number\", -1);\n\n            this.updateData(newData, newPeriodInfo);\n\n            this.load();\n\n            ready = true;\n        },\n\n        load: function() {\n            var manifest = this.manifestModel.getValue(),\n                self = this;\n\n            doUpdateData.call(this);\n\n            // Retrieve the representation of initial quality to enable some parameters initialization\n            // (@see getLiveEdgeTime() for example)\n            _currentRepresentation = getRepresentationForQuality.call(this, this.abrController.getPlaybackQuality(type, data).quality);\n\n            currentDownloadQuality = -1;\n\n            // Clear buffer\n            removeBuffer.call(this).then(function () {\n                if (_currentRepresentation) {\n                    self.indexHandler.setIsDynamic(isDynamic);\n                    if (minBufferTime === -1) {\n                        minBufferTime = self.bufferExt.decideBufferLength(manifest.minBufferTime, periodInfo.duration, waitingForBuffer);\n                    }\n\n                    if (liveDelay === -1 || liveDelay < minBufferTime) {\n                        liveDelay = minBufferTime;\n                    }\n\n                    // Update manifest's minBufferTime value\n                    manifest.minBufferTime = minBufferTime;\n                    if (type === \"video\") {\n                        if (isDynamic) {\n                            self.indexHandler.updateSegmentList(_currentRepresentation).then(\n                                function() {\n                                    getLiveEdgeTime.call(self).then(\n                                        function(time) {\n                                            self.system.notify(\"startTimeFound\", time);\n                                        }\n                                    );\n                                }\n                            );\n                        } else {\n                            self.indexHandler.getCurrentTime(_currentRepresentation).then(\n                                function(time) {\n                                    if (time < _currentRepresentation.segmentAvailabilityRange.start) {\n                                        time = _currentRepresentation.segmentAvailabilityRange.start;\n                                    }\n                                    self.system.notify(\"startTimeFound\", time);\n                                }\n                            );\n                        }\n                    }\n                }\n\n            });\n        },\n\n        getIndexHandler: function() {\n            return this.indexHandler;\n        },\n\n        getType: function() {\n            return type;\n        },\n\n        setType: function(value) {\n            type = value;\n\n            if (this.indexHandler !== undefined) {\n                this.indexHandler.setType(value);\n            }\n        },\n\n        getPeriodInfo: function() {\n            return periodInfo;\n        },\n\n        getVideoModel: function() {\n            return this.videoModel;\n        },\n\n        setVideoModel: function(value) {\n            this.videoModel = value;\n        },\n\n        getFragmentController: function() {\n            return this.fragmentController;\n        },\n\n        setFragmentController: function(value) {\n            if (value) {\n                this.fragmentController = value;\n                fragmentModel = this.fragmentController.attachBufferController(this);\n                fragmentModel.fragmentLoader.subscribe(MediaPlayer.dependencies.FragmentLoader.eventList.ENAME_LOADING_PROGRESS, this);\n                fragmentModel.setType(type);\n            }\n        },\n\n        setEventController: function(value) {\n            this.eventController = value;\n        },\n\n        getData: function() {\n            return data;\n        },\n\n        updateData: function(newData, newPeriodInfo) {\n\n            this.debug.log(\"[BufferController][\" + type + \"] Update data\");\n\n            // Check if track has changed (in case of language switch for example)\n            trackChanged = (data === null) ? false : ((data.id !==  newData.id) || (data.lang !==  newData.lang) || (data.subType !==  newData.subType));\n\n            // Set the new data\n            data = newData;\n            periodInfo = newPeriodInfo;\n            dataChanged = true;\n\n            if (trackChanged) {\n                this.debug.log(\"[BufferController][\" + type + \"] Track changed\");\n\n                // Restart buffering process to switch as soon as possible to new track\n\n                // Reset current timeout\n                clearTimeout(bufferTimeout);\n                bufferTimeout = null;\n\n                // Reset buffering completed state\n                isBufferingCompleted = false;\n\n                // Restart controller if stopped (if buffering was already completed)\n                doStart.call(this);\n\n                // Restart buffering process\n                if (deferredFragmentBuffered === null) {\n                    checkIfSufficientBuffer.call(this);\n                }\n            }\n        },\n\n        getHtmlVideoState: function() {\n            return htmlVideoState;\n        },\n\n        getAvailableRepresentations: function() {\n            return availableRepresentations;\n        },\n\n        getCurrentRepresentation: function() {\n            return _currentRepresentation;\n        },\n\n        getBuffer: function() {\n            return buffer;\n        },\n\n        setBuffer: function(value) {\n            buffer = value;\n        },\n\n        getMinBufferTime: function() {\n            return minBufferTime;\n        },\n\n        setMinBufferTime: function(value) {\n            minBufferTime = value;\n        },\n\n        getLiveDelay: function() {\n            return liveDelay;\n        },\n\n        setMediaSource: function(value) {\n            mediaSource = value;\n        },\n\n        isReady: function() {\n            return state === READY;\n        },\n\n        isBufferingCompleted: function() {\n            return isBufferingCompleted;\n        },\n\n        clearMetrics: function() {\n            if (type === null || type === \"\") {\n                return;\n            }\n\n            this.metricsModel.clearCurrentMetricsForType(type);\n        },\n\n        updateManifest: function() {\n            this.system.notify(\"manifestUpdate\");\n        },\n\n        updateBufferState: function() {\n            var currentTime = this.videoModel.getCurrentTime(),\n                previousTime = htmlVideoTime === -1 ? currentTime : htmlVideoTime,\n                progress = (currentTime - previousTime),\n                ranges,\n                self = this;\n\n            clearTimeout(bufferStateTimeout);\n            bufferStateTimeout = null;\n\n            if (started === false) {\n                return;\n            }\n\n            if (type === \"text\") {\n                return;\n            }\n\n            if (trickModeEnabled) {\n                return;\n            }\n\n            //this.debug.log(\"#### [\" + type + \"] level = \" + bufferLevel + \", currentTime = \" + currentTime + \", progress = \" + progress);\n\n            switch (htmlVideoState) {\n                case INIT:\n                    htmlVideoState = BUFFERING;\n                    this.debug.info(\"[BufferController][\" + type + \"] BUFFERING - \" + currentTime + \" - \" + bufferLevel);\n                    this.metricsModel.addState(type, \"buffering\", currentTime);\n                    break;\n\n                case BUFFERING:\n                    if (!this.getVideoModel().isPaused() &&\n                        ((progress > 0) && (bufferLevel >= 1))) {\n                        htmlVideoState = PLAYING;\n                        this.debug.info(\"[BufferController][\" + type + \"] PLAYING - \" + currentTime);\n                        this.metricsModel.addState(type, \"playing\", currentTime);\n                        // Reset seeking state since on some browsers (IE11/Edge) seeked event may not be raised\n                        seeking = false;\n                        seekTarget = -1;\n\n                        // Reset segment download error status\n                        segmentDownloadErrorCount = 0;\n                    } else if (!this.getVideoModel().isStalled()) {\n                        ranges = this.sourceBufferExt.getAllRanges(buffer);\n                    }\n                    break;\n\n                case PLAYING:\n                    if (!this.getVideoModel().isPaused() && !this.getVideoModel().isSeeking() &&\n                        ((progress <= 0 && bufferLevel <= 1) || (bufferLevel === 0))) {\n                        htmlVideoState = BUFFERING;\n                        this.debug.info(\"[BufferController][\" + type + \"] BUFFERING - \" + currentTime + \" - \" + bufferLevel);\n                        this.metricsModel.addState(type, \"buffering\", currentTime);\n\n                        if (segmentRequestOnError) {\n                            // If buffering is due to segment download failure (see onBytesError()), then signal it to Stream (see Stream.onBufferFailed())\n                            signalSegmentLoadingFailed.call(this);\n                        } else {\n                            // Check if there is a hole in the buffer (segment download failed or input stream discontinuity), then skip it\n                            // For live streams we consider discontinuities lower than a segment duration\n                            ranges = this.sourceBufferExt.getAllRanges(buffer);\n                            var i;\n                            for (i = 0; i < ranges.length; i++) {\n                                if (currentTime < ranges.start(i)) {\n                                    if (!isDynamic || ((ranges.start(i) - currentTime) < segmentDuration)) {\n                                        break;\n                                    }\n                                }\n                            }\n                            if (i < ranges.length) {\n                                // Seek to next available range\n                                this.debug.info(\"[BufferController][\" + type + \"] BUFFERING => skip buffer discontinuity, seek to \" + ranges.start(i));\n                                this.videoModel.setCurrentTime(ranges.start(i));\n                            }\n                        }\n                    }\n\n                    bufferStateTimeout = setTimeout(function() {\n                        bufferStateTimeout = null;\n                        updateBufferLevel.call(self, false);\n                    }, 1000);\n\n                    break;\n            }\n\n            if (currentTime > 0) {\n                htmlVideoTime = currentTime;\n            }\n        },\n\n        updateStalledState: function() {\n            stalled = this.videoModel.isStalled();\n        },\n\n        reset: function(errored) {\n            var cancel = function cancelDeferred(d) {\n                    if (d) {\n                        d.reject();\n                        d = null;\n                    }\n                },\n                deferred = Q.defer(),\n                self = this;\n\n            doStop.call(this);\n            // Wait for current buffering process to be completed before restarting\n            this.sourceBufferExt.abort(mediaSource, buffer);\n\n            if (playlistRefreshTimeout) {\n                clearTimeout(playlistRefreshTimeout);\n                playlistRefreshTimeout = null;\n            }\n\n            Q.when(deferredFragmentBuffered ? deferredFragmentBuffered.promise : true).then(\n                function() {\n                    cancel(deferredRejectedDataAppend);\n                    cancel(deferredFragmentBuffered);\n\n                    if (fragmentModel) {\n                        fragmentModel.fragmentLoader.unsubscribe(MediaPlayer.dependencies.FragmentLoader.eventList.ENAME_LOADING_PROGRESS, self.abrController);\n                        self.fragmentController.abortRequestsForModel(fragmentModel);\n                        self.fragmentController.detachBufferController(fragmentModel);\n                        fragmentModel = null;\n                    }\n\n                    self.clearMetrics();\n                    initializationData = [];\n                    initialPlayback = true;\n                    isQuotaExceeded = false;\n                    rejectedBytes = null;\n                    appendingRejectedData = false;\n\n                    if (trickModeEnabled) {\n                        // Restore ABR quality and auto switch state\n                        self.abrController.setAutoSwitchFor(type, trickModePreviousAutoSwitch);\n                        self.abrController.setQualityFor(type, trickModePreviousQuality);\n                    }\n\n                    if (!errored) {\n                        self.sourceBufferExt.removeSourceBuffer(mediaSource, buffer);\n                    }\n                    data = null;\n                    buffer = null;\n\n                    deferred.resolve();\n                }, function() {\n                    deferred.reject();\n                }\n            );\n\n            return deferred.promise;\n        },\n\n        getSegmentDuration: function() {\n            return segmentDuration;\n        },\n\n        setTrickMode: function(enabled, forward) {\n            var deferred = Q.defer();\n\n            this.debug.log(\"[BufferController][\" + type + \"] setTrickMode - enabled = \" + enabled);\n\n            if (trickModeEnabled === enabled) {\n                deferred.resolve();\n                return deferred.promise;\n            }\n            trickModeEnabled = enabled;\n\n            if (trickModeEnabled) {\n                // Trick mode enabled\n                // => store current quality and auto switch state\n                // => disable auto switch and set lowest quality\n                trickModeForward = forward;\n                trickModePreviousQuality = this.abrController.getQualityFor(type);\n                trickModePreviousAutoSwitch = this.abrController.getAutoSwitchFor(type);\n                this.abrController.setAutoSwitchFor(type, false);\n                this.abrController.setQualityFor(type, 0);\n                deferred.resolve();\n            } else {\n                // Trick mode disabled\n                // => restore ABR quality and auto switch state\n                this.abrController.setAutoSwitchFor(type, trickModePreviousAutoSwitch);\n                this.abrController.setQualityFor(type, trickModePreviousQuality);\n                removeBuffer.call(this).then(function() {\n                    deferred.resolve();\n                });\n            }\n\n            return deferred.promise;\n        },\n\n        start: doStart,\n        seek: doSeek,\n        stop: doStop,\n        seeked: doSeeked,\n        updateBufferLevel: updateBufferLevel\n    };\n};\n\nMediaPlayer.dependencies.BufferController.prototype = {\n    constructor: MediaPlayer.dependencies.BufferController\n};\n","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.dependencies.BufferExtensions = function () {\n    \"use strict\";\n\n    var minBufferTarget,\n        currentBufferTarget,\n        topAudioQualityIndex = 0,\n        topVideoQualityIndex = 0,\n        audioData = null,\n        videoData = null,\n\n        getCurrentHttpRequestLatency = function(metrics) {\n            var httpRequest = this.metricsExt.getCurrentHttpRequest(metrics);\n            if (httpRequest !== null) {\n                return (httpRequest.tresponse.getTime() - httpRequest.trequest.getTime()) / 1000;\n            }\n            return 0;\n        },\n\n        isPlayingAtTopQuality = function() {\n            var self = this,\n                audioQuality,\n                videoQuality,\n                isAtTop;\n\n            audioQuality = audioData ? self.abrController.getQualityFor(\"audio\") : topAudioQualityIndex;\n            videoQuality = videoData ? self.abrController.getQualityFor(\"video\") : topVideoQualityIndex;\n\n            isAtTop = (audioQuality === topAudioQualityIndex) &&\n                (videoQuality === topVideoQualityIndex);\n\n            return isAtTop;\n        };\n\n    return {\n        system:undefined,\n        videoModel: undefined,\n        metricsExt: undefined,\n        metricsModel: undefined,\n        abrController: undefined,\n        bufferMax: undefined,\n\n        updateData: function(data, type) {\n            if (data) {\n                var topIndex = data.Representation_asArray.length - 1;\n\n                if (type === \"audio\") {\n                    topAudioQualityIndex = topIndex;\n                    audioData = data;\n                } else if (type === \"video\") {\n                    topVideoQualityIndex = topIndex;\n                    videoData = data;\n                }\n            }\n        },\n\n        getTopQualityIndex: function(type) {\n            var topQualityIndex = null;\n\n            if (type === \"audio\") {\n                topQualityIndex = topAudioQualityIndex;\n            } else if (type === \"video\") {\n                topQualityIndex = topVideoQualityIndex;\n            }\n\n            return topQualityIndex;\n        },\n\n        decideBufferLength: function (minBufferTime, duration/*, waitingForBuffer*/) {\n\n            if (duration === Infinity) {\n                minBufferTarget = (minBufferTime > 0) ? minBufferTime : MediaPlayer.dependencies.BufferExtensions.DEFAULT_MIN_BUFFER_TIME;\n            } else if (minBufferTime >= duration) {\n                minBufferTarget = Math.min(duration, MediaPlayer.dependencies.BufferExtensions.DEFAULT_MIN_BUFFER_TIME);\n            } else {\n                minBufferTarget = Math.min(duration, minBufferTime);\n            }\n\n            return minBufferTarget;\n        },\n\n        getLeastBufferLevel: function() {\n            var videoMetrics = this.metricsModel.getReadOnlyMetricsFor(\"video\"),\n                videoBufferLevel = this.metricsExt.getCurrentBufferLevel(videoMetrics),\n                audioMetrics = this.metricsModel.getReadOnlyMetricsFor(\"audio\"),\n                audioBufferLevel = this.metricsExt.getCurrentBufferLevel(audioMetrics),\n                leastLevel = null;\n\n            if (videoBufferLevel === null || audioBufferLevel === null) {\n                leastLevel = (audioBufferLevel !== null) ? audioBufferLevel.level : ((videoBufferLevel !== null) ? videoBufferLevel.level : null);\n            } else {\n                leastLevel = Math.min(audioBufferLevel.level, videoBufferLevel.level);\n            }\n\n            return leastLevel;\n        },\n\n        getRequiredBufferLength: function (waitingForBuffer, delay, isDynamic, duration) {\n            var self = this,\n                vmetrics = self.metricsModel.getReadOnlyMetricsFor(\"video\"),\n                ametrics = self.metricsModel.getReadOnlyMetricsFor(\"audio\"),\n                isLongFormContent = (duration >= MediaPlayer.dependencies.BufferExtensions.LONG_FORM_CONTENT_DURATION_THRESHOLD),\n                deferred = Q.defer(),\n                isAtTop = false,\n                requiredBufferLength;\n\n            if (self.bufferMax === MediaPlayer.dependencies.BufferExtensions.BUFFER_SIZE_MIN) {\n                requiredBufferLength = minBufferTarget;\n                deferred.resolve(requiredBufferLength);\n            } else if (self.bufferMax === MediaPlayer.dependencies.BufferExtensions.BUFFER_SIZE_INFINITY) {\n                requiredBufferLength = duration;\n                deferred.resolve(requiredBufferLength);\n            } else if (self.bufferMax === MediaPlayer.dependencies.BufferExtensions.BUFFER_SIZE_REQUIRED) {\n                currentBufferTarget = minBufferTarget;\n\n                if (!isDynamic) {\n                    if (!waitingForBuffer) {\n                        isAtTop = isPlayingAtTopQuality.call(self);\n                    }\n                }\n\n                        if (isAtTop) {\n                            currentBufferTarget = isLongFormContent ?\n                                MediaPlayer.dependencies.BufferExtensions.BUFFER_TIME_AT_TOP_QUALITY_LONG_FORM :\n                                MediaPlayer.dependencies.BufferExtensions.BUFFER_TIME_AT_TOP_QUALITY;\n                        }\n\n                        requiredBufferLength = currentBufferTarget + delay + Math.max(getCurrentHttpRequestLatency.call(self, vmetrics),\n                            getCurrentHttpRequestLatency.call(self, ametrics));\n\n                        deferred.resolve(requiredBufferLength);\n            } else {\n                deferred.reject(\"invalid bufferMax value: \" + self.bufferMax);\n            }\n\n            return deferred.promise;\n        },\n\n        //TODO: need to add this info to MediaPlayer.vo.metrics.BufferLevel or create new metric?\n        getBufferTarget: function() {\n            return currentBufferTarget === undefined ? minBufferTarget : currentBufferTarget;\n        }\n    };\n};\n\nMediaPlayer.dependencies.BufferExtensions.BUFFER_SIZE_REQUIRED = \"required\";\nMediaPlayer.dependencies.BufferExtensions.BUFFER_SIZE_MIN = \"min\";\nMediaPlayer.dependencies.BufferExtensions.BUFFER_SIZE_INFINITY = \"infinity\";\nMediaPlayer.dependencies.BufferExtensions.BUFFER_TIME_AT_STARTUP = 1;\nMediaPlayer.dependencies.BufferExtensions.DEFAULT_MIN_BUFFER_TIME = 16;\nMediaPlayer.dependencies.BufferExtensions.DEFAULT_BUFFER_TO_KEEP = 30;\nMediaPlayer.dependencies.BufferExtensions.DEFAULT_LIVE_DELAY = 16;\nMediaPlayer.dependencies.BufferExtensions.BUFFER_TIME_AT_TOP_QUALITY = 30;\nMediaPlayer.dependencies.BufferExtensions.BUFFER_TIME_AT_TOP_QUALITY_LONG_FORM = 300;\nMediaPlayer.dependencies.BufferExtensions.LONG_FORM_CONTENT_DURATION_THRESHOLD = 600;\nMediaPlayer.dependencies.BufferExtensions.prototype.constructor = MediaPlayer.dependencies.BufferExtensions;\n","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.utils.Capabilities = function () {\n    \"use strict\";\n};\n\nMediaPlayer.utils.Capabilities.prototype = {\n    constructor: MediaPlayer.utils.Capabilities,\n    system: undefined,\n\n    supportsMediaSource: function () {\n        \"use strict\";\n\n        var hasWebKit = (\"WebKitMediaSource\" in window),\n            hasMediaSource = (\"MediaSource\" in window);\n\n        return (hasWebKit || hasMediaSource);\n    },\n\n    supportsMediaKeys: function () {\n        \"use strict\";\n\n        var hasWebKit = (\"WebKitMediaKeys\" in window),\n            hasMs = (\"MSMediaKeys\" in window),\n            hasMediaSource = (\"MediaKeys\" in window);\n\n        return (hasWebKit || hasMs || hasMediaSource);\n    },\n\n    /**\n     * Returns whether Encrypted Media Extensions are supported on this\n     * user agent\n     *\n     * @return {boolean} true if EME is supported, false otherwise\n     */\n    supportsEncryptedMedia: function () {\n        return this.system.hasMapping('protectionModel');\n    },\n\n    supportsCodec: function (element, codec) {\n        \"use strict\";\n\n        if (!(element instanceof HTMLMediaElement)) {\n            throw \"element must be of type HTMLMediaElement.\";\n        }\n\n        var canPlay = element.canPlayType(codec);\n        return (canPlay === \"probably\" || canPlay === \"maybe\");\n    }\n};","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.utils.Config = function () {\n    \"use strict\";\n\n    var paramsType = [\"video\", \"audio\"],\n\n        // Default configuration, provides list of possible parameters\n        params = {\n            // BufferController parameters\n            \"BufferController.minBufferTimeForPlaying\": -1,\n            \"BufferController.minBufferTime\": -1,\n            \"BufferController.bufferToKeep\": -1,\n            \"BufferController.liveDelay\": -1,\n            // ABR parameters\n            \"ABR.minBandwidth\": -1,\n            \"ABR.maxBandwidth\": -1,\n            \"ABR.minQuality\": -1,\n            \"ABR.maxQuality\": -1,\n            \"ABR.switchUpIncrementally\": -1,\n            \"ABR.switchUpRatioSafetyFactor\": -1,\n            \"ABR.latencyInBandwidth\": -1,\n            \"ABR.switchDownBufferTime\": -1,\n            \"ABR.switchDownBufferRatio\": -1,\n            \"ABR.switchLowerBufferTime\": -1,\n            \"ABR.switchLowerBufferRatio\": -1,\n            \"ABR.switchUpBufferTime\": -1,\n            \"ABR.switchUpBufferRatio\": -1,\n            \"ABR.keepBandwidthCondition\": -1,\n            \"ABR.droppedFramesMinRatio\": -1,\n            \"ABR.droppedFramesMaxRatio\": -1,\n            // Manifest loader parameters\n            \"ManifestLoader.RetryAttempts\": -1,\n            \"ManifestLoader.RetryInterval\": -1,\n            // Fragment loader parameters\n            \"FragmentLoader.RetryAttempts\": -1,\n            \"FragmentLoader.RetryInterval\": -1,\n            // Protection parameters\n            \"Protection.licensePersistence\": -1,\n            // Video parameters\n            \"video\": {\n            },\n            // Audio parameters\n            \"audio\": {\n            }\n        },\n\n        doSetParams = function (newParams) {\n            var item,\n                typeParams,\n                typeItem;\n\n            for (item in newParams) {\n                if (newParams.hasOwnProperty(item)) {\n                    // Check if comment\n                    if (item.indexOf('//') === -1) {\n                        // Check if type parameters\n                        if (paramsType.indexOf(item) > -1) {\n                            typeParams = newParams[item];\n                            for (typeItem in typeParams) {\n                                if (typeParams.hasOwnProperty(typeItem)) {\n                                    params[item][typeItem] = newParams[item][typeItem];\n                                }\n                            }\n                        } else {\n                            params[item] = newParams[item];\n                        }\n                    }\n                }\n            }\n        },\n\n        getParam = function (params, name, type, def) {\n            var value = params[name];\n\n            if ((value === undefined) || (value === -1)) {\n                return def;\n            }\n\n            if ((type !== undefined) && (typeof value !== type)) {\n                switch (type) {\n                    case 'number':\n                        value = Number(value);\n                        break;\n                    case 'boolean':\n                        value = (value === 'true') ||\n                                (value === '1') ||\n                                (value === 1);\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n            return value;\n        },\n\n        doGetParam = function (name, type, def) {\n            return getParam(params, name, type, def);\n        },\n\n        doGetParamFor = function (key, name, type, def) {\n            var typeParams = params[key];\n\n            if ((typeParams !== undefined) && (typeParams[name] !== undefined)) {\n                return getParam(typeParams, name, type, def);\n            }\n\n            return getParam(params, name, type, def);\n        };\n\n    return {\n        debug: undefined,\n\n        setup: function () {\n        },\n\n        setParams: function (newParams) {\n            doSetParams(newParams);\n\n            // Update debugger level if set in config\n            var level = this.getParam(\"Debug.level\", \"number\", -1);\n            if (level !== -1) {\n                this.debug.setLevel(level);\n            }\n        },\n\n        getParam: function (name, type, def) {\n            return doGetParam(name, type, def);\n        },\n\n        getParamFor: function (key, name, type, def) {\n            return doGetParamFor(key, name, type, def);\n        }\n    };\n};\n\nMediaPlayer.utils.Config.prototype = {\n    constructor: MediaPlayer.utils.Config\n};\n","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.di.Context = function () {\n    \"use strict\";\n\n    var mapProtectionModel = function() {\n        var videoElement = document.createElement(\"video\"),\n            debug = this.system.getObject(\"debug\");\n\n        /* @if PROTECTION=true */\n        // Detect EME APIs.  Look for newest API versions first\n        if (MediaPlayer.models.ProtectionModel_21Jan2015.detect(videoElement)) {\n            this.system.mapSingleton('protectionModel', MediaPlayer.models.ProtectionModel_21Jan2015);\n        } else if (MediaPlayer.models.ProtectionModel_3Feb2014.detect(videoElement)) {\n            this.system.mapClass('protectionModel', MediaPlayer.models.ProtectionModel_3Feb2014);\n        } else if (MediaPlayer.models.ProtectionModel_01b.detect(videoElement)) {\n            this.system.mapClass('protectionModel', MediaPlayer.models.ProtectionModel_01b);\n        } else {\n            debug.log(\"No supported version of EME detected on this user agent!\");\n            debug.log(\"Attempts to play encrypted content will fail!\");\n        }\n        /* @endif */\n    };\n\n    return {\n        system : undefined,\n        setup : function () {\n            this.system.autoMapOutlets = true;\n\n            // MediaPlayer.utils.*\n            this.system.mapSingleton('capabilities', MediaPlayer.utils.Capabilities);\n            this.system.mapSingleton('config', MediaPlayer.utils.Config);\n            this.system.mapSingleton('debug', MediaPlayer.utils.Debug);\n            this.system.mapSingleton('debugController', MediaPlayer.utils.DebugController);\n            this.system.mapClass('domParser', MediaPlayer.utils.DOMParser);\n            this.system.mapSingleton('eventBus', MediaPlayer.utils.EventBus);\n            this.system.mapSingleton('textTrackExtensions', MediaPlayer.utils.TextTrackExtensions);\n            this.system.mapSingleton('tokenAuthentication', MediaPlayer.utils.TokenAuthentication);\n            this.system.mapSingleton('vttParser', MediaPlayer.utils.VTTParser);\n            this.system.mapSingleton('ttmlParser', MediaPlayer.utils.TTMLParser);\n            this.system.mapSingleton('ttmlRenderer', MediaPlayer.utils.TTMLRenderer);\n\n            // MediaPlayer.models.*\n            this.system.mapSingleton('manifestModel', MediaPlayer.models.ManifestModel);\n            this.system.mapClass('metrics', MediaPlayer.models.MetricsList);\n            this.system.mapSingleton('metricsModel', MediaPlayer.models.MetricsModel);\n            this.system.mapSingleton('uriQueryFragModel', MediaPlayer.models.URIQueryAndFragmentModel);\n            this.system.mapSingleton('videoModel', MediaPlayer.models.VideoModel);\n\n            // MediaPlayer.dependencies.*\n            this.system.mapSingleton('abrController', MediaPlayer.dependencies.AbrController);\n            this.system.mapClass('bufferController', MediaPlayer.dependencies.BufferController);\n            this.system.mapSingleton('bufferExt', MediaPlayer.dependencies.BufferExtensions);\n            this.system.mapSingleton('errHandler', MediaPlayer.dependencies.ErrorHandler);\n            this.system.mapClass('eventController', MediaPlayer.dependencies.EventController);\n            this.system.mapClass('fragmentController', MediaPlayer.dependencies.FragmentController);\n            this.system.mapClass('fragmentInfoController', MediaPlayer.dependencies.FragmentInfoController);\n            this.system.mapClass('fragmentLoader', MediaPlayer.dependencies.FragmentLoader);\n            this.system.mapClass('fragmentModel', MediaPlayer.dependencies.FragmentModel);\n            this.system.mapClass('manifestLoader', MediaPlayer.dependencies.ManifestLoader);\n            this.system.mapSingleton('manifestUpdater', MediaPlayer.dependencies.ManifestUpdater);\n            this.system.mapSingleton('mediaSourceExt', MediaPlayer.dependencies.MediaSourceExtensions);\n            this.system.mapSingleton('notifier', MediaPlayer.dependencies.Notifier);\n            this.system.mapSingleton('parser', MediaPlayer.dependencies.Parser);\n            this.system.mapSingleton('sourceBufferExt', MediaPlayer.dependencies.SourceBufferExtensions);\n            this.system.mapClass('stream', MediaPlayer.dependencies.Stream);\n            this.system.mapSingleton('streamController', MediaPlayer.dependencies.StreamController);\n            this.system.mapClass('textController', MediaPlayer.dependencies.TextController);\n            this.system.mapSingleton('textSourceBuffer', MediaPlayer.dependencies.TextSourceBuffer);\n            this.system.mapSingleton('textTTMLXMLMP4SourceBuffer', MediaPlayer.dependencies.TextTTMLXMLMP4SourceBuffer);\n            this.system.mapSingleton('videoExt', MediaPlayer.dependencies.VideoModelExtensions);\n\n            // MediaPlayer.dependencies.protection.*\n            /* @if PROTECTION=true */\n            this.system.mapClass('protectionController', MediaPlayer.dependencies.ProtectionController);\n            this.system.mapSingleton('protectionExt', MediaPlayer.dependencies.ProtectionExtensions);\n            this.system.mapSingleton('ksClearKey', MediaPlayer.dependencies.protection.KeySystem_ClearKey);\n            this.system.mapSingleton('ksPlayReady', MediaPlayer.dependencies.protection.KeySystem_PlayReady);\n            this.system.mapSingleton('ksWidevine', MediaPlayer.dependencies.protection.KeySystem_Widevine);\n            this.system.mapSingleton('serverClearKey', MediaPlayer.dependencies.protection.servers.ClearKey);\n            this.system.mapSingleton('serverDRMToday', MediaPlayer.dependencies.protection.servers.DRMToday);\n            this.system.mapSingleton('serverPlayReady', MediaPlayer.dependencies.protection.servers.PlayReady);\n            this.system.mapSingleton('serverWidevine', MediaPlayer.dependencies.protection.servers.Widevine);\n            /* @endif */\n            mapProtectionModel.call(this); // Determines EME API support and version\n\n            // MediaPlayer.rules.*\n            this.system.mapClass('abrRulesCollection', MediaPlayer.rules.BaseRulesCollection);\n            this.system.mapClass('abandonRequestRule', MediaPlayer.rules.AbandonRequestsRule);\n            this.system.mapClass('downloadRatioRule', MediaPlayer.rules.DownloadRatioRule);\n            this.system.mapClass('droppedFramesRule', MediaPlayer.rules.DroppedFramesRule);\n            this.system.mapClass('insufficientBufferRule', MediaPlayer.rules.InsufficientBufferRule);\n            this.system.mapClass('limitSwitchesRule', MediaPlayer.rules.LimitSwitchesRule);\n\n            // Dash.dependencies.*\n            this.system.mapClass('baseURLExt', Dash.dependencies.BaseURLExtensions);\n            this.system.mapClass('fragmentExt', Dash.dependencies.FragmentExtensions);\n            this.system.mapClass('indexHandler', Dash.dependencies.DashHandler);\n            this.system.mapSingleton('manifestExt', Dash.dependencies.DashManifestExtensions);\n            //this.system.mapSingleton('metricsExt', Dash.dependencies.DashMetricsExtensions);\n            this.system.mapSingleton('metricsExt', MediaPlayer.dependencies.MetricsExtensions);\n            this.system.mapSingleton('timelineConverter', Dash.dependencies.TimelineConverter);\n            this.system.mapClass('dashParser', Dash.dependencies.DashParser);\n\n            // Mss package if available\n            if (Mss.dependencies.MssParser) {\n                this.system.mapClass('mssParser', Mss.dependencies.MssParser);\n            }\n\n            // Hls package if available\n            if (Hls.dependencies.HlsParser) {\n                this.system.mapClass('hlsParser', Hls.dependencies.HlsParser);\n                this.system.mapSingleton('hlsDemux', Hls.dependencies.HlsDemux);\n            }\n            // But we do always provide HlsStream to support HLS(+FP) streams in Safari\n            this.system.mapClass('hlsStream', Hls.dependencies.HlsStream);\n\n            // Create the context manager to plug some specific parts of the code\n            this.system.mapSingleton('contextManager', MediaPlayer.modules.ContextManager);\n\n            // Plug message handler. When the message is notify, the contextManager is called\n            this.system.mapHandler('setContext', 'contextManager', 'setContext');\n        }\n    };\n};\n","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.modules.ContextManager = function (){\n    \"use strict\";\n\n    return {\n        system: undefined,\n        debug: undefined,\n\n        setContext: function(ctx) {\n            this.system.autoMapOutlets = true;\n\n            if (ctx === \"MSS\") {\n                // here we map specific Class\n                this.system.mapClass('mp4Processor', MediaPlayer.dependencies.Mp4Processor);\n                this.system.mapClass('indexHandler', Mss.dependencies.MssHandler);\n                this.system.mapClass('fragmentController', Mss.dependencies.MssFragmentController);\n            } else if (ctx === \"HLS\") {\n                this.system.mapClass('mp4Processor', MediaPlayer.dependencies.Mp4Processor);\n                this.system.mapClass('fragmentController', Hls.dependencies.HlsFragmentController);\n                this.system.mapClass('indexHandler', Hls.dependencies.HlsHandler);\n            } else {\n                this.system.mapClass('fragmentController', MediaPlayer.dependencies.FragmentController);\n                this.system.mapClass('indexHandler', Dash.dependencies.DashHandler);\n            }\n        }\n    };\n};\n\nMediaPlayer.modules.ContextManager.prototype =  {\n    constructor: MediaPlayer.modules.ContextManager\n};\n","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.utils.Debug = function () {\n    \"use strict\";\n\n    Date.prototype.HHMMSSmmm = function() {\n\n        var h = this.getHours().toString(),\n            m = this.getMinutes().toString(),\n            s = this.getSeconds().toString(),\n            ms = this.getMilliseconds().toString(),\n            HH = h[1] ? h : \"0\" + h[0],\n            MM = m[1] ? m : \"0\" + m[0],\n            SS = s[1] ? s : \"0\" + s[0],\n            mmm = ms[2] ? ms : \"0\" + (ms[1] ? ms : \"0\" + ms[0]);\n\n        return HH + \":\" + MM + \":\" + SS + \".\" + mmm;\n    };\n\n    Date.prototype.MMSSmmm = function() {\n\n        var m = this.getMinutes().toString(),\n            s = this.getSeconds().toString(),\n            ms = this.getMilliseconds().toString(),\n            MM = m[1] ? m : \"0\" + m[0],\n            SS = s[1] ? s : \"0\" + s[0],\n            mmm = ms[2] ? ms : \"0\" + (ms[1] ? ms : \"0\" + ms[0]);\n\n        return MM + \":\" + SS + \".\" + mmm;\n    };\n\n    // MemoryLogger definition\n\n    var MemoryLogger = function(){\n        // array to store logs\n        this.logArray= [];\n        // boolean to set leve in message\n        this.showLevel = true;\n    };\n\n\n    MemoryLogger.prototype.error =\n    MemoryLogger.prototype.warn = \n    MemoryLogger.prototype.info =\n    MemoryLogger.prototype.debug  = function(message){\n        this.logArray.push(message);\n    };\n\n    MemoryLogger.prototype.getLogs = function(){\n        return this.logArray;\n    };\n\n    // ORANGE: add level\n    var NONE  = 0,\n        ERROR = 1,\n        WARN  = 2,\n        INFO  = 3,\n        DEBUG = 4,\n        ALL   = 4,\n        level = 0,\n        showTimestamp = true,\n        showElapsedTime = false,\n        startTime = new Date(),\n        // default logger set to console\n        _logger = console,\n\n        _log = function (logLevel, args) {\n            if (logLevel <= getLevel()) {\n\n                var message = _prepareLog(logLevel, args);\n\n                switch (logLevel) {\n                    case ERROR:\n                        _logger.error(message);\n                        break;\n                    case WARN:\n                        _logger.warn(message);\n                        break;\n                    case INFO:\n                        _logger.info(message);\n                        break;\n                    case DEBUG:\n                        _logger.debug(message);\n                        break;\n                }\n                \n            }\n\n        },\n\n        _prepareLog = function(logLevel, args){\n            var message = \"\",\n                logTime = null;\n\n            if (showTimestamp) {\n                logTime = new Date();\n                message += \"[\" + logTime.HHMMSSmmm() + \"]\";\n            }\n\n            if(_logger && _logger.showLevel){\n                 message += \"[\"+_getStringLevel(logLevel)+\"]\";\n            }\n\n            if (showElapsedTime) {\n                message += \"[\" + new Date(logTime - startTime).MMSSmmm() + \"]\";\n            }\n\n            Array.apply(null, args).forEach(function(item) {\n                message += item + \" \";\n            });\n\n            return message;\n        },\n\n        _getStringLevel = function(level){\n            switch(level){\n                case ERROR:\n                return \"ERROR\";\n                case WARN:\n                return \"WARN\";\n                case INFO:\n                return \"INFO\";\n                case DEBUG:\n                return \"DEBUG\";\n                default:\n                return \"\";\n            }\n        },\n\n        getLevel = function() {\n            return level;\n        },\n\n        getLogger = function () {\n            return _logger;\n        };\n\n    return {\n        \n        // ORANGE: add level\n        NONE:   NONE,\n        ERROR:  ERROR,\n        WARN:   WARN,\n        INFO:   INFO,\n        DEBUG:  DEBUG,\n        ALL:    ALL,\n\n        getLevel: getLevel,\n        getLogger: getLogger,\n\n        setLevel: function(value) {\n            level  = value;\n        },\n\n        setLogger: function(type){\n           switch(type){\n                case 'log4javascript' :\n                    var appender = new log4javascript.PopUpAppender();\n                    var layout = new log4javascript.PatternLayout(\"%d{HH:mm:ss.SSS} %-5p - %m%n\");\n                    appender.setLayout(layout);\n                    _logger.addAppender(appender);\n                    _logger.setLevel(log4javascript.Level.ALL);\n                    _logger.initialized = true;\n                break;\n\n                case 'memory':\n                    _logger = new MemoryLogger();\n                break;\n\n                case 'console':\n                    _logger = console;\n                break;\n\n                default:\n                    _logger = null;\n           }\n        },\n\n        error: function () {\n            _log.call(this, ERROR, arguments);\n        },\n\n        warn: function () {\n            _log.call(this, WARN, arguments);\n        },\n\n        info: function () {\n            _log.call(this, INFO, arguments);\n        },\n\n        // Keep this function for compatibility\n        log: function () {\n            _log.call(this, DEBUG, arguments);\n        }\n    };\n};\n","/**\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2016, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * @constructs DebugController\n * @description A class which allow to download debug data on specific keybord shortcut\n */\nMediaPlayer.utils.DebugController = function() {\n    'use strict';\n\n    // debug data configuration\n    var debugData = {\n        isInDebug: false,\n        level: 0,\n        loggerType: 'console'\n    };\n\n    var version = '';\n\n    var _handleKeyPressedEvent = function(e) {\n        // if we press ctrl + alt + maj + z we activate debug mode\n        if ((e.altKey === true) && (e.ctrlKey === true) && (e.shiftKey === true) &&\n            ((e.keyCode === 68) || (e.keyCode === 90))) {\n            if (debugData.isInDebug) {\n                console.log('hasplayer.js debug OFF (v' + version + ')');\n                debugData.isInDebug = false;\n                if (e.keyCode === 90) {\n                    _downloadDebug(this.debug.getLogger().getLogs());\n                    this.debug.setLevel(debugData.level);\n                    this.debug.setLogger(debugData.loggerType);\n                } else {\n                    this.debug.setLevel(0);\n                }\n            } else {\n                console.log('hasplayer.js debug ON (v' + version + ')');\n                debugData.isInDebug = true;\n                debugData.level = this.debug.getLevel();\n                this.debug.setLevel((e.keyCode === 68) ? 4 : 3);\n                this.debug.setLogger((e.keyCode === 68) ? 'console' : 'memory');\n            }\n        }\n    };\n\n    var _downloadDebug = function(array) {\n        if (array && array.length > 0) {\n            var filename = 'hasplayer_logs.txt',\n                data = JSON.stringify(array, null, '\\r\\n'),\n                blob = new Blob([data], {\n                    type: 'text/json'\n                });\n\n            if (navigator.msSaveBlob) { // For IE10+ and edge\n                navigator.msSaveBlob(blob, filename);\n            } else {\n                var e = document.createEvent('MouseEvents'),\n                    a = document.createElement('a');\n                a.download = filename;\n                a.href = window.URL.createObjectURL(blob);\n                a.dataset.downloadurl = ['text/json', a.download, a.href].join(':');\n                e.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);\n                a.dispatchEvent(e);\n            }\n        }\n    };\n\n    return {\n        debug: undefined,\n\n        setup: function() {\n            window.addEventListener('keydown', _handleKeyPressedEvent.bind(this));\n        },\n\n        init: function(ver) {\n            version = ver;\n        }\n\n    };\n};\n\nMediaPlayer.utils.DebugController.prototype = {\n    constructor: MediaPlayer.utils.DebugController\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nMediaPlayer.dependencies.ErrorHandler = function () {\n    \"use strict\";\n\n    return {\n        eventBus: undefined,\n        debug: undefined,\n\n        sendWarning: function (code, message, data) {\n            this.debug.warn(\"[Warn] Code: \" + code + \", Message: \" + message + \", Data: \" + JSON.stringify(data, null, '\\t'));\n            this.eventBus.dispatchEvent({\n                type: \"warning\",\n                data: {code : code, message: message, data: data}\n            });\n        },\n\n        sendError: function (code, message, data) {\n            this.debug.error(\"[Error] Code: \" + code + \", Message: \" + message + \", Data: \" + JSON.stringify(data, null, '\\t'));\n            this.eventBus.dispatchEvent({\n                type: \"error\",\n                data: {code : code, message: message, data: data}\n            });\n        }\n    };\n};\n\nMediaPlayer.dependencies.ErrorHandler.prototype = {\n    constructor: MediaPlayer.dependencies.ErrorHandler\n};\n\n// <video> element errors\nMediaPlayer.dependencies.ErrorHandler.prototype.INTERNAL_ERROR = \"INTERNAL_ERROR\";\n\n// <video> element errors\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_ABORTED = \"MEDIA_ERR_ABORTED\";\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_NETWORK = \"MEDIA_ERR_NETWORK\";\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_DECODE = \"MEDIA_ERR_DECODE\";\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_SRC_NOT_SUPPORTED = \"MEDIA_ERR_SRC_NOT_SUPPORTED\";\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_ENCRYPTED = \"MEDIA_ERR_ENCRYPTED\";\n\nMediaPlayer.dependencies.ErrorHandler.prototype.CAPABILITY_ERR_MEDIASOURCE = \"CAPABILITY_ERR_MEDIASOURCE\";\nMediaPlayer.dependencies.ErrorHandler.prototype.CAPABILITY_ERR_MEDIAKEYS = \"CAPABILITY_ERR_MEDIAKEYS\";\n\n// MSE errors\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CREATE_MEDIASOURCE = \"MEDIA_ERR_CREATE_MEDIASOURCE\";\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CODEC_UNSUPPORTED = \"MEDIA_ERR_CODEC_UNSUPPORTED\";\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CREATE_SOURCEBUFFER = \"MEDIA_ERR_CREATE_SOURCEBUFFER\";\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_APPEND_SOURCEBUFFER = \"MEDIA_ERR_APPEND_SOURCEBUFFER\";\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_REMOVE_SOURCEBUFFER = \"MEDIA_ERR_REMOVE_SOURCEBUFFER\";\n\n// MediaPlayer errors\nMediaPlayer.dependencies.ErrorHandler.prototype.MANIFEST_ERR_PARSE = \"MANIFEST_ERR_PARSE\";\nMediaPlayer.dependencies.ErrorHandler.prototype.MANIFEST_ERR_NO_STREAM = \"MANIFEST_ERR_NO_STREAM\";\nMediaPlayer.dependencies.ErrorHandler.prototype.MANIFEST_ERR_NO_VIDEO = \"MANIFEST_ERR_NO_VIDEO\";\nMediaPlayer.dependencies.ErrorHandler.prototype.MANIFEST_ERR_NO_AUDIO = \"MANIFEST_ERR_NO_AUDIO\";\nMediaPlayer.dependencies.ErrorHandler.prototype.MANIFEST_ERR_NO_TEXT = \"MANIFEST_ERR_NO_TEXT\";\nMediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_MANIFEST = \"DOWNLOAD_ERR_MANIFEST\";\nMediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_SIDX = \"DOWNLOAD_ERR_SIDX\";\nMediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_INIT = \"DOWNLOAD_ERR_INIT\";\nMediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_CONTENT = \"DOWNLOAD_ERR_CONTENT\";\n\n// MSS errors\nMediaPlayer.dependencies.ErrorHandler.prototype.MSS_NO_TFRF = \"MSS_NO_TFRF\";\n\n// HLS errors\nMediaPlayer.dependencies.ErrorHandler.prototype.HLS_INVALID_PACKET_ERROR = \"HLS_INVALID_PACKET_ERROR\";\nMediaPlayer.dependencies.ErrorHandler.prototype.HLS_DEMUX_ERROR = \"HLS_DEMUX_ERROR\";\nMediaPlayer.dependencies.ErrorHandler.prototype.HLS_INVALID_KEY_ERROR = \"HLS_INVALID_KEY_ERROR\";\n\n// MediaKeyError from EME v0.1b (https://dvcs.w3.org/hg/html-media/raw-file/eme-v0.1b/encrypted-media/encrypted-media.html)\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR = \"MEDIA_KEYERR\";\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_UNKNOWN = \"MEDIA_KEYERR_UNKNOWN\";\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_CLIENT = \"MEDIA_KEYERR_CLIENT\";\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_SERVICE = \"MEDIA_KEYERR_SERVICE\";\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_OUTPUT = \"MEDIA_KEYERR_OUTPUT\";\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_HARDWARECHANGE = \"MEDIA_KEYERR_HARDWARECHANGE\";\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_DOMAIN = \"MEDIA_KEYERR_DOMAIN\";\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_EXPIRED = \"MEDIA_KEYERR_EXPIRED\";\n\n// Key system errors\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYSYSERR_ACCESS_DENIED = \"MEDIA_KEYSYSERR_ACCESS_DENIED\";\n\n// Key/license errors\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_URL_LICENSER_UNKNOWN = \"MEDIA_KEYMESSERR_URL_LICENSER_UNKNOWN\";\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_NO_CHALLENGE = \"MEDIA_KEYMESSERR_NO_CHALLENGE\";\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_LICENSER_ERROR = \"MEDIA_KEYMESSERR_LICENSER_ERROR\";\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_NO_SESSION = \"MEDIA_KEYMESSERR_NO_SESSION\";\n\n// Other MediaKeyError\nMediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_SERVER_CERTIFICATE = \"MEDIA_KEYERR_SERVER_CERTIFICATE\";\n\n// DOM exceptions (see http://www.w3.org/TR/WebIDL-1/#h-idl-domexception-error-names)\nMediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_INDEX_SIZE = 1;\nMediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_HIERARCHY_REQUEST = 3;\nMediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_WRONG_DOCUMENT = 4;\nMediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_INVALID_CHARACTER = 5;\nMediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_NO_MODIFICATION_ALLOWED = 7;\nMediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_NOT_FOUND = 8;\nMediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_NOT_SUPPORTED = 9;\nMediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_INVALID_STATE = 11;\nMediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_SYNTAX = 12;\nMediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_INVALID_MODIFICATION = 13;\nMediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_NAMESPACE = 14;\nMediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_INVALID_ACCESS = 15;\nMediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_SECURITY = 18;\nMediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_NETWORK = 19;\nMediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_ABORT = 20;\nMediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_URL_MISMATCH = 21;\nMediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_QUOTA_EXCEEDED = 22;\nMediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_TIMEOUT = 23;\nMediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_INVALID_NODE_TYPE = 24;\nMediaPlayer.dependencies.ErrorHandler.prototype.DOM_ERR_DATA_CLONE = 25;\n","MediaPlayer.utils.EventBus = function() {\n    \"use strict\";\n\n    var registrations,\n\n        getListeners = function(type, useCapture) {\n            var captype = (useCapture ? '1' : '0') + type;\n\n            if (!(captype in registrations)) {\n                registrations[captype] = [];\n            }\n\n            return registrations[captype];\n        },\n\n        init = function() {\n            registrations = {};\n        };\n\n    init();\n\n    return {\n        addEventListener: function(type, listener, useCapture) {\n            var listeners = getListeners(type, useCapture),\n                idx = listeners.indexOf(listener);\n\n            if (idx === -1) {\n                listeners.push(listener);\n            }\n        },\n\n        removeEventListener: function(type, listener, useCapture) {\n            var listeners = getListeners(type, useCapture),\n                idx = listeners.indexOf(listener);\n\n            if (idx !== -1) {\n                listeners.splice(idx, 1);\n            }\n        },\n\n        dispatchEvent: function(evt) {\n            var listeners = getListeners(evt.type, false).slice(),\n                i = 0;\n\n            for (i = 0; i < listeners.length; i += 1) {\n                listeners[i].call(this, evt);\n            }\n            return !evt.defaultPrevented;\n        }\n    };\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Fraunhofer Fokus\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.dependencies.EventController = function() {\n    \"use strict\";\n\n\n    var inlineEvents = [], // Holds all Inline Events not triggered yet\n        inbandEvents = [], // Holds all Inband Events not triggered yet\n        activeEvents = [], // Holds all Events currently running\n        eventInterval = null, // variable holding the setInterval\n        refreshDelay = 100, // refreshTime for the setInterval\n        presentationTimeThreshold = refreshDelay / 1000,\n        MPD_RELOAD_SCHEME = \"urn:mpeg:dash:event:2012\",\n        MPD_RELOAD_VALUE = 1,\n\n        reset = function() {\n            if (eventInterval !== null) {\n                clearInterval(eventInterval);\n                eventInterval = null;\n            }\n            inlineEvents = null;\n            inbandEvents = null;\n            activeEvents = null;\n        },\n\n        clear = function() {\n            if (eventInterval !== null) {\n                clearInterval(eventInterval);\n                eventInterval = null;\n            }\n        },\n\n        start = function() {\n            var self = this;\n\n            self.debug.log(\"[EventController] Start Event Controller\");\n            if (!isNaN(refreshDelay)) {\n                eventInterval = setInterval(onEventTimer.bind(this), refreshDelay);\n            }\n        },\n\n        /**\n         * Add events to the eventList. Events that are not in the mpd anymore but not triggered yet will still be deleted\n         * @param values\n         */\n        addInlineEvents = function(values) {\n            var self = this;\n            inlineEvents = [];\n\n            if (values && values.length > 0) {\n                inlineEvents = values;\n            }\n            self.debug.log(\"[EventController] Added \" + values.length + \" inline events\");\n        },\n\n        /**\n         * i.e. processing of any one event message box with the same id is sufficient\n         * @param values\n         */\n        addInbandEvents = function(values) {\n            var self = this,\n                i = 0,\n                event;\n\n            for (i = 0; i < values.length; i++) {\n                event = values[i];\n                inbandEvents[event.id] = event;\n                self.debug.log(\"[EventController] Add inband event with id \" + event.id);\n            }\n        },\n\n        /**\n         * Itereate through the eventList and trigger/remove the events\n         */\n        onEventTimer = function() {\n            triggerEvents.call(this, inbandEvents);\n            triggerEvents.call(this, inlineEvents);\n            removeEvents.call(this);\n        },\n\n        triggerEvents = function(events) {\n            var self = this,\n                currentVideoTime = this.videoModel.getCurrentTime(),\n                presentationTime,\n                j = 0,\n                curr;\n\n            /* == Trigger events that are ready == */\n            if (events) {\n                for (j = 0; j < events.length; j++) {\n                    curr = events[j];\n\n                    if (curr !== undefined) {\n                        presentationTime = curr.presentationTime / curr.eventStream.timescale;\n                        if (presentationTime === 0 || (presentationTime <= currentVideoTime && presentationTime + presentationTimeThreshold > currentVideoTime)) {\n                            self.debug.log(\"[EventController] Start Event at \" + currentVideoTime);\n                            if (curr.duration > 0) {\n                                activeEvents.push(curr);\n                            }\n                            if (curr.eventStream.schemeIdUri === MPD_RELOAD_SCHEME && curr.eventStream.value === MPD_RELOAD_VALUE) {\n                                refreshManifest.call(this);\n                            }\n                            events.splice(j, 1);\n                        }\n                    }\n                }\n            }\n        },\n\n        /**\n         * Remove events from the list that are over\n         */\n        removeEvents = function() {\n            var self = this,\n                currentVideoTime,\n                i = 0,\n                curr;\n\n            if (activeEvents) {\n                currentVideoTime = this.videoModel.getCurrentTime();\n\n                for (i = 0; i < activeEvents.length; i++) {\n                    curr = activeEvents[i];\n                    if (curr !== null && (curr.duration + curr.presentationTime) / curr.eventStream.timescale < currentVideoTime) {\n                        self.debug.log(\"[EventController] Remove Event at time \" + currentVideoTime);\n                        curr = null;\n                        activeEvents.splice(i, 1);\n                    }\n                }\n            }\n\n        },\n\n        refreshManifest = function() {\n            var self = this,\n                manifest = self.manifestModel.getValue(),\n                url = manifest.mpdUrl;\n\n            if (manifest.hasOwnProperty(\"Location\")) {\n                url = manifest.Location;\n            }\n            self.debug.log(\"[EventController] Refresh manifest @ \" + url);\n            self.manifestLoader.load(url).then(\n                function(manifestResult) {\n                    self.manifestModel.setValue(manifestResult);\n                }\n            );\n        };\n\n    return {\n        manifestModel: undefined,\n        manifestLoader: undefined,\n        debug: undefined,\n        system: undefined,\n        videoModel: undefined,\n        addInlineEvents: addInlineEvents,\n        addInbandEvents: addInbandEvents,\n        reset: reset,\n        clear: clear,\n        start: start\n    };\n\n};\n\nMediaPlayer.dependencies.EventController.prototype = {\n    constructor: MediaPlayer.dependencies.EventController\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.dependencies.FragmentController = function() {\n    \"use strict\";\n\n    var fragmentModels = [],\n\n        findModel = function(bufferController) {\n            var ln = fragmentModels.length,\n                i = 0;\n            // We expect one-to-one relation between FragmentModel and BufferController,\n            // so just compare the given BufferController object with the one that stored in the model to find the model for it\n            for (i = 0; i < ln; i += 1) {\n                if (fragmentModels[i].getContext() === bufferController) {\n                    return fragmentModels[i];\n                }\n            }\n\n            return null;\n        },\n\n        isReadyToLoadNextFragment = function() {\n            var isReady = true,\n                ln = fragmentModels.length,\n                i = 0;\n            // Loop through the models and check if all of them are in the ready state\n            for (i = 0; i < ln; i += 1) {\n                if (!fragmentModels[i].isReady()) {\n                    isReady = false;\n                    break;\n                }\n            }\n\n            return isReady;\n        },\n\n        executeRequests = function() {\n            var i = 0;\n\n            for (i = 0; i < fragmentModels.length; i += 1) {\n                fragmentModels[i].executeCurrentRequest();\n            }\n        };\n\n    return {\n        system: undefined,\n        debug: undefined,\n\n        process: function(bytes) {\n            var result = null;\n\n            if (bytes !== null && bytes !== undefined && bytes.byteLength > 0) {\n                result = new Uint8Array(bytes);\n            }\n\n            return Q.when(result);\n        },\n\n        attachBufferController: function(bufferController) {\n            var model;\n\n            if (!bufferController) {\n                return null;\n            }\n            // Wrap the buffer controller into model and store it to track the loading state and execute the requests\n            model = findModel(bufferController);\n\n            if (!model) {\n                model = this.system.getObject(\"fragmentModel\");\n                model.setContext(bufferController);\n                fragmentModels.push(model);\n            }\n\n            return model;\n        },\n\n        detachBufferController: function(bufferController) {\n            var idx = fragmentModels.indexOf(bufferController);\n            // If we have the model for the given buffer just remove it from array\n            if (idx > -1) {\n                fragmentModels.splice(idx, 1);\n            }\n        },\n\n        onBufferControllerStateChange: function() {\n            // Check if we are ready to execute pending requests and do it\n            if (isReadyToLoadNextFragment()) {\n                executeRequests.call(this);\n            }\n        },\n\n        isFragmentLoadedOrPending: function(bufferController, request) {\n            var fragmentModel = findModel(bufferController),\n                isLoaded;\n\n            if (!fragmentModel) {\n                return false;\n            }\n\n            isLoaded = fragmentModel.isFragmentLoadedOrPending(request);\n\n            return isLoaded;\n        },\n\n        getPendingRequests: function(bufferController) {\n            var fragmentModel = findModel(bufferController);\n\n            if (!fragmentModel) {\n                return null;\n            }\n\n            return fragmentModel.getPendingRequests();\n        },\n\n        getLoadingRequests: function(bufferController) {\n            var fragmentModel = findModel(bufferController);\n\n            if (!fragmentModel) {\n                return null;\n            }\n\n            return fragmentModel.getLoadingRequests();\n        },\n\n        isInitializationRequest: function(request) {\n            return (request && request.type && request.type.toLowerCase() === \"initialization segment\");\n        },\n\n        getLoadingTime: function(bufferController) {\n            var fragmentModel = findModel(bufferController);\n\n            if (!fragmentModel) {\n                return null;\n            }\n\n            return fragmentModel.getLoadingTime();\n        },\n\n        getExecutedRequestForTime: function(model, time) {\n            if (model) {\n                return model.getExecutedRequestForTime(time);\n            }\n\n            return null;\n        },\n\n        removeExecutedRequest: function(model, request) {\n            if (model) {\n                model.removeExecutedRequest(request);\n            }\n        },\n\n        removeExecutedRequestsBeforeTime: function(model, time) {\n            if (model) {\n                model.removeExecutedRequestsBeforeTime(time);\n            }\n        },\n\n        clearExecutedRequests: function(model) {\n            if (model) {\n                model.clearExecutedRequests();\n            }\n        },\n\n        cancelPendingRequestsForModel: function(model) {\n            if (model) {\n                model.cancelPendingRequests();\n            }\n        },\n\n        abortRequestsForModel: function(model) {\n            if (model) {\n                model.abortRequests();\n            }\n        },\n\n        prepareFragmentForLoading: function(bufferController, request, startLoadingCallback, successLoadingCallback, errorLoadingCallback, streamEndCallback) {\n            var fragmentModel = findModel(bufferController);\n\n            if (!fragmentModel || !request) {\n                return null;\n            }\n            // Store the request and all the necessary callbacks in the model for deferred execution\n            fragmentModel.addRequest(request);\n            fragmentModel.setCallbacks(startLoadingCallback, successLoadingCallback, errorLoadingCallback, streamEndCallback);\n\n            return true;\n        }\n    };\n};\n\nMediaPlayer.dependencies.FragmentController.prototype = {\n    constructor: MediaPlayer.dependencies.FragmentController\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.dependencies.FragmentLoader = function() {\n    \"use strict\";\n\n    var DEFAULT_RETRY_ATTEMPTS = 2,\n        DEFAULT_RETRY_INTERVAL = 500,\n        retryAttempts = DEFAULT_RETRY_ATTEMPTS,\n        retryInterval = DEFAULT_RETRY_INTERVAL,\n        retryCount = 0,\n        xhrs = [],\n        type,\n\n        _checkForExistence = function(request) {\n            var req = new XMLHttpRequest(),\n                isSuccessful = false;\n\n            req.open(\"HEAD\", request.url, true);\n\n            req.onload = function() {\n                if (req.status < 200 || req.status > 399) {\n                    return;\n                }\n                isSuccessful = true;\n                request.deferred.resolve(request);\n            };\n\n            req.onloadend = req.onerror = function() {\n                if (isSuccessful) {\n                    return;\n                }\n                request.deferred.reject(req);\n            };\n\n            req.send();\n        },\n\n        _loadRequest = function(request) {\n            var deferred = Q.defer(),\n                req = new XMLHttpRequest(),\n                httpRequestMetrics = null,\n                firstProgress = true,\n                needFailureReport = true,\n                lastTraceTime = null,\n                self = this;\n\n            xhrs.push(req);\n            request.requestStartDate = new Date();\n\n            httpRequestMetrics = self.metricsModel.addHttpRequest(\n                request.streamType,\n                null,\n                request.type,\n                request.url,\n                null,\n                request.range,\n                request.requestStartDate,\n                null,\n                null,\n                null,\n                null,\n                request.duration,\n                request.startTime,\n                request.quality);\n\n            self.metricsModel.appendHttpTrace(\n                httpRequestMetrics,\n                request.requestStartDate,\n                request.requestStartDate.getTime() - request.requestStartDate.getTime(), [0]);\n\n            lastTraceTime = request.requestStartDate;\n\n            req.open(\"GET\", self.tokenAuthentication.addTokenAsQueryArg(request.url), true);\n            req.responseType = \"arraybuffer\";\n            req = self.tokenAuthentication.setTokenInRequestHeader(req);\n\n            if (request.range) {\n                req.setRequestHeader(\"Range\", 'bytes='+request.range);\n            }\n\n            req.onprogress = function(event) {\n                var currentTime = new Date();\n                if (firstProgress) {\n                    firstProgress = false;\n                    if (!event.lengthComputable || (event.lengthComputable && event.total !== event.loaded)) {\n                        request.firstByteDate = currentTime;\n                        httpRequestMetrics.tresponse = currentTime;\n                    }\n                }\n\n                if (event.lengthComputable) {\n                    request.bytesLoaded = event.loaded;\n                    request.bytesTotal = event.total;\n                }\n\n                self.metricsModel.appendHttpTrace(\n                    httpRequestMetrics,\n                    currentTime,\n                    currentTime.getTime() - lastTraceTime.getTime(), [request.bytesLoaded ? request.bytesLoaded : 0]);\n\n                lastTraceTime = currentTime;\n\n                self.notify(MediaPlayer.dependencies.FragmentLoader.eventList.ENAME_LOADING_PROGRESS, {\n                    request: request,\n                    httpRequestMetrics: httpRequestMetrics,\n                    lastTraceTime: lastTraceTime\n                });\n\n            };\n\n            req.onload = function() {\n                if (req.status < 200 || req.status > 399) {\n                    return;\n                }\n                needFailureReport = false;\n\n                var currentTime = new Date(),\n                    bytes = req.response,\n                    bytesLength = (bytes ? bytes.byteLength : 0),\n                    latency,\n                    download;\n\n                if (!request.firstByteDate) {\n                    request.firstByteDate = request.requestStartDate;\n                }\n                request.requestEndDate = currentTime;\n\n                latency = (request.firstByteDate.getTime() - request.requestStartDate.getTime());\n                download = (request.requestEndDate.getTime() - request.firstByteDate.getTime());\n\n                self.debug.log(\"[FragmentLoader][\"+type+\"] Loaded: \" + request.url + \" (\" + req.status + \", \" + latency + \"ms, \" + download + \"ms)\");\n\n                httpRequestMetrics.tresponse = request.firstByteDate;\n                httpRequestMetrics.tfinish = request.requestEndDate;\n                httpRequestMetrics.responsecode = req.status;\n\n                httpRequestMetrics.bytesLength = bytesLength;\n\n                self.metricsModel.appendHttpTrace(\n                    httpRequestMetrics,\n                    currentTime,\n                    currentTime.getTime() - lastTraceTime.getTime(), [bytesLength]);\n\n                lastTraceTime = currentTime;\n\n                deferred.resolve({\n                    data: bytes,\n                    request: request\n                });\n            };\n\n            req.onabort = function() {\n                var currentTime = new Date(),\n                    lastTrace,\n                    bytes;\n\n                req.aborted = true;\n\n                if (httpRequestMetrics.trace.length === 0) {\n                    return;\n                }\n                lastTrace = httpRequestMetrics.trace[httpRequestMetrics.trace.length - 1];\n                bytes = lastTrace.b[0];\n\n                request.requestEndDate = currentTime;\n                httpRequestMetrics.tresponse = request.firstByteDate;\n                httpRequestMetrics.tfinish = request.requestEndDate;\n                httpRequestMetrics.responsecode = req.status;\n\n                httpRequestMetrics.bytesLength = bytes;\n            };\n\n            req.onloadend = req.onerror = function() {\n                if (xhrs.indexOf(req) === -1) {\n                    return;\n                }\n                \n                xhrs.splice(xhrs.indexOf(req), 1);\n                \n                if (!needFailureReport) {\n                    return;\n                }\n                needFailureReport = false;\n\n                httpRequestMetrics.responsecode = req.status;\n\n                // When request failed do not complete http metrics so that\n                // DownloadRatioRule does not take into account these request\n                /*var currentTime = new Date(),\n                    bytes = req.response,\n                    latency,\n                    download;\n\n                if (!request.firstByteDate) {\n                    request.firstByteDate = request.requestStartDate;\n                }\n                request.requestEndDate = currentTime;\n\n                latency = (request.firstByteDate.getTime() - request.requestStartDate.getTime());\n                download = (request.requestEndDate.getTime() - request.firstByteDate.getTime());\n\n                httpRequestMetrics.tresponse = request.firstByteDate;\n                httpRequestMetrics.tfinish = request.requestEndDate;\n                httpRequestMetrics.responsecode = req.status;\n\n                self.metricsModel.appendHttpTrace(httpRequestMetrics,\n                    currentTime,\n                    currentTime.getTime() - lastTraceTime.getTime(), [bytes ? bytes.byteLength : 0]);\n                lastTraceTime = currentTime;*/\n\n                deferred.reject(req);\n            };\n\n            self.debug.log(\"[FragmentLoader][\"+type+\"] Load: \" + request.url);\n\n            req.send();\n            return deferred.promise;\n        },\n\n        _load = function (request, deferred) {\n            var self = this;\n\n            _loadRequest.call(self, request).then(function(result) {\n                    retryCount = 0;\n                    deferred.resolve(result);\n                }, function(reqerror) {\n                     if (reqerror.aborted) {\n                        // Request has been aborted => set status to 0\n                        request.status = 0;\n                        request.aborted = true;\n                        deferred.reject(request);\n                    } else if (retryCount >= retryAttempts) {\n                        // No (more) retry => set status and reject\n                        retryCount = 0;\n                        request.status = reqerror.status;\n                        deferred.reject(request);\n                    } else {\n                        // Retry\n                        setTimeout(function() {\n                            retryCount++;\n                            _load.call(self, request, deferred);\n                        }, retryInterval);\n                    }\n                });           \n\n        };\n\n    return {\n        metricsModel: undefined,\n        debug: undefined,\n        tokenAuthentication: undefined,\n        config: undefined,\n        notify: undefined,\n        subscribe: undefined,\n        unsubscribe: undefined,\n\n        setup: function() {\n            retryAttempts = this.config.getParam(\"FragmentLoader.RetryAttempts\", \"number\", DEFAULT_RETRY_ATTEMPTS);\n            retryInterval = this.config.getParam(\"FragmentLoader.RetryInterval\", \"number\", DEFAULT_RETRY_INTERVAL);\n        },\n\n        setType: function (value) {\n            type = value;\n        },\n\n        load: function(request) {\n            var deferred = Q.defer();\n\n            // MSS use case: if initialization segment and data already ready (automatically generated),\n            // then do not download segment\n            if (request.type === \"Initialization Segment\" && request.data) {\n                deferred.resolve(request, {data: request.data});\n            } else {\n                _load.call(this, request, deferred);\n            }\n\n            return deferred.promise;\n        },\n\n        abort: function() {\n            var i = 0;\n\n            for (i = 0; i < xhrs.length; i += 1) {\n                this.debug.log(\"[FragmentLoader][\"+type+\"] Abort XHR \" + (xhrs[i].responseURL ? xhrs[i].responseURL : \"\"));\n                xhrs[i].abort();\n            }\n        },\n\n        checkForExistence: function(req) {\n            if (!req) {\n                return Q.when(null);\n            }\n\n            req.deferred = Q.defer();\n            _checkForExistence.call(this, req);\n\n            return req.deferred.promise;\n        }\n    };\n};\n\nMediaPlayer.dependencies.FragmentLoader.prototype = {\n    constructor: MediaPlayer.dependencies.FragmentLoader\n};\n\nMediaPlayer.dependencies.FragmentLoader.eventList = {\n    ENAME_LOADING_PROGRESS: \"loadingProgress\"\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nMediaPlayer.dependencies.FragmentModel = function () {\n    \"use strict\";\n\n    var context,\n        executedRequests = [],\n        pendingRequests = [],\n        loadingRequests = [],\n        startLoadingCallback,\n        successLoadingCallback,\n        errorLoadingCallback,\n        streamEndCallback,\n        type,\n\n        LOADING_REQUEST_THRESHOLD = 2,\n\n        loadCurrentFragment = function(request) {\n            var onSuccess,\n                onError,\n                self = this;\n\n            // We are about to start loading the fragment, so execute the corresponding callback\n            startLoadingCallback.call(context, request);\n\n            onSuccess = function(request, response) {\n                loadingRequests.splice(loadingRequests.indexOf(request), 1);\n                executedRequests.push(request);\n                successLoadingCallback.call(context, request, response);\n                request.deferred = null;\n            };\n\n            onError = function(request) {\n                loadingRequests.splice(loadingRequests.indexOf(request), 1);\n                errorLoadingCallback.call(context, request);\n                request.deferred = null;\n            };\n\n            self.fragmentLoader.load(request).then(onSuccess.bind(context, request),\n                onError.bind(context, request));\n        },\n\n        sortRequestsByProperty = function(requestsArray, sortProp) {\n            var compare = function (req1, req2){\n                if (req1[sortProp] < req2[sortProp]) {\n                    return -1;\n                }\n                if (req1[sortProp] > req2[sortProp]){\n                    return 1;\n                }\n                return 0;\n            };\n\n            requestsArray.sort(compare);\n\n        },\n\n        removeExecutedRequest = function(request) {\n            var idx = executedRequests.indexOf(request);\n\n            if (idx !== -1) {\n                executedRequests.splice(idx, 1);\n            }\n        };\n\n    return {\n        system: undefined,\n        debug: undefined,\n        fragmentLoader: undefined,\n\n        setContext: function(value) {\n            context = value;\n        },\n\n        getContext: function() {\n            return context;\n        },\n\n        setType: function (value) {\n            type = value;\n            if (this.fragmentLoader) {\n                this.fragmentLoader.setType(value);\n            }\n        },\n\n        addRequest: function(value) {\n            if (value) {\n                if (this.isFragmentLoadedOrPending(value)) {\n                    return;\n                }\n\n                pendingRequests.push(value);\n                sortRequestsByProperty.call(this, pendingRequests, \"index\");\n            }\n        },\n\n        setCallbacks: function(onLoadingStart, onLoadingSuccess, onLoadingError, onStreamEnd) {\n            startLoadingCallback = onLoadingStart;\n            streamEndCallback = onStreamEnd;\n            errorLoadingCallback = onLoadingError;\n            successLoadingCallback = onLoadingSuccess;\n        },\n\n        isFragmentLoadedOrPending: function(request) {\n            var isLoaded = false,\n                i = 0,\n                req;\n\n            // First, check if the fragment has already been loaded\n            for (i = 0; i < executedRequests.length; i++) {\n                req = executedRequests[i];\n                if (request.startTime === req.startTime || ((req.action === \"complete\") && request.action === req.action)) {\n                    //self.debug.log(request.streamType + \" Fragment already loaded for time: \" + request.startTime);\n                    if (request.url === req.url) {\n                        //self.debug.log(request.streamType + \" Fragment url already loaded: \" + request.url);\n                        isLoaded = true;\n                        break;\n                    } else {\n                        // Remove overlapping segment of a different quality\n                        executedRequests.splice(i, 1);\n                        i--;\n                    }\n                }\n            }\n\n            // if it has not been loaded check if it is going to be loaded\n            if (!isLoaded) {\n                for (i = 0; i < pendingRequests.length; i++) {\n                    req = pendingRequests[i];\n                    if ((request.url === req.url) && (request.startTime === req.startTime)) {\n                        isLoaded = true;\n                    }\n                }\n            }\n\n            if (!isLoaded) {\n                for (i = 0; i < loadingRequests.length; i++) {\n                    req = loadingRequests[i];\n                    if ((request.url === req.url) && (request.startTime === req.startTime)) {\n                        isLoaded = true;\n                    }\n                }\n            }\n\n            return isLoaded;\n        },\n\n        isReady: function() {\n            return context.isReady();\n        },\n\n        getPendingRequests: function() {\n            return pendingRequests;\n        },\n\n        getLoadingRequests: function() {\n            return loadingRequests;\n        },\n\n        getLoadingTime: function() {\n            var loadingTime = 0,\n                req,\n                i;\n\n            // get the latest loaded request and calculate its loading time. In case requestEndDate/firstByteDate properties\n            // have not been set (e.g. for a request with action='complete') we should get the previous request.\n            for (i = executedRequests.length - 1; i >= 0; i -= 1) {\n                req = executedRequests[i];\n\n                if ((req.requestEndDate instanceof Date) && (req.firstByteDate instanceof Date)) {\n                    loadingTime = req.requestEndDate.getTime() - req.firstByteDate.getTime();\n                    break;\n                }\n            }\n\n            return loadingTime;\n        },\n\n        getExecutedRequestForTime: function(time) {\n            var lastIdx = executedRequests.length - 1,\n                start = NaN,\n                end = NaN,\n                req = null,\n                i;\n\n            // loop through the executed requests and pick the one for which the playback interval matches the given time\n            for (i = lastIdx; i >= 0; i -=1) {\n                req = executedRequests[i];\n                start = req.startTime;\n                end = start + req.duration;\n                if (!isNaN(start) && !isNaN(end) && (time > start) && (time < end)) {\n                    return req;\n                }\n            }\n\n            return null;\n        },\n\n        getExecutedRequestForQualityAndIndex: function(quality, index) {\n            var lastIdx = executedRequests.length - 1,\n                req = null,\n                i;\n\n            for (i = lastIdx; i >= 0; i -=1) {\n                req = executedRequests[i];\n                if (req.quality === quality && req.index === index) {\n                    return req;\n                }\n            }\n\n            return null;\n        },\n\n        removeExecutedRequest: function(request) {\n            removeExecutedRequest.call(this, request);\n        },\n\n        removeExecutedRequestsBeforeTime: function(time) {\n            var lastIdx = executedRequests.length - 1,\n                start = NaN,\n                req = null,\n                i;\n\n            // loop through the executed requests and remove the ones for which startTime is less than the given time\n            for (i = lastIdx; i >= 0; i -=1) {\n                req = executedRequests[i];\n                start = req.startTime;\n                if (!isNaN(start) && (start < time)) {\n                    removeExecutedRequest.call(this, req);\n                }\n            }\n        },\n\n        clearExecutedRequests: function() {\n            executedRequests = [];\n        },\n\n        cancelPendingRequests: function() {\n            pendingRequests = [];\n        },\n\n        abortRequests: function() {\n            this.fragmentLoader.abort();\n            loadingRequests = [];\n        },\n\n        executeCurrentRequest: function() {\n            var self = this,\n                currentRequest;\n\n            if (pendingRequests.length === 0) {\n                return;\n            }\n\n            if (loadingRequests.length >= LOADING_REQUEST_THRESHOLD) {\n                // too many requests have been loading, do nothing until some of them are loaded or aborted\n                return;\n            }\n\n            // take the next request to execute and remove it from the list of pending requests\n            currentRequest = pendingRequests.shift();\n\n            switch (currentRequest.action) {\n                case \"complete\":\n                    // Stream has completed, execute the correspoinding callback\n                    executedRequests.push(currentRequest);\n                    streamEndCallback.call(context, currentRequest);\n                    break;\n                case \"download\":\n                    loadingRequests.push(currentRequest);\n                    loadCurrentFragment.call(self, currentRequest);\n                    break;\n                default:\n                    this.debug.log(\"Unknown request action.\");\n                    if (currentRequest.deferred) {\n                        currentRequest.deferred.reject();\n                        currentRequest.deferred = null;\n                    } else {\n                        errorLoadingCallback.call(context, currentRequest);\n                    }\n            }\n        }\n    };\n};\n\nMediaPlayer.dependencies.FragmentModel.prototype = {\n    constructor: MediaPlayer.dependencies.FragmentModel\n};","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.dependencies.FragmentInfoController = function() {\n    \"use strict\";\n    var READY = \"READY\",\n        state = READY,\n        ready = false,\n        started = false,\n        fragmentModel = null,\n        type,\n        bufferTimeout,\n        _fragmentInfoTime,\n        _bufferController,\n        // ORANGE: segment download failed recovery\n        SEGMENT_DOWNLOAD_ERROR_MAX = 3,\n        segmentDownloadFailed = false,\n        segmentDownloadErrorCount = 0,\n        startFragmentInfoDate = null,\n        startTimeStampValue = null,\n        deltaTime = 0,\n\n        segmentDuration = NaN,\n\n        sendRequest = function() {\n            this.debug.info(\"[FragmentInfoController][\" + type + \"] sendRequest\");\n            // Check if running state\n            if (!isRunning.call(this)) {\n                return;\n            }\n\n            if (fragmentModel !== null) {\n                this.fragmentController.onBufferControllerStateChange();\n            }\n        },\n\n        startPlayback = function() {\n            if (!ready || !started) {\n                return;\n            }\n\n            startFragmentInfoDate = new Date().getTime();\n            startTimeStampValue = _fragmentInfoTime;\n\n            this.debug.info(\"[FragmentInfoController][\" + type + \"] startPlayback\");\n\n            // Start buffering process\n            bufferFragmentInfo.call(this);\n        },\n\n        doStart = function() {\n            var self = this,\n                segments;\n\n            if (started === true) {\n                return;\n            }\n\n            started = true;\n\n            self.debug.info(\"[FragmentInfoController][\" + type + \"] START\");\n\n            segments = _bufferController.getCurrentRepresentation().segments;\n            if (segments) {\n                _fragmentInfoTime = segments[segments.length - 1].presentationStartTime - segments[segments.length - 1].duration;\n\n                startPlayback.call(self);\n            } else {\n                self.indexHandler.updateSegmentList(_bufferController.getCurrentRepresentation()).then(function(segmentList) {\n                    segments = segmentList;\n                    _fragmentInfoTime = segments[segments.length - 1].presentationStartTime - segments[segments.length - 1].duration;\n\n                    startPlayback.call(self);\n                });\n            }\n        },\n\n        doStop = function() {\n            if (!started) {\n                return;\n            }\n            this.debug.info(\"[FragmentInfoController][\" + type + \"] STOP\");\n\n            // Stop buffering process\n            clearTimeout(bufferTimeout);\n            started = false;\n\n            startFragmentInfoDate = null;\n            startTimeStampValue = null;\n\n            this.fragmentController.abortRequestsForModel(fragmentModel);\n        },\n\n        onBytesLoadingStart = function(request) {\n            this.debug.info(\"[FragmentInfoController][\" + type + \"] Load request \", (request.url !== null) ? request.url : request.quality);\n        },\n\n        onBytesLoaded = function(request, response) {\n            var self = this,\n                deltaDate,\n                deltaTimeStamp;\n\n            segmentDuration = request.duration;\n\n            // Reset segment download error status\n            segmentDownloadFailed = false;\n            segmentDownloadErrorCount = 0;\n\n            this.debug.log(\"[FragmentInfoController][\" + type + \"] FragmentInfo loaded \", request.url);\n\n            try {\n                this.fragmentController.process(response.data, request, _bufferController.getCurrentRepresentation()).then(function(/*data*/) {\n                    deltaDate = (new Date().getTime() - startFragmentInfoDate) / 1000;\n                    deltaTimeStamp = (_fragmentInfoTime + segmentDuration) - startTimeStampValue;\n                    deltaTime = (deltaTimeStamp - deltaDate) > 0 ? (deltaTimeStamp - deltaDate) : 0;\n                    delayLoadNextFragmentInfo.call(self, deltaTime);\n                });\n            } catch (e) {\n                this.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.INTERNAL_ERROR, \"Internal error while processing fragment info segment\", e.message);\n            }\n        },\n\n        isRunning = function() {\n            return started;\n        },\n\n        onBytesError = function(e) {\n            if (!isRunning.call(this)) {\n                return;\n            }\n\n            // Abandonned request => load segment at lowest quality\n            if (e.aborted) {\n                bufferFragmentInfo.call(this);\n                return;\n            }\n\n            // Segment download failed\n            segmentDownloadErrorCount += 1;\n\n            // => If failed SEGMENT_DOWNLOAD_ERROR_MAX times, then raise a warning\n            // => Else raise a warning and try to reload session\n            if (segmentDownloadErrorCount === SEGMENT_DOWNLOAD_ERROR_MAX) {\n                this.errHandler.sendWarning(MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_CONTENT,\n                    \"Failed to download fragmentInfo segment\", {\n                        url: e.url,\n                        status: e.status\n                    });\n            } else {\n                this.errHandler.sendWarning(MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_CONTENT,\n                    \"Failed to download fragmentInfo segment\", {\n                        url: e.url,\n                        status: e.status\n                    });\n            }\n        },\n\n        onFragmentRequest = function(request) {\n            var self = this;\n\n            // Check if current request signals end of stream\n            if ((request !== null) && (request.action === request.ACTION_COMPLETE)) {\n                doStop.call(self);\n                return;\n            }\n\n            if (request !== null) {\n                _fragmentInfoTime = request.startTime + request.duration;\n                request = self.indexHandler.getFragmentInfoRequest(request);\n\n                if (self.fragmentController.isFragmentLoadedOrPending(self, request)) {\n                    self.indexHandler.getNextSegmentRequest(_bufferController.getCurrentRepresentation()).then(onFragmentRequest.bind(self));\n                    return;\n                }\n\n                self.debug.log(\"[FragmentInfoController][\" + type + \"] onFragmentRequest \" + request.url);\n\n                // Download the fragment info segment\n                self.fragmentController.prepareFragmentForLoading(self, request, onBytesLoadingStart, onBytesLoaded, onBytesError, null);\n                sendRequest.call(self);\n            } else {\n                // No more fragment in current list\n                self.debug.log(\"[FragmentInfoController][\" + type + \"] bufferFragmentInfo failed\");\n            }\n        },\n\n        delayLoadNextFragmentInfo = function(delay) {\n            var self = this,\n                delayMs = Math.round(Math.min((delay * 1000), 2000));\n\n            self.debug.log(\"[FragmentInfoController][\" + type + \"] Check buffer delta = \" + delayMs + \" ms\");\n\n            clearTimeout(bufferTimeout);\n            bufferTimeout = setTimeout(function() {\n                bufferTimeout = null;\n                bufferFragmentInfo.call(self);\n            }, delayMs);\n        },\n\n        bufferFragmentInfo = function() {\n            var self = this,\n                segmentTime;\n\n            // Check if running state\n            if (!isRunning.call(self)) {\n                return;\n            }\n\n            self.debug.log(\"[FragmentInfoController][\" + type + \"] Start buffering process...\");\n\n            // Get next segment time\n            segmentTime = _fragmentInfoTime;\n\n            self.debug.log(\"[FragmentInfoController][\" + type + \"] loadNextFragment for time: \" + segmentTime);\n\n            this.indexHandler.getSegmentRequestForTime(_bufferController.getCurrentRepresentation(), segmentTime).then(onFragmentRequest.bind(this));\n        };\n\n    return {\n        sourceBufferExt: undefined,\n        abrController: undefined,\n        debug: undefined,\n        system: undefined,\n        errHandler: undefined,\n        abrRulesCollection: undefined,\n        indexHandler: undefined,\n\n        initialize: function(type, fragmentController, bufferController) {\n            var self = this;\n\n            self.debug.log(\"[FragmentInfoController][\" + type + \"] Initialize\");\n\n            _bufferController = bufferController;\n\n            self.setType(type);\n            self.setFragmentController(fragmentController);\n\n            ready = true;\n        },\n\n        setType: function(value) {\n            type = value;\n\n            if (this.indexHandler !== undefined) {\n                this.indexHandler.setType(value);\n                this.indexHandler.setIsDynamic(true);\n            }\n        },\n\n        isReady: function() {\n            return state === READY;\n        },\n\n        setFragmentController: function(value) {\n            if (value) {\n                this.fragmentController = value;\n                fragmentModel = this.fragmentController.attachBufferController(this);\n                fragmentModel.setType(type);\n            }\n        },\n\n        reset: function() {\n            var self = this;\n\n            doStop.call(self);\n\n            if (fragmentModel) {\n                self.fragmentController.abortRequestsForModel(fragmentModel);\n                self.fragmentController.detachBufferController(fragmentModel);\n                fragmentModel = null;\n            }\n\n            return Q.when(null);\n        },\n\n        start: doStart,\n        stop: doStop\n    };\n};\n\nMediaPlayer.dependencies.FragmentInfoController.prototype = {\n    constructor: MediaPlayer.dependencies.FragmentInfoController\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.dependencies.ManifestLoader = function() {\n    \"use strict\";\n\n    var DEFAULT_RETRY_ATTEMPTS = 2,\n        DEFAULT_RETRY_INTERVAL = 500,\n        _retryAttempts = DEFAULT_RETRY_ATTEMPTS,\n        _retryInterval = DEFAULT_RETRY_INTERVAL,\n        _xhrLoader = null,\n\n        _getDecodedResponseText = function(text) {\n            var fixedCharCodes = '',\n                i = 0,\n                charCode;\n\n            // Some content is not always successfully decoded by every browser.\n            // Known problem case: UTF-16 BE manifests on Internet Explorer 11.\n            // This function decodes any text that the browser failed to decode.\n            if (text.length < 1) {\n                return text;\n            }\n\n            // The troublesome bit here is that IE still strips off the BOM, despite incorrectly decoding the file.\n            // So we will simply assume that the first character is < (0x3C) and detect its invalid decoding (0x3C00).\n            if (text.charCodeAt(0) !== 0x3C00) {\n                return text;\n            }\n\n            // We have a problem!\n            for (i = 0; i < text.length; i += 1) {\n                charCode = text.charCodeAt(i);\n\n                // Swap around the two bytes that make up the character code.\n                fixedCharCodes += String.fromCharCode(((charCode & 0xFF) << 8 | (charCode & 0xFF00) >> 8));\n            }\n\n            return fixedCharCodes;\n        },\n\n        _parseBaseUrl = function(url) {\n            var base = null;\n\n            if (url.indexOf(\"/\") !== -1) {\n                if (url.indexOf(\"?\") !== -1) {\n                    url = url.substring(0, url.indexOf(\"?\"));\n                }\n                base = url.substring(0, url.lastIndexOf(\"/\") + 1);\n            }\n\n            return base;\n        },\n\n        _abort = function() {\n\n            if (_xhrLoader !== null) {\n                _xhrLoader.abort();\n            }\n\n            this.parser.abort();\n        },\n\n        _load = function(url) {\n            var baseUrl = _parseBaseUrl(url),\n                deferred = Q.defer(),\n                self = this;\n\n            _xhrLoader = new MediaPlayer.dependencies.XHRLoader();\n            _xhrLoader.initialize(null, _retryAttempts, _retryInterval);\n            _xhrLoader.load(url).then(\n                function (request) {\n\n                    // Get the redirection URL and use it as base URL for subsequent requests\n                    if (request.responseURL) {\n                        self.debug.log(\"[ManifestLoader] Redirect URL: \" + request.responseURL);\n                        baseUrl = _parseBaseUrl(request.responseURL);\n                    }\n\n                    self.tokenAuthentication.checkRequestHeaderForToken(request);\n                    self.metricsModel.addHttpRequest(\"stream\",\n                        null,\n                        \"MPD\",\n                        url,\n                        null,\n                        null,\n                        request.startDate,\n                        request.endDate,\n                        request.status,\n                        null,\n                        null);\n\n                    self.parser.parse(_getDecodedResponseText(request.responseText), baseUrl).then(\n                        function(manifest) {\n                            if (manifest) {\n                                manifest.mpdUrl = url;\n                                manifest.mpdLoadedTime = request.endDate;\n                                self.metricsModel.addManifestUpdate(\"stream\", manifest.type, request.startDate, request.endDate, manifest.availabilityStartTime);\n                                deferred.resolve(manifest);\n                            } else {\n                                deferred.reject();\n                            }\n                        },\n                        function(error) {\n                            // Check if reject is due to other issue than manifest parsing\n                            // (for example HLS variant steam playlist download error)\n                            if (error && error.name && error.message) {\n                                deferred.reject(error);\n                            } else {\n                                self.debug.error(\"[ManifestLoader] Manifest parsing error\");\n                                deferred.reject({\n                                    name: MediaPlayer.dependencies.ErrorHandler.prototype.MANIFEST_ERR_PARSE,\n                                    message: \"Failed to parse manifest\",\n                                    data: {\n                                        url: url\n                                    }\n                                });\n                            }\n                        }\n                    );\n                },\n                function(request) {\n\n                    if (!request || request.aborted) {\n                        deferred.reject();\n                    } else {\n\n                        self.metricsModel.addHttpRequest(\"stream\",\n                            null,\n                            \"MPD\",\n                            url,\n                            null,\n                            null,\n                            request.startDate,\n                            request.endDate,\n                            request.status,\n                            null,\n                            null);\n\n                        deferred.reject({\n                            name: MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_MANIFEST,\n                            message: \"Failed to download manifest\",\n                            data : {\n                                url: url,\n                                status: request.status\n                            }\n                        });\n                    }\n                }\n            );\n\n            return deferred.promise;\n        };\n\n    return {\n        debug: undefined,\n        parser: undefined,\n        config: undefined,\n        metricsModel: undefined,\n        tokenAuthentication: undefined,\n\n        setup: function() {\n            _retryAttempts = this.config.getParam(\"ManifestLoader.RetryAttempts\", \"number\", DEFAULT_RETRY_ATTEMPTS);\n            _retryInterval = this.config.getParam(\"ManifestLoader.RetryInterval\", \"number\", DEFAULT_RETRY_INTERVAL);\n        },\n\n        load: _load,\n\n        abort: _abort\n    };\n};\n\nMediaPlayer.dependencies.ManifestLoader.prototype = {\n    constructor: MediaPlayer.dependencies.ManifestLoader\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.dependencies.ManifestUpdater = function() {\n    \"use strict\";\n\n    var refreshDelay = NaN,\n        refreshTimer = null,\n        isStopped = false,\n        deferredUpdate,\n\n        clear = function() {\n            if (refreshTimer !== null) {\n                clearInterval(refreshTimer);\n                refreshTimer = null;\n            }\n        },\n\n        start = function() {\n            clear.call(this);\n\n            if (!isNaN(refreshDelay)) {\n                this.debug.log(\"Refresh manifest in \" + refreshDelay + \" seconds.\");\n                refreshTimer = setTimeout(onRefreshTimer.bind(this), Math.min(refreshDelay * 1000, Math.pow(2, 31) - 1), this);\n            }\n        },\n\n        update = function() {\n            var self = this,\n                manifest = self.manifestModel.getValue(),\n                timeSinceLastUpdate, \n                t;\n\n            if (manifest !== undefined && manifest !== null) {\n                t = self.manifestExt.getRefreshDelay(manifest);\n                timeSinceLastUpdate = (new Date().getTime() - manifest.mpdLoadedTime.getTime()) / 1000;\n                refreshDelay = Math.max(t - timeSinceLastUpdate, 0);\n                start.call(self);\n            }\n        },\n\n        onRefreshTimer = function() {\n            var self = this,\n                manifest,\n                url;\n\n            // The manifest should not update until the previous update has completed. A promise postpones the update\n            // until is is resolved. For the first time the promise does not exist yet, so pass 'true' instead.\n            Q.when(deferredUpdate ? deferredUpdate.promise : true).then(\n                function() {\n                    deferredUpdate = Q.defer();\n                    manifest = self.manifestModel.getValue();\n                    url = manifest.mpdUrl;\n\n                    if (manifest.hasOwnProperty(\"Location\")) {\n                        url = manifest.Location;\n                    }\n\n                    //self.debug.log(\"Refresh manifest @ \" + url);\n\n                    self.manifestLoader.load(url).then(\n                        function(manifestResult) {\n                            self.manifestModel.setValue(manifestResult);\n                            self.debug.log(\"Manifest has been refreshed.\");\n                            //self.debug.log(manifestResult);\n                            if (isStopped) {\n                                return;\n                            }\n\n                            update.call(self);\n                        }\n                    );\n                }\n            );\n        },\n\n        onStreamsComposed = function() {\n            // When streams are ready we can consider manifest update completed. Resolve the update promise.\n            if (deferredUpdate) {\n                deferredUpdate.resolve();\n            }\n        };\n\n    return {\n        debug: undefined,\n        system: undefined,\n        manifestModel: undefined,\n        manifestExt: undefined,\n        manifestLoader: undefined,\n\n        setup: function() {\n            update.call(this);\n            // Listen to streamsComposed event to be aware that the streams have been composed\n            this.system.mapHandler(\"streamsComposed\", undefined, onStreamsComposed.bind(this));\n        },\n\n        start: function() {\n            isStopped = false;\n            update.call(this);\n        },\n\n        stop: function() {\n            isStopped = true;\n            clear.call(this);\n        }\n    };\n};\n\nMediaPlayer.dependencies.ManifestUpdater.prototype = {\n    constructor: MediaPlayer.dependencies.ManifestUpdater\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.models.ManifestModel = function () {\n    \"use strict\";\n\n    var manifest = null;\n\n    return {\n        system: undefined,\n        eventBus: undefined,\n\n        getValue:  function () {\n            return manifest;\n        },\n\n        setValue: function (value) {\n            manifest = value;\n            if (manifest) {\n                this.system.notify(\"manifestUpdated\");\n            }\n\n            if (manifest !== null) {\n                this.eventBus.dispatchEvent({\n                    type: \"manifestLoaded\",\n                    data: value\n                });\n            }\n        }\n    };\n};\n\nMediaPlayer.models.ManifestModel.prototype = {\n    constructor: MediaPlayer.models.ManifestModel\n};\n\n\n\n\n","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.dependencies.MediaSourceExtensions = function () {\n    \"use strict\";\n};\n\nMediaPlayer.dependencies.MediaSourceExtensions.prototype = {\n    constructor: MediaPlayer.dependencies.MediaSourceExtensions,\n\n    createMediaSource: function () {\n        \"use strict\";\n\n        var hasWebKit = (\"WebKitMediaSource\" in window),\n            hasMediaSource = (\"MediaSource\" in window);\n\n        if (hasMediaSource) {\n            return new MediaSource();\n        } else if (hasWebKit) {\n            return new WebKitMediaSource();\n        }\n\n        return null;\n    },\n\n    attachMediaSource: function (source, videoModel) {\n        \"use strict\";\n\n        videoModel.setSource(window.URL.createObjectURL(source));\n        return true;\n    },\n\n    detachMediaSource: function (videoModel) {\n        \"use strict\";\n        videoModel.setSource(null);\n        return true;\n    },\n\n    setDuration: function (source, value) {\n        \"use strict\";\n        var i,\n            updating = false;\n\n        if (source.readyState !== 'open') return source.duration;\n\n        for (i = 0; i < source.sourceBuffers.length; i++) {\n            if(source.sourceBuffers[i].updating){\n                updating = true;\n                break;\n            }\n        }\n\n        if (!updating) {\n            source.duration = value;\n        }\n\n        return source.duration;\n    },\n\n    signalEndOfStream: function(source) {\n        \"use strict\";\n        var buffers = source.sourceBuffers,\n            ln = buffers.length,\n            i = 0;\n\n        if (source.readyState !== 'open') {\n            return;\n        }\n\n        for (i; i < ln; i++) {\n            if (buffers[i].updating) {\n                return;\n            }\n            if (buffers[i].buffered.length === 0) {\n                return;\n            }\n        }\n\n        source.endOfStream();\n        return true;\n    }\n};","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.dependencies.MetricsExtensions = function() {\n    \"use strict\";\n\n    var h264ProfileMap = {\n        \"42\": \"Baseline\",\n        \"4D\": \"Main\",\n        \"58\": \"Extended\",\n        \"64\": \"High\"\n    };\n\n    var findRepresentionInPeriodArray = function(periodArray, representationId) {\n        var period,\n            adaptationSet,\n            adaptationSetArray,\n            representation,\n            representationArray,\n            periodArrayIndex,\n            adaptationSetArrayIndex,\n            representationArrayIndex;\n\n        for (periodArrayIndex = 0; periodArrayIndex < periodArray.length; periodArrayIndex = periodArrayIndex + 1) {\n            period = periodArray[periodArrayIndex];\n            adaptationSetArray = period.AdaptationSet_asArray;\n            for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex < adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) {\n                adaptationSet = adaptationSetArray[adaptationSetArrayIndex];\n                representationArray = adaptationSet.Representation_asArray;\n                for (representationArrayIndex = 0; representationArrayIndex < representationArray.length; representationArrayIndex = representationArrayIndex + 1) {\n                    representation = representationArray[representationArrayIndex];\n                    if (representationId === representation.id) {\n                        return representation;\n                    }\n                }\n            }\n        }\n\n        return null;\n    };\n\n    var adaptationIsType = function(adaptation, bufferType) {\n        var found = false;\n        // TODO : HACK ATTACK\n        // Below we call getIsVideo and getIsAudio and then check the adaptation set for a 'type' property.\n        // getIsVideo and getIsAudio are adding this 'type' property and SHOULD NOT BE.\n        // This method expects getIsVideo and getIsAudio to be sync, but they are async (returns a promise).\n        // This is a bad workaround!\n        // The metrics extensions should have every method use promises.\n\n        if (bufferType === \"video\") {\n            this.manifestExt.getIsVideo(adaptation);\n            if (adaptation.type === \"video\") {\n                found = true;\n            }\n        } else if (bufferType === \"audio\") {\n            this.manifestExt.getIsAudio(adaptation);\n            if (adaptation.type === \"audio\") {\n                found = true;\n            }\n        } else if (bufferType === \"text\") {\n            this.manifestExt.getIsText(adaptation);\n            if (adaptation.type === \"text\") {\n                found = true;\n            }\n        } else {\n            found = false;\n        }\n\n        return found;\n    };\n\n    var rslt = MediaPlayer.utils.copyMethods(Dash.dependencies.DashMetricsExtensions);\n\n    rslt.config = undefined;\n\n    rslt.getDuration = function() {\n        var self = this,\n            manifest = self.manifestModel.getValue(),\n            duration = manifest ? manifest.Period.duration : null;\n\n        if (duration !== Infinity) {\n            return duration;\n        }\n\n        return -1;\n    };\n\n    rslt.getFormatForType = function(type) {\n        var self = this,\n            manifest = self.manifestModel.getValue(),\n            i = 0,\n            adaptation;\n\n        for (i = 0; i < manifest.Period.AdaptationSet.length; i++) {\n            adaptation = manifest.Period.AdaptationSet[i];\n            if (adaptation.type === type) {\n                return adaptation.mimeType;\n            }\n        }\n\n        return null;\n    };\n\n    rslt.getCodecForType = function(type) {\n        var self = this,\n            manifest = self.manifestModel.getValue(),\n            i = 0,\n            adaptation;\n\n        for (i = 0; i < manifest.Period.AdaptationSet.length; i++) {\n            adaptation = manifest.Period.AdaptationSet[i];\n            if (adaptation.type === type || adaptation.contentType === type) {\n                //return codecs of the first Representation\n                return adaptation.Representation_asArray[0].codecs;\n            }\n        }\n\n        return null;\n    };\n\n    rslt.getVideoWidthForRepresentation = function(representationId) {\n        var self = this,\n            manifest = self.manifestModel.getValue(),\n            representation,\n            periodArray;\n\n        if (manifest) {\n            periodArray = manifest.Period_asArray;\n\n            representation = findRepresentionInPeriodArray.call(self, periodArray, representationId);\n\n            if (representation === null) {\n                return null;\n            }\n\n            return representation.width;\n        } else {\n            return null;\n        }\n    };\n\n    rslt.getVideoHeightForRepresentation = function(representationId) {\n        var self = this,\n            manifest = self.manifestModel.getValue(),\n            representation,\n            periodArray;\n\n        if (manifest) {\n            periodArray = manifest.Period_asArray;\n\n            representation = findRepresentionInPeriodArray.call(self, periodArray, representationId);\n\n            if (representation === null) {\n                return null;\n            }\n\n            return representation.height;\n        } else {\n            return null;\n        }\n    };\n\n    rslt.getCodecsForRepresentation = function(representationId) {\n        var self = this,\n            manifest = self.manifestModel.getValue(),\n            representation,\n            periodArray = manifest.Period_asArray;\n\n        representation = findRepresentionInPeriodArray.call(self, periodArray, representationId);\n\n        if (representation === null) {\n            return null;\n        }\n\n        return representation.codecs;\n    };\n\n    rslt.getH264ProfileLevel = function(codecs) {\n\n        if (codecs.indexOf(\"avc1\") < 0) {\n            return \"\";\n        }\n        var profile = h264ProfileMap[codecs.substr(5, 2)],\n            level = parseInt(codecs.substr(9, 2), 16) / 10.0;\n\n        return profile + \"@\" + level.toString();\n    };\n\n    rslt.getBitratesForType = function(type, data) {\n        var self = this,\n            manifest = self.manifestModel.getValue(),\n            periodArray,\n            period,\n            periodArrayIndex,\n            adaptationSetArray,\n            adaptationSet = null,\n            representation,\n            representationArray,\n            adaptationSetArrayIndex,\n            representationArrayIndex,\n            bitrateArray = [];\n\n        if (((manifest === null) || (manifest === undefined)) && ((data === null) || (data === undefined))) {\n            return null;\n        }\n\n        if (data) {\n            adaptationSet = data;\n        } else {\n            periodArray = manifest.Period_asArray;\n\n            for (periodArrayIndex = 0; periodArrayIndex < periodArray.length; periodArrayIndex = periodArrayIndex + 1) {\n                period = periodArray[periodArrayIndex];\n                adaptationSetArray = period.AdaptationSet_asArray;\n                for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex < adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) {\n                    adaptationSet = adaptationSetArray[adaptationSetArrayIndex];\n                    if (adaptationIsType.call(self, adaptationSetArray[adaptationSetArrayIndex], type)) {\n                        adaptationSet = adaptationSetArray[adaptationSetArrayIndex];\n                        break;\n                    }\n                }\n            }\n        }\n\n        if (adaptationSet !== null) {\n            // Order adaptationSet's representations in bitrate ascending value\n            adaptationSet = self.manifestExt.processAdaptation(adaptationSet);\n            representationArray = adaptationSet.Representation_asArray;\n            for (representationArrayIndex = 0; representationArrayIndex < representationArray.length; representationArrayIndex = representationArrayIndex + 1) {\n                representation = representationArray[representationArrayIndex];\n                bitrateArray.push(representation.bandwidth);\n            }\n        }\n\n        return bitrateArray;\n    };\n\n    rslt.getBitratesWithResolutionForType = function(type) {\n        var self = this,\n            manifest = self.manifestModel.getValue(),\n            periodArray,\n            period,\n            periodArrayIndex,\n            adaptationSet,\n            adaptationSetArray,\n            representation,\n            representationArray,\n            adaptationSetArrayIndex,\n            representationArrayIndex,\n            bitrateArray = [];\n\n        if ((manifest === null) || (manifest === undefined)) {\n            return null;\n        }\n\n        periodArray = manifest.Period_asArray;\n\n        for (periodArrayIndex = 0; periodArrayIndex < periodArray.length; periodArrayIndex = periodArrayIndex + 1) {\n            period = periodArray[periodArrayIndex];\n            adaptationSetArray = period.AdaptationSet_asArray;\n            for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex < adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) {\n                adaptationSet = adaptationSetArray[adaptationSetArrayIndex];\n                if (adaptationIsType.call(self, adaptationSet, type)) {\n                    //order adaptation in bitrate ascending value\n                    adaptationSet = self.manifestExt.processAdaptation(adaptationSet);\n                    representationArray = adaptationSet.Representation_asArray;\n                    for (representationArrayIndex = 0; representationArrayIndex < representationArray.length; representationArrayIndex = representationArrayIndex + 1) {\n                        representation = representationArray[representationArrayIndex];\n                        var reso = {\n                            bitrate: representation.bandwidth,\n                            width: representation.width,\n                            height: representation.height\n                        };\n                        bitrateArray.push(reso);\n                    }\n                    return bitrateArray;\n                }\n            }\n        }\n\n        return bitrateArray;\n    };\n\n    return rslt;\n};\n\nMediaPlayer.dependencies.MetricsExtensions.prototype = {\n    constructor: MediaPlayer.dependencies.MetricsExtensions\n};\n","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n MediaPlayer.models.MetricsModel = function () {\n    \"use strict\";\n\n    return {\n        system : undefined,\n        eventBus: undefined,\n        config: undefined,\n        streamMetrics: {},\n        metricsChanged: function () {\n            this.eventBus.dispatchEvent({\n                type: \"metricsChanged\",\n                data: {}\n            });\n        },\n\n        metricChanged: function (streamType) {\n            this.eventBus.dispatchEvent({\n                type: \"metricChanged\",\n                data: {stream: streamType}\n            });\n            this.metricsChanged();\n        },\n\n        metricUpdated: function (streamType, metricType, vo) {\n            this.eventBus.dispatchEvent({\n                type: \"metricUpdated\",\n                data: {stream: streamType, metric: metricType, value: vo}\n            });\n            this.metricChanged(streamType);\n        },\n\n        metricAdded: function (streamType, metricType, vo) {\n            this.eventBus.dispatchEvent({\n                type: \"metricAdded\",\n                data: {stream: streamType, metric: metricType, value: vo}\n            });\n            this.metricChanged(streamType);\n        },\n\n        clearCurrentMetricsForType: function (type) {\n            var keepBW = this.config.getParamFor(type, \"ABR.keepBandwidthCondition\", \"boolean\", true);\n\n            for (var prop in this.streamMetrics[type]) {\n                // We keep HttpList in order to keep bandwidth conditions when switching the input stream\n                if (this.streamMetrics[type].hasOwnProperty(prop) && ((prop !== \"HttpList\") || (keepBW === false))) {\n                    this.streamMetrics[type][prop] = [];\n                }\n            }\n\n            this.metricChanged(type);\n        },\n\n        clearAllCurrentMetrics: function () {\n            var self = this;\n\n            for (var prop in this.streamMetrics) {\n                if (this.streamMetrics.hasOwnProperty(prop) && (prop === \"stream\")) {\n                    delete this.streamMetrics[prop];\n                }\n            }\n\n            //this.streamMetrics = {};\n            this.metricsChanged.call(self);\n        },\n\n        getReadOnlyMetricsFor: function(type) {\n            if (this.streamMetrics.hasOwnProperty(type)) {\n                return this.streamMetrics[type];\n            }\n\n            return null;\n        },\n\n        getMetricsFor: function(type) {\n            var metrics;\n\n            if (this.streamMetrics.hasOwnProperty(type)) {\n                metrics = this.streamMetrics[type];\n            } else {\n                metrics = this.system.getObject(\"metrics\");\n                this.streamMetrics[type] = metrics;\n            }\n\n            return metrics;\n        },\n\n        addTcpConnection: function (streamType, tcpid, dest, topen, tclose, tconnect) {\n            var vo = new MediaPlayer.vo.metrics.TCPConnection();\n\n            vo.tcpid = tcpid;\n            vo.dest = dest;\n            vo.topen = topen;\n            vo.tclose = tclose;\n            vo.tconnect = tconnect;\n\n            this.getMetricsFor(streamType).TcpList.push(vo);\n            this.metricAdded(streamType, \"TcpConnection\", vo);\n\n            return vo;\n        },\n\n        // ORANGE: add request quality\n        addHttpRequest: function (streamType, tcpid, type, url, actualurl, range, trequest, tresponse, tfinish, responsecode, interval, mediaduration, startTime, quality) {\n            var vo = new MediaPlayer.vo.metrics.HTTPRequest(),\n                metrics = this.getMetricsFor(streamType).HttpList;\n\n            vo.stream = streamType;\n            vo.tcpid = tcpid;\n            vo.type = type;\n            vo.url = url;\n            vo.actualurl = actualurl;\n            vo.range = range;\n            vo.trequest = trequest;\n            vo.tresponse = tresponse;\n            vo.tfinish = tfinish;\n            vo.responsecode = responsecode;\n            vo.interval = interval;\n            vo.mediaduration = mediaduration;\n            vo.startTime = startTime;\n            vo.quality = quality;\n\n            metrics.push(vo);\n            this.metricAdded(streamType, \"HttpRequest\", vo);\n\n            // Keep only last 10 metrics to avoid memory leak\n            if (metrics.length > 10) {\n                metrics.shift();\n            }\n\n            return vo;\n        },\n\n        appendHttpTrace: function (httpRequest, s, d, b) {\n            var vo = new MediaPlayer.vo.metrics.HTTPRequest.Trace();\n\n            vo.s = s;\n            vo.d = d;\n            vo.b = b;\n\n            httpRequest.trace.push(vo);\n            this.metricUpdated(httpRequest.stream, \"HttpRequestTrace\", httpRequest);\n\n            return vo;\n        },\n\n        addRepresentationSwitch: function (streamType, t, mt, to, lto) {\n            var vo = new MediaPlayer.vo.metrics.RepresentationSwitch();\n\n            vo.t = t;\n            vo.mt = mt;\n            vo.to = to;\n            vo.lto = lto;\n\n            this.getMetricsFor(streamType).RepSwitchList.push(vo);\n            this.metricAdded(streamType, \"RepresentationSwitch\", vo);\n\n            return vo;\n        },\n\n        addBufferedSwitch: function (streamType, mt, to, lto) {\n            var vo = new MediaPlayer.vo.metrics.BufferedSwitch();\n\n            vo.mt = mt;\n            vo.to = to;\n            vo.lto = lto;\n\n            this.getMetricsFor(streamType).BufferedSwitchList.push(vo);\n            this.metricAdded(streamType, \"BufferedSwitch\", vo);\n\n            return vo;\n        },\n\n        addState: function (streamType, currentState, position, reason) {\n\n            var state = this.getMetricsFor(streamType).State;\n            if (state.length > 0 && state[state.length - 1].current === currentState) {\n                return;\n            }\n\n            var vo = new MediaPlayer.vo.metrics.State(),\n                metrics = this.getMetricsFor(streamType).State;\n\n            vo.current = currentState;\n            vo.position = position;\n            vo.reason = reason;\n\n            metrics.push(vo);\n            this.metricAdded(streamType, \"State\", vo);\n\n            // console.log(\"[STATE] type: \" + streamType + \", state:\" + currentState + \", position: \" + position);\n\n            // Keep only last 10 metrics to avoid memory leak\n            if (metrics.length > 10) {\n                metrics.shift();\n            }\n\n            return vo;\n        },\n\n        addSession: function (streamType, url, loop, endTime, playerType) {\n            var vo = new MediaPlayer.vo.metrics.Session();\n\n            vo.uri = url;\n            if (loop) {\n                vo.loopMode = 1;\n            } else {\n                vo.loopMode = 0;\n            }\n            vo.endTime = endTime;\n            vo.playerType = playerType;\n\n            this.metricAdded(streamType, \"Session\", vo);\n\n            return vo;\n        },\n\n        addCondition: function (streamType, isFullScreen, videoWidth, videoHeight, droppedFrames, fps) {\n            var vo = new MediaPlayer.vo.metrics.Condition();\n\n            vo.isFullScreen = isFullScreen;\n            vo.windowSize = videoWidth + \"x\" + videoHeight;\n            vo.fps = fps;\n            vo.droppedFrames = droppedFrames;\n\n            this.metricAdded(streamType, \"Condition\", vo);\n\n            return vo;\n        },\n\n        addMetaData: function () {\n            this.metricAdded(null, \"ManifestReady\", null);\n        },\n\n        addBufferLevel: function (streamType, t, level) {\n            var vo = new MediaPlayer.vo.metrics.BufferLevel(),\n                metrics = this.getMetricsFor(streamType).BufferLevel;\n\n            vo.t = t;\n            vo.level = Number(level.toFixed(3));\n\n            metrics.push(vo);\n            this.metricAdded(streamType, \"BufferLevel\", vo);\n\n            // Keep only last 10 metrics to avoid memory leak\n            if (metrics.length > 10) {\n                metrics.shift();\n            }\n\n            return vo;\n        },\n\n\n        addDVRInfo: function (streamType, t, range) {\n            var vo = new MediaPlayer.vo.metrics.DVRInfo(),\n                metrics = this.getMetricsFor(streamType).DVRInfo;\n\n            vo.t = t;\n            vo.range = range;\n\n            metrics.push(vo);\n            this.metricAdded(streamType, \"DVRInfo\", vo);\n\n            // Keep only last 10 metrics to avoid memory leak\n            if (metrics.length > 10) {\n                metrics.shift();\n            }\n\n            return vo;\n        },\n\n        addDroppedFrames: function (streamType, quality) {\n            var vo = new MediaPlayer.vo.metrics.DroppedFrames(),\n                list = this.getMetricsFor(streamType).DroppedFrames;\n\n            vo.time = quality.creationTime;\n            vo.droppedFrames = quality.droppedVideoFrames;\n            vo.decodedFrameCount = quality.totalVideoFrames;\n\n            if (list.length > 0 && list[list.length - 1] === vo) {\n                return list[list.length - 1];\n            }\n\n            list.push(vo);\n\n            this.metricAdded(streamType, \"DroppedFrames\", vo);\n            return vo;\n        },\n\n\n        addPlaybackQuality: function (streamType, t, quality, mediaTime) {\n            var vo = new MediaPlayer.vo.metrics.PlaybackQuality(),\n                metrics = this.getMetricsFor(streamType).PlaybackQuality;\n\n            vo.t = t;//quality.creationTime;\n            vo.mt = mediaTime;\n            vo.droppedFrames = quality.droppedVideoFrames;\n            vo.totalVideoFrames = quality.totalVideoFrames;\n\n            // Add new metrics only if droppedVideoFrames or totalVideoFrames changed\n            if (metrics.length > 0) {\n                if ((vo.droppedFrames === metrics[metrics.length-1].droppedFrames) &&\n                    (vo.totalVideoFrames === metrics[metrics.length-1].totalVideoFrames)) {\n                    return metrics[metrics.length - 1];\n                }\n            }\n\n            metrics.push(vo);\n            this.metricAdded(streamType, \"PlaybackQuality\", vo);\n\n            // Keep only last 10 metrics to avoid memory leak\n            if (metrics.length > 10) {\n                metrics.shift();\n            }\n\n            return vo;\n        },\n\n        addVideoResolution: function (streamType, t, width, height, mediaTime) {\n            var vo = new MediaPlayer.vo.metrics.VideoResolution(),\n                metrics = this.getMetricsFor(streamType).VideoResolution;\n\n            vo.t = t;\n            vo.mt = mediaTime;\n            vo.width = width;\n            vo.height = height;\n\n            // Add new metrics only if width or height changed\n            if (metrics.length > 0) {\n                if ((vo.width === metrics[metrics.length-1].width) &&\n                    (vo.height === metrics[metrics.length-1].height)) {\n                    return metrics[metrics.length - 1];\n                }\n            }\n\n            metrics.push(vo);\n            this.metricAdded(streamType, \"VideoResolution\", vo);\n\n            return vo;\n        },\n\n        addManifestUpdate: function(streamType, type, requestTime, fetchTime, availabilityStartTime, presentationStartTime, clientTimeOffset, currentTime, buffered, latency) {\n            var vo = new MediaPlayer.vo.metrics.ManifestUpdate(),\n                metrics = this.getMetricsFor(\"stream\");\n\n            vo.streamType = streamType;\n            vo.type = type;\n            vo.requestTime = requestTime; // when this manifest update was requested\n            vo.fetchTime = fetchTime; // when this manifest update was received\n            vo.availabilityStartTime = availabilityStartTime;\n            vo.presentationStartTime = presentationStartTime; // the seek point (liveEdge for dynamic, Period[0].startTime for static)\n            vo.clientTimeOffset = clientTimeOffset; // the calculated difference between the server and client wall clock time\n            vo.currentTime = currentTime; // actual element.currentTime\n            vo.buffered = buffered; // actual element.ranges\n            vo.latency = latency; // (static is fixed value of zero. dynamic should be ((Now-@availabilityStartTime) - currentTime)\n\n            metrics.ManifestUpdate.push(vo);\n            this.metricAdded(streamType, \"ManifestUpdate\", vo);\n\n            return vo;\n        },\n\n        updateManifestUpdateInfo: function(manifestUpdate, updatedFields) {\n            if (manifestUpdate && updatedFields) {\n                for (var field in updatedFields) {\n                    if (updatedFields.hasOwnProperty(field)) {\n                        manifestUpdate[field] = updatedFields[field];\n                    }\n                }\n\n                this.metricUpdated(manifestUpdate.streamType, \"ManifestUpdate\", manifestUpdate);\n            }\n        },\n\n        addManifestUpdatePeriodInfo: function(manifestUpdate, id, index, start, duration) {\n            var vo = new MediaPlayer.vo.metrics.ManifestUpdate.PeriodInfo();\n\n            vo.id = id;\n            vo.index = index;\n            vo.start = start;\n            vo.duration = duration;\n\n            manifestUpdate.periodInfo.push(vo);\n            this.metricUpdated(manifestUpdate.streamType, \"ManifestUpdatePeriodInfo\", manifestUpdate);\n\n            return vo;\n        },\n\n        addManifestUpdateRepresentationInfo: function(manifestUpdate, id, index, periodIndex, streamType, presentationTimeOffset, startNumber, segmentInfoType) {\n            var vo = new MediaPlayer.vo.metrics.ManifestUpdate.RepresentationInfo();\n\n            vo.id = id;\n            vo.index = index;\n            vo.periodIndex = periodIndex;\n            vo.streamType = streamType;\n            vo.startNumber = startNumber;\n            vo.segmentInfoType = segmentInfoType;\n            vo.presentationTimeOffset = presentationTimeOffset;\n\n            manifestUpdate.representationInfo.push(vo);\n            this.metricUpdated(manifestUpdate.streamType, \"ManifestUpdateRepresentationInfo\", manifestUpdate);\n\n            return vo;\n        },\n\n        addPlayList: function (streamType, start, mstart, starttype, speed) {\n            var vo = new MediaPlayer.vo.metrics.PlayList(),\n                metrics = this.getMetricsFor(streamType).PlayList;\n\n            vo.stream = streamType;\n            vo.start = start;\n            vo.mstart = mstart;\n            vo.starttype = starttype;\n            vo.speed = speed;\n\n            metrics.push(vo);\n            this.metricAdded(streamType, \"PlayList\", vo);\n\n            // Keep only last 10 metrics to avoid memory leak\n            if (metrics.length > 10) {\n                metrics.shift();\n            }\n\n            return vo;\n        },\n\n        appendPlayListTrace: function (playList, representationid, subreplevel, start, mstart, duration, playbackspeed, stopreason) {\n            var vo = new MediaPlayer.vo.metrics.PlayList.Trace();\n\n            vo.representationid = representationid;\n            vo.subreplevel = subreplevel;\n            vo.start = start;\n            vo.mstart = mstart;\n            vo.duration = duration;\n            vo.playbackspeed = playbackspeed;\n            vo.stopreason = stopreason;\n\n            if (playList && Array.isArray(playList.trace)) {\n                playList.trace.push(vo);\n                this.metricUpdated(playList.stream, \"PlayListTrace\", playList);\n\n                // Keep only last 10 metrics to avoid memory leak\n                if (playList.trace.length > 10) {\n                    playList.trace.shift();\n                }\n            }\n\n            return vo;\n        }\n    };\n};\n\nMediaPlayer.models.MetricsModel.prototype = {\n    constructor: MediaPlayer.models.MetricsModel\n};\n","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.dependencies.Mp4Processor = function() {\n    \"use strict\";\n\n    ///////////////////////////////////////////////////////////////////////////////////////////\n    // MOOV\n    ///////////////////////////////////////////////////////////////////////////////////////////\n\n    var createMovieHeaderBox = function(tracks) {\n\n            // Movie Header Box\n            // This box defines overall information which is media-independent, and relevant to the\n            // entire presentation considered as a whole.\n\n            // Create MovieHeader box (mvhd)\n            var mvhd = new mp4lib.boxes.MovieHeaderBox(),\n                track = tracks[tracks.length - 1]; // take last track to determine get track id\n\n            mvhd.version = 1; // version = 1  in order to have 64bits duration value\n            mvhd.creation_time = 0; // the creation time of the presentation => ignore (set to 0)\n            mvhd.modification_time = 0; // the most recent time the presentation was modified => ignore (set to 0)\n            mvhd.timescale = track.timescale; // the time-scale for the entire presentation => take timescale of current adaptationSet\n            mvhd.duration = Math.round(track.duration * track.timescale); // the length of the presentation (in the indicated timescale) =>  take duration of period\n            mvhd.rate = 0x00010000; // 16.16 number, \"1.0\" = normal playback\n            mvhd.volume = 0x0100; // 8.8 number, \"1.0\" = full volume\n            mvhd.reserved = 0;\n            mvhd.reserved_2 = [0x0, 0x0];\n            mvhd.matrix = [0x00010000, 0x0, 0x0, 0x0, 0x00010000, 0x0, 0x0, 0x0, 0x40000000]; // provides a transformation matrix for the video; (u,v,w) are restricted here to (0,0,1),\n            // hex values (0,0,0x40000000)\n            mvhd.pre_defined = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0];\n            mvhd.next_track_ID = track.trackId + 1; // indicates a value to use for the track ID of the next track to be added to this presentation\n            mvhd.flags = 0; //default value\n\n            return mvhd;\n        },\n\n        createTrackBox = function(track) {\n\n            // Track Box: This is a container box for a single track of a presentation\n            // Track Header Box: This box specifies the characteristics of a single track\n            var trak,\n                tkhd,\n                mdia;\n\n            // Create Track box (trak)\n            trak = new mp4lib.boxes.TrackBox();\n\n            // Create and add TrackHeader box (trak)\n            tkhd = new mp4lib.boxes.TrackHeaderBox();\n\n            tkhd.version = 1; // version = 1  in order to have 64bits duration value\n            tkhd.flags = 0x1 | 0x2 | 0x4; //Track_enabled: Indicates that the track is enabled. Flag value is 0x000001. A disabled track (the low\n            //bit is zero) is treated as if it were not present.\n            //Track_in_movie: Indicates that the track is used in the presentation. Flag value is 0x000002.\n            //Track_in_preview: Indicates that the track is used when previewing the presentation. Flag value is 0x000004.\n            tkhd.creation_time = 0; // the creation time of the presentation => ignore (set to 0)\n            tkhd.modification_time = 0; // the most recent time the presentation was modified => ignore (set to 0)\n            tkhd.track_id = track.trackId; // uniquely identifies this track over the entire life-time of this presentation\n            tkhd.reserved = 0;\n            tkhd.duration = Math.round(track.duration * track.timescale); // the duration of this track (in the timescale indicated in the Movie Header Box) =>  take duration of period\n            tkhd.reserved_2 = [0x0, 0x0];\n            tkhd.layer = 0; // specifies the front-to-back ordering of video tracks; tracks with lower numbers are closer to the viewer => 0 since only one video track\n            tkhd.alternate_group = 0; // specifies a group or collection of tracks => ignore\n            tkhd.volume = 0x0100; // 8.8 number, \"1.0\" = full volume\n            tkhd.reserved_3 = 0;\n            tkhd.matrix = [0x00010000, 0x0, 0x0, 0x0, 0x00010000, 0x0, 0x0, 0x0, 0x40000000]; // provides a transformation matrix for the video; (u,v,w) are restricted here to (0,0,1),\n            tkhd.width = track.width << 16; // visual presentation size as fixed-point 16.16 values\n            tkhd.height = track.height << 16; // visual presentation size as fixed-point 16.16 values\n\n            trak.boxes.push(tkhd);\n\n            //Create container for the track information in a track (mdia)\n            mdia = new mp4lib.boxes.MediaBox();\n\n            //Create and add Media Header Box (mdhd)\n            mdia.boxes.push(createMediaHeaderBox(track));\n\n            //Create and add Handler Reference Box (hdlr)\n            mdia.boxes.push(createHandlerReferenceBox(track));\n\n            //Create and add Media Information Box (minf)\n            mdia.boxes.push(createMediaInformationBox(track));\n\n            trak.boxes.push(mdia);\n\n            return trak;\n        },\n\n        getLanguageCode = function(language) {\n\n            // Declares the language code for this track. See ISO 639-2/T for the set of three character\n            // codes. Each character is packed as the difference between its ASCII value and 0x60. Since the code\n            // is confined to being three lower-case letters, these values are strictly positive.\n            var firstLetterCode,\n                secondLetterCode,\n                thirdLetterCode,\n                result = 0;\n\n            // If lang member is define, get it. if not language is 'und'\n            // If current adaptation is video type, return 'und'.\n            // var language = adaptation.lang ? adaptation.lang : 'und' ;\n\n            // Return value is packed on 15 bits, each character is defined on 5 bits\n            // there is a padding value to align on 16 bits\n            firstLetterCode = (language.charCodeAt(0) - 96) << 10; //96 decimal base = 0x60\n            secondLetterCode = (language.charCodeAt(1) - 96) << 5;\n            thirdLetterCode = language.charCodeAt(2) - 96;\n\n            result = firstLetterCode | secondLetterCode | thirdLetterCode;\n\n            return result;\n        },\n\n        createMediaHeaderBox = function(track) {\n\n            // mdhd : The media header declares overall information that is media-independent, and relevant to characteristics of\n            // the media in a track.\n            var mdhd = new mp4lib.boxes.MediaHeaderBox();\n\n            mdhd.flags = 0;\n            mdhd.version = 1; // version = 1  in order to have 64bits duration value\n            mdhd.creation_time = 0; // the creation time of the presentation => ignore (set to 0)\n            mdhd.modification_time = 0; // the most recent time the presentation was modified => ignore (set to 0)\n            mdhd.timescale = track.timescale; // the time-scale for the entire presentation => take timescale of current adaptationSet\n            mdhd.duration = Math.round(track.duration * track.timescale); //integer that declares the duration of this media (in the scale of the timescale). If the\n            //duration cannot be determined then duration is set to all 1s.\n            mdhd.pad = 0; // padding for language value\n            mdhd.language = getLanguageCode(track.language);\n\n            mdhd.pre_defined = 0; // default value\n\n            return mdhd;\n        },\n\n        stringToCharCode = function(str) {\n            var code = 0,\n                i;\n\n            for (i = 0; i < str.length; i += 1) {\n                code |= str.charCodeAt(i) << ((str.length - i - 1) * 8);\n            }\n            return code;\n        },\n\n        createHandlerReferenceBox = function(track) {\n\n            // This box within a Media Box declares the process by which the media-data in the track is presented, and thus,\n            // the nature of the media in a track. For example, a video track would be handled by a video handler.\n            var hdlr = new mp4lib.boxes.HandlerBox();\n\n            hdlr.version = 0; // default value version = 0\n            hdlr.pre_defined = 0; //default value.\n            switch (track.type) {\n                case 'video':\n                    hdlr.handler_type = stringToCharCode(hdlr.HANDLERTYPEVIDEO);\n                    hdlr.name = hdlr.HANDLERVIDEONAME;\n                    break;\n                case 'audio':\n                    hdlr.handler_type = stringToCharCode(hdlr.HANDLERTYPEAUDIO);\n                    hdlr.name = hdlr.HANDLERAUDIONAME;\n                    break;\n                default:\n                    hdlr.handler_type = stringToCharCode(hdlr.HANDLERTYPETEXT);\n                    hdlr.name = hdlr.HANDLERTEXTNAME;\n            }\n            hdlr.name += '\\0';\n            hdlr.reserved = [0x0, 0x0, 0x0]; //default value\n            hdlr.flags = 0; //default value\n\n            return hdlr;\n        },\n\n        createMediaInformationBox = function(track) {\n\n            // This box contains all the objects that declare characteristic information of the media in the track.\n            var minf = new mp4lib.boxes.MediaInformationBox();\n\n            //Create and add the adapted media header box (vmhd, smhd or nmhd) for audio, video or text.\n            switch (track.type) {\n                case 'video':\n                    minf.boxes.push(createVideoMediaHeaderBox(track));\n                    break;\n                case 'audio':\n                    minf.boxes.push(createSoundMediaHeaderBox(track));\n                    break;\n                default:\n                    //minf.boxes.push(createNullMediaHeaderBox(track));\n            }\n\n            //Create and add Data Information Box (dinf)\n            minf.boxes.push(createDataInformationBox(track));\n\n            //Create and add Sample Table Box (stbl)\n            minf.boxes.push(createSampleTableBox(track));\n\n            return minf;\n\n        },\n\n        createDataInformationBox = function() {\n            var dinf,\n                dref,\n                url;\n\n            // The data information box contains objects that declare the location of the media information in a track.\n            dinf = new mp4lib.boxes.DataInformationBox();\n\n            // The data reference object contains a table of data references (normally URLs) that declare the location(s) of\n            // the media data used within the presentation\n            dref = new mp4lib.boxes.DataReferenceBox();\n\n            dref.version = 0; // is an integer that specifies the version of this box default = 0\n            dref.entry_count = 1; // is an integer that counts the actual entries\n            dref.flags = 0; // default value\n\n            // The DataEntryBox within the DataReferenceBox shall be either a DataEntryUrnBox or a DataEntryUrlBox.\n            // (not used, but mandatory)\n            url = new mp4lib.boxes.DataEntryUrlBox();\n            url.location = \"\";\n            url.version = 0;\n            url.flags = 1;\n\n            //add data Entry Url Box in data Reference box\n            dref.boxes.push(url);\n\n            //add data Reference Box in data information box\n            dinf.boxes.push(dref);\n\n            return dinf;\n        },\n\n        createDecodingTimeToSampleBox = function() {\n\n            // This box contains a compact version of a table that allows indexing from decoding time to sample number.\n\n            var stts = new mp4lib.boxes.TimeToSampleBox();\n\n            stts.version = 0; // is an integer that specifies the version of this box. default value = 0\n            stts.entry_count = 0; // is an integer that gives the number of entries in the following table. not used in fragmented content\n            stts.flags = 0; // default value = 0\n\n            stts.entry = [];\n\n            return stts;\n        },\n\n        createSampleToChunkBox = function() {\n\n            // Samples within the media data are grouped into chunks.\n            var stsc = new mp4lib.boxes.SampleToChunkBox();\n\n            stsc.flags = 0;\n            stsc.version = 0; // is an integer that specifies the version of this box. default value = 0.\n            stsc.entry_count = 0; // is an integer that gives the number of entries in the following table\n\n            stsc.entry = [];\n\n            return stsc;\n        },\n\n        createChunkOffsetBox = function() {\n\n            // The chunk offset table gives the index of each chunk into the containing file\n            var stco = new mp4lib.boxes.ChunkOffsetBox();\n\n            stco.version = 0; // is an integer that specifies the version of this box. default value = 0\n            stco.entry_count = 0; // is an integer that gives the number of entries in the following table\n            stco.flags = 0; // default value\n\n            stco.chunk_offset = [];\n\n            return stco;\n        },\n\n        createSampleSizeBox = function() {\n\n            // This box contains the sample count and a table giving the size in bytes of each sample. This allows the media\n            // data itself to be unframed. The total number of samples in the media is always indicated in the sample count.\n            var stsz = new mp4lib.boxes.SampleSizeBox();\n\n            stsz.version = 0; // default value = 0\n            stsz.flags = 0; //default value = 0\n            stsz.sample_count = 0; //is an integer that gives the number of samples in the track; if sample-size is 0, then it is\n            //also the number of entries in the following table\n            stsz.sample_size = 0; //is integer specifying the default sample size.\n\n            return stsz;\n        },\n\n        _hexstringtoBuffer = function(a) {\n            var res = new Uint8Array(a.length / 2),\n                i;\n\n            for (i = 0; i < a.length / 2; i += 1) {\n                res[i] = parseInt(\"\" + a[i * 2] + a[i * 2 + 1], 16);\n            }\n            return res;\n        },\n\n        _mergeArrays = function(oldBuffer, newPart) {\n            var res = new Uint8Array(oldBuffer.length + newPart.length);\n            res.set(oldBuffer, 0);\n            res.set(newPart, oldBuffer.length);\n            return res;\n        },\n\n        createAVCConfigurationBox = function(track) {\n            var avcC,\n                NALDatabuffer,\n                codecPrivateData,\n                NALArray,\n                SPS_index,\n                PPS_index,\n                i,\n                NALBuffer,\n                tempBuffer,\n                regexpSPS = new RegExp(\"^[A-Z0-9]7\", \"gi\"),\n                regexpPPS = new RegExp(\"^[A-Z0-9]8\", \"gi\");\n\n            //Create an AVC Configuration Box\n            avcC = new mp4lib.boxes.AVCConfigurationBox();\n\n            avcC.configurationVersion = 1; //unsigned int(8) configurationVersion = 1;\n            avcC.lengthSizeMinusOne = 3; //indicates the length in bytes of the NALUnitLength field in an AVC video\n            //sample or AVC parameter set sample of the associated stream minus one\n\n            avcC.reserved = 0x3F; //bit(6) reserved = 111111b;\n\n            avcC.SPS_NAL = []; //SPS NAL Array\n            avcC.PPS_NAL = []; //PPS NAL Array\n\n            NALDatabuffer = new Uint8Array(0);\n\n            codecPrivateData = track.codecPrivateData;\n\n            NALArray = codecPrivateData.split(\"00000001\");\n\n            NALArray.splice(0, 1);\n\n            SPS_index = 0;\n            PPS_index = 0;\n            for (i = 0; i < NALArray.length; i += 1) {\n                NALBuffer = _hexstringtoBuffer(NALArray[i]);\n\n                if (NALArray[i].match(regexpSPS)) {\n                    avcC.SPS_NAL[SPS_index++] = {\n                        \"NAL_length\": NALBuffer.length,\n                        \"NAL\": NALBuffer\n                    };\n                    avcC.AVCProfileIndication = parseInt(NALArray[i].substr(2, 2), 16); //contains the profile code as defined in ISO/IEC 14496-10.\n                    avcC.profile_compatibility = parseInt(NALArray[i].substr(4, 2), 16); //is a byte defined exactly the same as the byte which occurs between the\n                    //profile_IDC and level_IDC in a sequence parameter set (SPS), as defined in ISO/IEC 14496-10.\n                    avcC.AVCLevelIndication = parseInt(NALArray[i].substr(6, 2), 16); //contains the level code as defined in ISO/IEC 14496-10.\n                }\n                if (NALArray[i].match(regexpPPS)) {\n                    avcC.PPS_NAL[PPS_index++] = {\n                        \"NAL_length\": NALBuffer.length,\n                        \"NAL\": NALBuffer\n                    };\n                }\n\n                tempBuffer = new Uint8Array(NALBuffer.length + 4);\n                tempBuffer[3] = NALBuffer.length;\n                tempBuffer.set(NALBuffer, 4);\n\n                NALDatabuffer = _mergeArrays(NALDatabuffer, tempBuffer);\n            }\n            avcC.numOfSequenceParameterSets = SPS_index; // number of SPSs that are used as the initial set of SPSs for decoding the AVC elementary stream.\n            avcC.numOfPictureParameterSets = PPS_index; // number of PPSs that are used as the initial set of PPSs for decoding the AVC elementary stream.\n\n            return avcC;\n        },\n\n        createAVCVisualSampleEntry = function(track) {\n            var avc1 = null;\n\n            //An AVC visual sample entry shall contain an AVC Configuration Box\n            if (track.contentProtection !== undefined) {\n                avc1 = new mp4lib.boxes.EncryptedVideoBox();\n            } else {\n                avc1 = new mp4lib.boxes.AVC1VisualSampleEntryBox();\n            }\n\n            avc1.data_reference_index = 1; //To DO... ??\n            avc1.compressorname = [0x0A, 0x41, 0x56, 0x43, 0x20, 0x43, 0x6F, 0x64,\n                                   0x69, 0x6E, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00,\n                                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];\n            // = \"AVC Coding\";\n            //is a name, for informative purposes. It is formatted in a fixed 32-byte field, with the first\n            //byte set to the number of bytes to be displayed, followed by that number of bytes of displayable data,\n            //and then padding to complete 32 bytes total (including the size byte). The field may be set to 0.\n            avc1.depth = 0x0018; //takes one of the following values 0x0018  images are in colour with no alpha.\n            avc1.reserved = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0]; //default value = 0\n            avc1.reserved_2 = 0; //default value = 0\n            avc1.reserved_3 = 0; //default value = 0\n            avc1.pre_defined = 0; //unsigned int(16) pre_defined = 0;\n            avc1.pre_defined_2 = [0x0, 0x0, 0x0]; //unsigned int(32)[3] pre_defined = 0;\n            avc1.pre_defined_3 = 65535; //int(16) pre_defined = -1;\n            avc1.frame_count = 1; //template unsigned int(16) frame_count = 1;indicates how many frames of compressed video are stored in each sample. The default is\n            //1, for one frame per sample; it may be more than 1 for multiple frames per sample\n            avc1.horizresolution = 0x00480000; // 72 dpi\n            avc1.vertresolution = 0x00480000; // 72 dpi\n\n            avc1.height = track.height; //are the maximum visual width and height of the stream described by this sample\n            avc1.width = track.width; //description, in pixels\n\n            //create and add AVC Configuration Box (avcC)\n            avc1.boxes.push(createAVCConfigurationBox(track));\n\n            if (track.contentProtection !== undefined) {\n                // create and add Protection Scheme Info Box\n                avc1.boxes.push(createProtectionSchemeInfoBox(track));\n            }\n\n            return avc1;\n        },\n\n        createOriginalFormatBox = function(track) {\n            var frma = new mp4lib.boxes.OriginalFormatBox();\n            frma.data_format = stringToCharCode(track.codecs.substring(0, track.codecs.indexOf('.')));\n            return frma;\n        },\n\n        createSchemeTypeBox = function() {\n            var schm = new mp4lib.boxes.SchemeTypeBox();\n\n            schm.flags = 0;\n            schm.version = 0;\n            schm.scheme_type = 0x63656E63; //'cenc' => common encryption\n            schm.scheme_version = 0x00010000; // version set to 0x00010000 (Major version 1, Minor version 0)\n\n            return schm;\n        },\n\n        createSchemeInformationBox = function(track) {\n            var schi = new mp4lib.boxes.SchemeInformationBox();\n\n            //create and add Track Encryption Box\n            schi.boxes.push(createTrackEncryptionBox(track));\n\n            return schi;\n        },\n\n        createTrackEncryptionBox = function(track) {\n            var tenc = new mp4lib.boxes.TrackEncryptionBox();\n\n            tenc.flags = 0; //default value\n            tenc.version = 0; //default value\n\n            tenc.default_IsEncrypted = 0x1; //default value\n            tenc.default_IV_size = 8; //default value, NA =>  prciser\n            tenc.default_KID = (track.contentProtection && (track.contentProtection.length) > 0 && track.contentProtection[0][\"cenc:default_KID\"]) ?\n                track.contentProtection[0][\"cenc:default_KID\"] :\n                [0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0];\n\n            return tenc;\n        },\n\n        createProtectionSchemeInfoBox = function(track) {\n            //create Protection Scheme Info Box\n            var sinf = new mp4lib.boxes.ProtectionSchemeInformationBox();\n\n            //create and add Original Format Box => indicate codec type of the encrypted content\n            sinf.boxes.push(createOriginalFormatBox(track));\n\n            //create and add Scheme Type box\n            sinf.boxes.push(createSchemeTypeBox());\n\n            //create and add Scheme Information Box\n            sinf.boxes.push(createSchemeInformationBox(track));\n\n            return sinf;\n        },\n\n        createVisualSampleEntry = function(track) {\n            var codec = track.codecs.substring(0, track.codecs.indexOf('.'));\n\n            switch (codec) {\n                case \"avc1\":\n                    return createAVCVisualSampleEntry(track);\n                default:\n                    throw {\n                        name: MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CODEC_UNSUPPORTED,\n                        message: \"Video codec is not supported (MP4)\",\n                        data: {\n                            codec: codec\n                        }\n                    };\n            }\n        },\n\n        parseHexString = function(str) {\n            var bytes = [];\n            while (str.length >= 2) {\n                bytes.push(parseInt(str.substring(0, 2), 16));\n                str = str.substring(2, str.length);\n            }\n\n            return bytes;\n        },\n\n        createMPEG4AACESDescriptor = function(track) {\n            var audioSpecificConfig,\n                dsiLength,\n                decoderSpecificInfo,\n                dcdLength,\n                decoderConfigDescriptor,\n                esdLength,\n                esDescriptor;\n\n            // AudioSpecificConfig\n            // defined in ISO/IEC 14496-3, subpart 1\n            // => AudioSpecificConfig corresponds to hex bytes contained in \"codecPrivateData\" field\n            audioSpecificConfig = parseHexString(track.codecPrivateData);\n\n            // DecoderSpecificInfo\n            // defined in ISO/IEC 14496-1 (Systems), extends a BaseDescriptor\n            dsiLength = audioSpecificConfig.length;\n            decoderSpecificInfo = new Uint8Array(2 + dsiLength); // 2 = tag + size bytes\n            decoderSpecificInfo[0] = 0x05; // bit(8), tag=0x05 (DecSpecificInfoTag)\n            decoderSpecificInfo[1] = dsiLength; // bit(8), size\n            decoderSpecificInfo.set(audioSpecificConfig, 2); // AudioSpecificConfig bytes\n\n            // DecoderConfigDescriptor\n            // defined in ISO/IEC 14496-1 (Systems), extends a BaseDescriptor\n            dcdLength = 13 + decoderSpecificInfo.length; // 2 = tag + size bytes\n            decoderConfigDescriptor = new Uint8Array(2 + dcdLength);\n            decoderConfigDescriptor[0] = 0x04; // bit(8), tag=0x04 (DecoderConfigDescrTag)\n            decoderConfigDescriptor[1] = dcdLength; // bit(8), size\n            decoderConfigDescriptor[2] = 0x40; // bit(8), objectTypeIndication=0x40 (MPEG-4 AAC)\n            decoderConfigDescriptor[3] = 0x05 << 2; // bit(6), streamType=0x05 (Audiostream)\n            decoderConfigDescriptor[3] |= 0 << 1; // bit(1), upStream=0\n            decoderConfigDescriptor[3] |= 1; // bit(1), reserved=1\n            decoderConfigDescriptor[4] = 0xFF; // bit(24), buffersizeDB=undefined\n            decoderConfigDescriptor[5] = 0xFF; // ''\n            decoderConfigDescriptor[6] = 0xFF; // ''\n            decoderConfigDescriptor[7] = (track.bandwidth & 0xFF000000) >> 24; // bit(32), maxBitrate=undefined\n            decoderConfigDescriptor[8] = (track.bandwidth & 0x00FF0000) >> 16; // ''\n            decoderConfigDescriptor[9] = (track.bandwidth & 0x0000FF00) >> 8; // ''\n            decoderConfigDescriptor[10] = (track.bandwidth & 0x000000FF); // ''\n            decoderConfigDescriptor[11] = (track.bandwidth & 0xFF000000) >> 24; // bit(32), avgbitrate\n            decoderConfigDescriptor[12] |= (track.bandwidth & 0x00FF0000) >> 16; // ''\n            decoderConfigDescriptor[13] |= (track.bandwidth & 0x0000FF00) >> 8; // ''\n            decoderConfigDescriptor[14] |= (track.bandwidth & 0x000000FF); // ''\n            decoderConfigDescriptor.set(decoderSpecificInfo, 15); // DecoderSpecificInfo bytes\n\n            // ES_Descriptor\n            // defined in ISO/IEC 14496-1 (Systems), extends a BaseDescriptor\n            esdLength = 3 + decoderConfigDescriptor.length;\n            esDescriptor = new Uint8Array(2 + esdLength); // 2 = tag + size bytes\n            esDescriptor[0] = 0x03; // bit(8), tag=0x03 (ES_DescrTag)\n            esDescriptor[1] = esdLength; // bit(8), size\n            esDescriptor[2] = (track.trackId & 0xFF00) >> 8; // bit(16), ES_ID=track_id\n            esDescriptor[3] = (track.trackId & 0x00FF); // ''\n            esDescriptor[4] = 0; // bit(8), flags and streamPriority\n            esDescriptor.set(decoderConfigDescriptor, 5); // decoderConfigDescriptor bytes\n\n            return esDescriptor;\n        },\n\n        createMP4AudioSampleEntry = function(track) {\n            var mp4a = null,\n                esdBox,\n                ES_Descriptor;\n\n            if (track.contentProtection !== undefined) {\n                mp4a = new mp4lib.boxes.EncryptedAudioBox();\n            } else {\n                mp4a = new mp4lib.boxes.MP4AudioSampleEntryBox();\n            }\n\n            // SampleEntry fields\n            mp4a.reserved = [0x0, 0x0, 0x0, 0x0, 0x0, 0x0];\n            mp4a.data_reference_index = 1; // ??\n\n            // AudioSampleEntry fields\n            mp4a.reserved_2 = [0x0, 0x0]; // default value = 0\n            mp4a.channelcount = track.channels; // number of channels\n            mp4a.samplesize = 16; // default value = 16\n            mp4a.pre_defined = 0; // default value = 0\n            mp4a.reserved_3 = 0; // default value = 0\n            mp4a.samplerate = track.samplingRate << 16; // sampling rate, as fixed-point 16.16 values\n\n            esdBox = new mp4lib.boxes.ESDBox();\n            ES_Descriptor = createMPEG4AACESDescriptor(track);\n            esdBox.ES_tag = ES_Descriptor[0];\n            esdBox.ES_length = ES_Descriptor[1];\n            esdBox.ES_data = ES_Descriptor.subarray(2, ES_Descriptor.length);\n            esdBox.version = 0;\n            esdBox.flags = 0;\n\n            // MP4AudioSampleEntry fields\n            mp4a.boxes.push(esdBox);\n\n            if (track.contentProtection !== undefined) {\n                // create and add Protection Scheme Info Box\n                mp4a.boxes.push(createProtectionSchemeInfoBox(track));\n            }\n\n            return mp4a;\n        },\n\n        createAudioSampleEntry = function(track) {\n            var codec = track.codecs.substring(0, track.codecs.indexOf('.'));\n\n            switch (codec) {\n                case \"mp4a\":\n                    return createMP4AudioSampleEntry(track);\n                default:\n                    throw {\n                        name: MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CODEC_UNSUPPORTED,\n                        message: \"Audio codec is not supported (MP4)\",\n                        data: {\n                            codec: codec\n                        }\n                    };\n            }\n\n            return null;\n        },\n\n        createSampleDescriptionBox = function(track) {\n\n            //The sample description table gives detailed information about the coding type used, and any initialization\n            //information needed for that coding.\n            var stsd = new mp4lib.boxes.SampleDescriptionBox();\n            stsd.version = 0;\n            stsd.flags = 0;\n\n            switch (track.type) {\n                case \"video\":\n                    stsd.boxes.push(createVisualSampleEntry(track));\n                    break;\n                case \"audio\":\n                    stsd.boxes.push(createAudioSampleEntry(track));\n                    break;\n                default:\n                    //NAN : To do add text entry\n                    break;\n            }\n\n            return stsd;\n        },\n\n        createSampleTableBox = function(track) {\n\n            //The sample table contains all the time and data indexing of the media samples in a track. Using the tables\n            //here, it is possible to locate samples in time, determine their type (e.g. I-frame or not), and determine their\n            //size, container, and offset into that container.\n            var stbl = new mp4lib.boxes.SampleTableBox();\n\n            //create and add Decoding Time to Sample Box (stts)\n            stbl.boxes.push(createDecodingTimeToSampleBox(track));\n\n            //create and add Sample to Chunk Box (stsc)\n            stbl.boxes.push(createSampleToChunkBox(track));\n\n            //create and add Chunk Offset Box (stco)\n            stbl.boxes.push(createChunkOffsetBox(track));\n\n            //create and add Sample Size Box (stsz)\n            stbl.boxes.push(createSampleSizeBox(track));\n\n            //create and add Sample Description Box (stsd)\n            stbl.boxes.push(createSampleDescriptionBox(track));\n\n            return stbl;\n        },\n\n        createVideoMediaHeaderBox = function() {\n            //The video media header contains general presentation information, independent of the coding, for video\n            //track. Note that the flags field has the value 1.\n            var vmhd = new mp4lib.boxes.VideoMediaHeaderBox();\n\n            vmhd.version = 0; //default value, is an integer that specifies the version of this box\n            vmhd.flags = 1; //default value\n            vmhd.graphicsmode = 0; //specifies a composition mode for this video track, from the following enumerated set,\n            //which may be extended by derived specifications: copy = 0 copy over the existing image\n            vmhd.opcolor = [0x0, 0x0, 0x0]; //is a set of 3 colour values (red, green, blue) available for use by graphics modes\n            //default value opcolor = {0, 0, 0};\n\n            return vmhd;\n        },\n\n        createSoundMediaHeaderBox = function() {\n\n            //The sound media header contains general presentation information, independent of the coding, for audio\n            //track. This header is used for all tracks containing audio\n            var smhd = new mp4lib.boxes.SoundMediaHeaderBox();\n\n            smhd.version = 0; //default value, is an integer that specifies the version of this box\n            smhd.balance = 0; //is a fixed-point 8.8 number that places mono audio tracks in a stereo space; 0 is centre (the\n            //normal value); full left is -1.0 and full right is 1.0.\n            smhd.reserved = 0;\n            smhd.flags = 1;\n\n            return smhd;\n        },\n\n        /*createNullMediaHeaderBox = function () {\n            //NAN non dfini dans mp4lib,  dfinir\n            //var nmhd = new NullMediaHeaderBox();\n            //return nmhd;\n        },*/\n\n        createFileTypeBox = function() {\n\n            //create a File Type Box\n            var ftyp = new mp4lib.boxes.FileTypeBox();\n\n            ftyp.major_brand = 1769172790; // is a brand identifier iso6 => decimal ASCII value for iso6\n            ftyp.minor_brand = 1; // is an informative integer for the minor version of the major brand\n            ftyp.compatible_brands = []; //is a list, to the end of the box, of brands isom, iso6 and msdh\n            ftyp.compatible_brands[0] = 1769172845; // => decimal ASCII value for isom\n            ftyp.compatible_brands[1] = 1769172790; // => decimal ASCII value for iso6\n            ftyp.compatible_brands[2] = 1836278888; // => decimal ASCII value for msdh\n\n            return ftyp;\n        },\n\n        createMovieExtendsBox = function(tracks) {\n            var mvex,\n                //mehd,\n                trex,\n                track = tracks[tracks.length - 1],\n                i;\n\n            // Create Movie Extends Box (mvex)\n            // This box warns readers that there might be Movie Fragment Boxes in this file\n            mvex = new mp4lib.boxes.MovieExtendsBox();\n\n            // Create Movie Extends Header Box (mehd)\n            // The Movie Extends Header is optional, and provides the overall duration, including fragments, of a fragmented\n            // movie. If this box is not present, the overall duration must be computed by examining each fragment.\n            // mehd is optional\n            /*if (track.duration !== Number.POSITIVE_INFINITY) {\n                mehd = new mp4lib.boxes.MovieExtendsHeaderBox();\n                mehd.version = 1;\n                mehd.flags = 0;\n                mehd.fragment_duration = Math.round(track.duration * track.timescale); // declares length of the presentation of the whole movie including fragments\n\n                //add mehd box in mvex box\n                mvex.boxes.push(mehd);\n            }*/\n\n            for (i = 0; i < tracks.length; i += 1) {\n                track = tracks[i];\n                // Create Track Extend Box (trex), exactly one for each track in the movie box\n                // This sets up default values used by the movie fragments. By setting defaults in this way, space and\n                // complexity can be saved in each Track Fragment Box.\n                trex = new mp4lib.boxes.TrackExtendsBox();\n                trex.version = 0;\n                trex.flags = 0;\n                trex.track_ID = track.trackId; // identifies the track; this shall be the track ID of a track in the Movie Box\n                trex.default_sample_description_index = 1; // Set default value\n                trex.default_sample_duration = 0; // ''\n                trex.default_sample_flags = 0; // ''\n                trex.default_sample_size = 0; // ''\n\n                // add trex box in mvex box\n                mvex.boxes.push(trex);\n            }\n\n            return mvex;\n        },\n\n        createProtectionSystemSpecificHeaderBox = function(keySystems) {\n            var psshs = [],\n                pssh_bytes,\n                pssh,\n                i;\n\n            for (i = 0; i < keySystems.length; i += 1) {\n                pssh_bytes = new Uint8Array(keySystems[i].initData);\n                pssh = new mp4lib.boxes.ProtectionSystemSpecificHeaderBox();\n                pssh.read(pssh_bytes, 8, pssh_bytes.length); // 8: skip box length and type fields\n                psshs.push(pssh);\n            }\n\n            return psshs;\n        },\n\n        generateMoov = function (tracks) {\n            var boxes = [],\n                moov,\n                supportedKS,\n                i;\n\n            // Create Movie box (moov)\n            moov = new mp4lib.boxes.MovieBox();\n\n            // Create and add MovieHeader box (mvhd)\n            moov.boxes.push(createMovieHeaderBox(tracks));\n\n            for (i = 0; i < tracks.length; i += 1) {\n                // Create and add Track box (trak)\n                moov.boxes.push(createTrackBox(tracks[i]));\n            }\n\n            // Create and add MovieExtends box (mvex)\n            moov.boxes.push(createMovieExtendsBox(tracks));\n\n            // Create and add Protection System Specific Header box (pssh)\n            for (i = 0; i < tracks.length; i++) {\n                if (tracks[i].contentProtection !== undefined) {\n                    supportedKS = this.protectionExt.getSupportedKeySystemsFromContentProtection(tracks[i].contentProtection);\n                    moov.boxes.push.apply(moov.boxes, createProtectionSystemSpecificHeaderBox(supportedKS));\n                }\n            }\n\n            boxes.push(createFileTypeBox());\n\n            boxes.push(moov);\n\n            return boxes;\n        },\n\n        ///////////////////////////////////////////////////////////////////////////////////////////\n        // MOOF\n        ///////////////////////////////////////////////////////////////////////////////////////////\n\n        sequenceNumber = 1,\n\n        createMovieFragmentHeaderBox = function() {\n\n            // Movie Fragment Header Box\n            // The movie fragment header contains a sequence number, as a safety check. The sequence number usually\n            // starts at 1 and must increase for each movie fragment in the file, in the order in which they occur. This allows\n            // readers to verify integrity of the sequence; it is an error to construct a file where the fragments are out of\n            // sequence.\n            var mfhd = new mp4lib.boxes.MovieFragmentHeaderBox();\n\n            mfhd.version = 0;\n            mfhd.flags = 0;\n            mfhd.sequence_number = sequenceNumber++;\n\n            return mfhd;\n        },\n\n        createTrackFragmentBox = function(track) {\n\n            // Track Fragment Box\n            // Within the movie fragment there is a set of track fragments, zero or more per track. The track fragments in\n            // turn contain zero or more track runs, each of which document a contiguous run of samples for that track.\n            // Within these structures, many fields are optional and can be defaulted.\n            var traf = new mp4lib.boxes.TrackFragmentBox();\n\n            traf.version = 0;\n            traf.flags = 0;\n\n            // Add Track Fragment Header box (tfhd)\n            traf.boxes.push(createTrackFragmentHeaderBox(track));\n\n            // Add Track Fragment Decode Time box (tfdt)\n            traf.boxes.push(createTrackFragmentBaseMediaDecodeTimeBox(track));\n\n            // Add Track Fragment Run box (trun)\n            traf.boxes.push(createTrackFragmentRunBox(track));\n\n            // Add Sample Dependency Table box (sdtp)\n            traf.boxes.push(createSampleDependencyTableBox(track));\n\n            return traf;\n        },\n\n        createTrackFragmentHeaderBox = function(track) {\n\n            // Track Fragment Header Box\n            // Each movie fragment can add zero or more fragments to each track; and a track fragment can add zero or\n            // more contiguous runs of samples. The track fragment header sets up information and defaults used for those\n            // runs of samples.\n            var tfhd = new mp4lib.boxes.TrackFragmentHeaderBox();\n\n            tfhd.version = 0;\n            tfhd.flags = //0x000008 | // default-sample-duration-present\n            //0x000010 | // default-sample-size-present\n            0x020000; // default-base-is-moof\n\n            tfhd.track_ID = track.trackId;\n            //tfhd.default_sample_duration = 0;\n            //tfhd.default_sample_size = 0;\n\n            return tfhd;\n        },\n\n        createTrackFragmentBaseMediaDecodeTimeBox = function(track) {\n\n            // Track Fragment Base Media Decode Time Box\n            // The Track Fragment Base Media Decode Time Box provides the absolute decode time, measured on the\n            // media timeline, of the first sample in decode order in the track fragment. This can be useful, for example,\n            // when performing random access in a file; it is not necessary to sum the sample durations of all preceding\n            // samples in previous fragments to find this value (where the sample durations are the deltas in the Decoding\n            // Time to Sample Box and the sample_durations in the preceding track runs).\n            // The Track Fragment Base Media Decode Time Box, if present, shall be positioned after the Track Fragment\n            // Header Box and before the first Track Fragment Run box.\n\n            var tfdt = new mp4lib.boxes.TrackFragmentBaseMediaDecodeTimeBox();\n\n            tfdt.version = 1; // baseMediaDecodeTime on 64 bits\n            tfdt.flags = 0;\n\n            tfdt.baseMediaDecodeTime = (track.samples.length > 0) ? track.samples[0].dts : 0;\n\n            return tfdt;\n        },\n\n        createTrackFragmentRunBox = function(track) {\n\n            // Track Fragment Run Box\n            // Within the Track Fragment Box, there are zero or more Track Run Boxes. If the duration-is-empty flag is set in\n            // the tf_flags, there are no track runs. A track run documents a contiguous set of samples for a track.\n            // The number of optional fields is determined from the number of bits set in the lower byte of the flags, and the\n            // size of a record from the bits set in the second byte of the flags. This procedure shall be followed, to allow for\n            // new fields to be defined.\n\n            var trun = new mp4lib.boxes.TrackFragmentRunBox(),\n                i,\n                cts_base,\n                sample_duration_present_flag,\n                sample;\n\n            cts_base = track.samples[0].cts;\n            sample_duration_present_flag = (track.samples[0].duration > 0) ? 0x000100 : 0x000000;\n\n            trun.version = 0;\n            trun.flags = 0x000001 | // data-offset-present\n                         sample_duration_present_flag | // sample-duration-present\n                         0x000200 | // sample-size-present\n                         0x000400 | // sample-flags-present\n                         ((track.type === 'video') ? 0x000800 : 0x000000); // sample-composition-time-offsets-present\n\n            trun.data_offset = 0; // Initialize to 0, will be updated once mdat is set\n            trun.samples_table = [];\n            trun.sample_count = track.samples.length;\n\n            for (i = 0; i < track.samples.length; i++) {\n                sample = {\n                    sample_duration: track.samples[i].duration,\n                    sample_size: track.samples[i].size,\n                    sample_composition_time_offset: track.samples[i].cts - track.samples[i].dts,\n                    sample_flags: track.samples[i].flags\n                };\n\n                if (sample.sample_composition_time_offset < 0) {\n                    trun.version = 1;\n                }\n\n                trun.samples_table.push(sample);\n            }\n\n            return trun;\n        },\n\n        createSampleDependencyTableBox = function(track) {\n            var sdtp = new mp4lib.boxes.SampleDependencyTableBox(),\n                i;\n\n            sdtp.version = 0;\n            sdtp.flags = 0;\n            sdtp.sample_dependency_table = [];\n            for (i = 0; i < track.samples.length; i++) {\n                sdtp.sample_dependency_table.push((track.samples[i].flags & 0x0FF00000) >> 20);\n            }\n\n            return sdtp;\n        },\n\n        createMediaDataBox = function(track) {\n\n            // Media Data Box\n\n            var mdat = new mp4lib.boxes.MediaDataBox();\n\n            mdat.data = track.data;\n\n            return mdat;\n        },\n\n        generateMoof = function (tracks) {\n\n            var boxes = [],\n                moof,\n                i,\n                length,\n                trafs,\n                mdatLength = 0,\n                trackglobal = {},\n                mdatTracksTab = [],\n                offset = 0;\n\n            // Create Movie Fragment box (moof)\n            moof = new mp4lib.boxes.MovieFragmentBox();\n\n            // Create Movie Fragment Header box (moof)\n            moof.boxes.push(createMovieFragmentHeaderBox());\n\n            if (tracks) {\n                for (i = 0; i < tracks.length; i += 1) {\n                    // Create Track Fragment box (traf)\n                    moof.boxes.push(createTrackFragmentBox(tracks[i]));\n                }\n            }\n\n            boxes.push(moof);\n\n            moof.computeLength();\n            length = moof.size;\n\n            // Add tracks data\n            trafs = moof.getBoxesByType(\"traf\");\n\n            length += 8; // 8 = 'size' + 'type' mdat fields length\n\n            if (tracks && tracks.length) {\n                // mdat array size = tracks.length\n                mdatTracksTab = [tracks.length];\n            }\n\n            if (tracks) {\n                for (i = 0; i < tracks.length; i += 1) {\n                    // Update trun.data_offset for the track\n                    trafs[i].getBoxByType(\"trun\").data_offset = length;\n                    // Update length of output fragment file\n                    length += tracks[i].data.length;\n                    // Add current data in mdatTracksTab array\n                    mdatTracksTab[i] = tracks[i].data;\n                    // Update length of global mdat\n                    mdatLength += mdatTracksTab[i].length;\n                }\n            }\n\n            trackglobal.data = new Uint8Array(mdatLength);\n\n            // Concatenate all the tracks data in an array\n            for (i = 0; i < mdatTracksTab.length; i++) {\n                trackglobal.data.set(mdatTracksTab[i], offset);\n                offset += mdatTracksTab[i].length;\n            }\n\n            // Create mdat\n            boxes.push(createMediaDataBox(trackglobal));\n\n            return boxes;\n        };\n\n    return {\n        protectionExt: undefined,\n\n        generateInitSegment: function (tracks) {\n            var file = new mp4lib.boxes.File();\n            file.boxes = generateMoov.call(this, tracks);\n            return mp4lib.serialize(file);\n        },\n\n        generateMediaSegment: function (tracks) {\n            var file = new mp4lib.boxes.File();\n            file.boxes = generateMoof.call(this, tracks);\n            return mp4lib.serialize(file);\n        },\n\n        generateInitMediaSegment: function (tracks) {\n            var file = new mp4lib.boxes.File();\n            file.boxes = generateMoov.call(this, tracks);\n            file.boxes = file.boxes.concat(generateMoof.call(this, tracks));\n            return mp4lib.serialize(file);\n        },\n    };\n};\n\nMediaPlayer.dependencies.Mp4Processor.prototype = {\n    constructor: MediaPlayer.dependencies.Mp4Processor\n};","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.dependencies.Notifier = function () {\n    \"use strict\";\n\n    var OBSERVABLE_ID_PROP = \"observableId\",\n        system,\n        id = 0,\n\n        getId = function() {\n            if (!this[OBSERVABLE_ID_PROP]) {\n                id += 1;\n                this[OBSERVABLE_ID_PROP] = \"_id_\" + id;\n            }\n\n            return this[OBSERVABLE_ID_PROP];\n        };\n\n    return {\n        system : undefined,\n\n        setup: function() {\n            system = this.system;\n            system.mapValue('notify', this.notify);\n            system.mapValue('subscribe', this.subscribe);\n            system.mapValue('unsubscribe', this.unsubscribe);\n        },\n\n        notify: function (/*eventName[, args]*/) {\n            var eventId = arguments[0] + getId.call(this),\n                event = new MediaPlayer.vo.Event();\n\n            event.sender =  this;\n            event.type = arguments[0];\n            event.data = arguments[1];\n            event.error = arguments[2];\n            event.timestamp = new Date().getTime();\n\n            system.notify.call(system, eventId, event);\n        },\n\n        subscribe: function(eventName, observer, handler, oneShot) {\n            if (!handler && observer[eventName]) {\n                handler = observer[eventName] = observer[eventName].bind(observer);\n            }\n\n            if(!observer) throw \"observer object cannot be null or undefined\";\n\n            if(!handler) throw \"event handler cannot be null or undefined\";\n\n            eventName += getId.call(this);\n\n            system.mapHandler(eventName, undefined, handler, oneShot);\n        },\n\n        unsubscribe: function(eventName, observer, handler) {\n            handler = handler || observer[eventName];\n            eventName += getId.call(this);\n\n            system.unmapHandler(eventName, undefined, handler);\n        }\n    };\n};\n\nMediaPlayer.dependencies.Notifier.prototype = {\n    constructor: MediaPlayer.dependencies.Notifier\n};","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.dependencies.Parser = function() {\n    \"use strict\";\n\n    var _parser = null,\n\n        parse = function(data, baseUrl) {\n\n            if (_parser === null) {\n                // we parse the response of the request to know the manifest type\n                if (data.indexOf(\"SmoothStreamingMedia\") > -1 && typeof(this.mssParser) !== 'undefined') {\n                    this.system.notify('setContext', 'MSS');\n                    //do some business to transform it into a Dash Manifest\n                    _parser = this.mssParser;\n                } else if (data.indexOf(\"#EXTM3U\") > -1 && typeof(this.hlsParser) !== 'undefined') {\n                    this.system.notify('setContext', 'HLS');\n                    _parser = this.hlsParser;\n                } else if (data.indexOf(\"MPD\") > -1 && typeof(this.dashParser) !== 'undefined') {\n                    this.system.notify('setContext', 'MPD');\n                    _parser = this.dashParser;\n                } else {\n                    return Q.reject(\"manifest cannot be parsed, protocol is unsupported!\");\n                }\n            }\n\n            return _parser.parse(data, baseUrl);\n        },\n\n        abort = function() {\n            if ((_parser !== null) && (_parser.abort !== undefined)) {\n                _parser.abort();\n            }\n        },\n\n        reset = function() {\n            _parser = null;\n        };\n\n    return {\n        debug: undefined,\n        system: undefined,\n        dashParser: undefined,\n        mssParser: undefined,\n        hlsParser: undefined,\n        metricsModel: undefined,\n\n        parse: parse,\n        abort: abort,\n        reset: reset\n    };\n};\n\nMediaPlayer.dependencies.Parser.prototype = {\n    constructor: MediaPlayer.dependencies.Parser\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.dependencies.SourceBufferExtensions = function () {\n    \"use strict\";\n    this.system = undefined;\n    this.manifestExt = undefined;\n};\n\nMediaPlayer.dependencies.SourceBufferExtensions.prototype = {\n\n    constructor: MediaPlayer.dependencies.SourceBufferExtensions,\n\n    createSourceBuffer: function (mediaSource, codec) {\n        \"use strict\";\n\n        var buffer = null;\n\n        if (!mediaSource) {\n            return null;\n        }\n\n        try {\n            buffer = mediaSource.addSourceBuffer(codec);\n        } catch(ex) {\n            // For text track not supported by MSE, we try to create corresponding specific source buffer\n            if (this.manifestExt.getIsTextTrack(codec)) {\n                if ((codec === 'text/vtt') || (codec === 'text/ttml')) {\n                    buffer = this.system.getObject(\"textSourceBuffer\");\n                } else if (codec === 'application/ttml+xml+mp4' || codec === 'application/mp4' || codec === 'application/ttml+xml') {\n                    buffer = this.system.getObject(\"textTTMLXMLMP4SourceBuffer\");\n                } else {\n                    throw ex;\n                }\n            } else {\n                throw ex;\n            }\n        }\n        return buffer;\n    },\n\n    removeSourceBuffer: function (mediaSource, buffer) {\n        \"use strict\";\n        try {\n            mediaSource.removeSourceBuffer(buffer);\n        } catch (ex) {\n        }\n    },\n\n    getBufferRange: function (buffer, time, tolerance) {\n        \"use strict\";\n        var ranges = null,\n            start = 0,\n            end = 0,\n            firstStart = null,\n            lastEnd = null,\n            gap = 0,\n            toler = (tolerance || 0.03),\n            len,\n            i;\n\n        try {\n            ranges = buffer.buffered;\n        } catch(ex) {\n            return null;\n        }\n\n        if (ranges) {\n            for (i = 0, len = ranges.length; i < len; i += 1) {\n                start = ranges.start(i);\n                end = ranges.end(i);\n                if (firstStart === null) {\n                    gap = Math.abs(start - time);\n                    if (time >= start && time < end) {\n                        // start the range\n                        firstStart = start;\n                        lastEnd = end;\n                        continue;\n                    } else if (gap <= toler) {\n                        // start the range even though the buffer does not contain time 0\n                        firstStart = start;\n                        lastEnd = end;\n                        continue;\n                    }\n                } else {\n                    gap = start - lastEnd;\n                    if (gap <= toler) {\n                        // the discontinuity is smaller than the tolerance, combine the ranges\n                        lastEnd = end;\n                    } else {\n                        break;\n                    }\n                }\n            }\n\n            if (firstStart !== null) {\n                return {start: firstStart, end: lastEnd};\n            }\n        }\n\n        return null;\n    },\n\n    getAllRanges: function(buffer) {\n        var ranges = null;\n\n        try{\n            ranges = buffer.buffered;\n            return ranges;\n        } catch (ex) {\n            return null;\n        }\n    },\n\n    getBufferLength: function (buffer, time, tolerance) {\n        \"use strict\";\n\n        var self = this,\n            range,\n            length;\n\n        range = self.getBufferRange(buffer, time, tolerance);\n\n        if (range === null) {\n            length = 0;\n        } else {\n            length = range.end - time;\n        }\n\n        return length;\n    },\n\n    waitForUpdateEnd: function(buffer) {\n        \"use strict\";\n        var defer = Q.defer(),\n            intervalId,\n            CHECK_INTERVAL = 50,\n            checkIsUpdateEnded = function() {\n                // if updating is still in progress do nothing and wait for the next check again.\n                if (buffer.updating) {\n                    return;\n                }\n                // updating is completed, now we can stop checking and resolve the promise\n                clearInterval(intervalId);\n                defer.resolve(true);\n            },\n            updateEndHandler = function() {\n                if (buffer.updating) {\n                    return;\n                }\n\n                buffer.removeEventListener(\"updateend\", updateEndHandler, false);\n                defer.resolve(true);\n            };\n\n            if (!buffer.updating) {\n                defer.resolve(true);\n                return defer.promise;\n            }\n        // use updateend event if possible\n        if (typeof buffer.addEventListener === \"function\") {\n            try {\n                buffer.addEventListener(\"updateend\", updateEndHandler, false);\n            } catch (err) {\n                // use setInterval to periodically check if updating has been completed\n                intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);\n            }\n        } else {\n            // use setInterval to periodically check if updating has been completed\n            intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);\n        }\n\n        return defer.promise;\n    },\n\n    append: function (buffer, bytes, request) {\n        var deferred = Q.defer(),\n            self = this;\n\n        self.waitForUpdateEnd(buffer).then(function() {\n            try {\n                if (\"append\" in buffer) {\n                    buffer.append(bytes, request);\n                } else if (\"appendBuffer\" in buffer) {\n                    buffer.appendBuffer(bytes);\n                }\n\n                // updating is in progress, we should wait for it to complete before signaling that this operation is done\n                self.waitForUpdateEnd(buffer, request).then(\n                    function() {\n                        deferred.resolve();\n                    }\n                );\n            } catch (err) {\n                deferred.reject({err: err, data: bytes});\n            }\n        });\n\n        return deferred.promise;\n    },\n\n    remove: function (buffer, start, end, duration, mediaSource) {\n        var deferred = Q.defer(),\n            self = this;\n\n        self.waitForUpdateEnd(buffer).then(function() {\n            try {\n                // make sure that the given time range is correct. Otherwise we will get InvalidAccessError\n                if ((start >= 0) && (start < duration) && (end > start) && (mediaSource.readyState !== \"ended\")) {\n                    buffer.remove(start, end);\n                }\n\n                //workaround in order to remove all the cues in the textTrack from the video element.\n                //end parameter equals the video.duration. The use case of a dash stream with a full TTML subtitles file has an issue because video duration could be NaN. It occurs\n                //after the manifest has been parsed, a call to MediaSource.setDuration is made but after a few ms, a duration change event occurs with a value of NaN. The origin of this issue may be\n                //that no media segments have been pushed.\n                //So, all the buffer is removed.\n                if (isNaN(end) && (mediaSource.readyState !== \"ended\")) {\n                    buffer.remove(start);\n                }\n\n                // updating is in progress, we should wait for it to complete before signaling that this operation is done\n                self.waitForUpdateEnd(buffer).then(\n                    function() {\n                        deferred.resolve();\n                    }\n                );\n            } catch (err) {\n                deferred.reject(err);\n            }\n        });\n\n        return deferred.promise;\n    },\n\n    abort: function (mediaSource, buffer) {\n        \"use strict\";\n            try {\n                if (mediaSource.readyState === \"open\") {\n                    buffer.abort();\n                }\n            } catch(ex){\n            }\n    }\n};\n","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// Define Math.sign method in case it is not defined (like in IE11)\nif (!Math.sign) {\n    Math.sign = function(value) {\n        \"use strict\";\n        return (value < 0) ? -1 : ((value === 0) ? 0 : 1);\n    };\n}\n\nMediaPlayer.dependencies.Stream = function() {\n    \"use strict\";\n\n    var manifest,\n        mediaSource,\n        contentProtection = null,\n        videoController = null,\n        videoTrackIndex = -1,\n        audioController = null,\n        audioTrackIndex = -1,\n        textController = null,\n        subtitlesEnabled = false,\n        dvrStarted = false,\n        fragmentInfoVideoController = null,\n        fragmentInfoAudioController = null,\n        fragmentInfoTextController = null,\n\n        textTrackIndex = -1,\n        autoPlay = true,\n        initialized = false,\n        errored = false,\n\n        // Events listeners\n        endedListener,\n        loadedListener,\n        playListener,\n        pauseListener,\n        errorListener,\n        seekingListener,\n        seekedListener,\n        waitingListener,\n        timeupdateListener,\n        durationchangeListener,\n        progressListener,\n        ratechangeListener,\n        canplayListener,\n        playingListener,\n        loadstartListener,\n\n        // Audio/text languages\n        defaultAudioLang = 'und',\n        defaultSubtitleLang = 'und',\n\n        periodInfo = null,\n\n        // Initial start time\n        initialStartTime = -1,\n\n        // Play start time (= live edge for live streams)\n        playStartTime = -1,\n\n        // Programmatical seek\n        seekTime,\n        checkStartTimeIntervalId,\n\n        // trick mode variables\n        tmState = \"Stopped\",\n        tmSpeed = 1,\n        tmPreviousSpeed,\n        tmStartTime,\n        tmVideoStartTime,\n        tmMinSeekStep,\n        tmSeekStep,\n        tmSeekTime,\n        tmSeekTimeout,\n        tmSeekValue,\n        tmEndDetected = false,\n        muteState = false,\n\n        eventController = null,\n        protectionController,\n        initializeMediaSourceFinished = true,\n\n        reloadTimeout = null,\n        isReloading = false,\n\n        startClockTime = -1,\n        startStreamTime = -1,\n        visibilitychangeListener,\n\n        // ProtectionController events listener\n        onProtectionError = function(event) {\n            this.errHandler.sendError(event.data.code, event.data.message, event.data.data);\n        },\n\n        play = function() {\n            if (!initialized) {\n                return;\n            }\n\n            this.debug.info(\"[Stream] Play.\");\n            this.videoModel.play();\n        },\n\n        pause = function() {\n            this.debug.info(\"[Stream] Pause.\");\n            this.videoModel.pause();\n        },\n\n        seek = function(time, autoplay) {\n            if (!initialized) {\n                //this.debug.info(\"[Stream] (seek) not initialized\");\n                return;\n            }\n\n            this.debug.info(\"[Stream] Seek: \" + time);\n\n            // In case of live streams and then DVR seek, then we start the fragmentInfoControllers\n            // (check if seek not due to stream loading or reloading)\n            if (this.manifestExt.getIsDynamic(manifest) && !isReloading && (this.videoModel.getCurrentTime() !== 0)) {\n                startFragmentInfoControllers.call(this);\n            }\n\n            // Stream is starting playing => fills the buffers before setting <video> current time\n            if (autoplay === true) {\n                // 1- seeks the buffer controllers at the desired time\n                // 2- once data is present in the buffers, then we can set the current time to the <video> component (see onBufferUpdated())\n                seekTime = time;\n                this.system.unmapHandler(\"bufferUpdated\");\n                this.system.mapHandler(\"bufferUpdated\", undefined, onBufferUpdated.bind(this));\n                startBuffering.call(this, seekTime);\n            } else {\n                // Stream is already playing, simply seek the <video> component\n                this.videoModel.setCurrentTime(time);\n            }\n        },\n\n        // Media Source\n        setUpMediaSource = function(mediaSourceArg) {\n            var deferred = Q.defer(),\n                self = this,\n\n                onMediaSourceOpen = function( /*e*/ ) {\n                    //self.debug.log(\"MediaSource is open!\");\n\n                    mediaSourceArg.removeEventListener(\"sourceopen\", onMediaSourceOpen);\n                    mediaSourceArg.removeEventListener(\"webkitsourceopen\", onMediaSourceOpen);\n\n                    deferred.resolve(mediaSourceArg);\n                };\n\n            //self.debug.log(\"MediaSource should be closed. The actual readyState is: \" + mediaSourceArg.readyState);\n\n            mediaSourceArg.addEventListener(\"sourceopen\", onMediaSourceOpen, false);\n            mediaSourceArg.addEventListener(\"webkitsourceopen\", onMediaSourceOpen, false);\n\n            self.mediaSourceExt.attachMediaSource(mediaSourceArg, self.videoModel);\n\n            //self.debug.log(\"MediaSource attached to video.  Waiting on open...\");\n\n            return deferred.promise;\n        },\n\n        tearDownMediaSource = function() {\n            var self = this,\n                funcs = [],\n                deferred = Q.defer(),\n\n                executeReset = function() {\n                    if (!!videoController) {\n                        funcs.push(videoController.reset(errored));\n                    }\n\n                    if (!!fragmentInfoVideoController) {\n                        funcs.push(fragmentInfoVideoController.reset(errored));\n                    }\n\n                    if (!!audioController) {\n                        funcs.push(audioController.reset(errored));\n                    }\n\n                    if (!!fragmentInfoAudioController) {\n                        funcs.push(fragmentInfoAudioController.reset(errored));\n                    }\n\n                    if (!!textController) {\n                        funcs.push(textController.reset(errored));\n                    }\n\n                    if (!!fragmentInfoTextController) {\n                        funcs.push(fragmentInfoTextController.reset(errored));\n                    }\n\n                    Q.all(funcs).then(\n                        function() {\n                            if (!!eventController) {\n                                eventController.reset();\n                                eventController = undefined;\n                            }\n\n                            if (!!mediaSource) {\n                                self.mediaSourceExt.detachMediaSource(self.videoModel);\n                            }\n\n                            initialized = false;\n\n                            contentProtection = null;\n\n                            videoController = null;\n                            audioController = null;\n                            textController = null;\n\n                            mediaSource = null;\n                            manifest = null;\n\n                            deferred.resolve();\n                        });\n                };\n\n\n            Q.when(initializeMediaSourceFinished).then(\n                function() {\n                    executeReset();\n                });\n            return deferred.promise;\n        },\n\n        createBufferController = function(data, codec) {\n            var bufferController = null,\n                buffer = null;\n\n            // Check if codec is supported (applies only for video and audio)\n            if (data.type === 'video' || data.type === 'audio') {\n                if (!this.capabilities.supportsCodec(this.videoModel.getElement(), codec)) {\n                    this.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CODEC_UNSUPPORTED, 'Codec is not supported (HTMLMediaElement)', {\n                        codec: codec\n                    });\n                    return null;\n                }\n            }\n\n            // Create SourceBuffer\n            try {\n                buffer = this.sourceBufferExt.createSourceBuffer(mediaSource, codec);\n            } catch (ex) {\n                this.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CREATE_SOURCEBUFFER, 'Failed to create ' + data.type + ' source buffer',\n                    new MediaPlayer.vo.Error(ex.code, ex.name, ex.message));\n                return null;\n            }\n\n            // Create and initialize BufferController\n            bufferController = this.system.getObject(\"bufferController\");\n            bufferController.initialize(data.type, periodInfo, data, buffer, this.fragmentController, mediaSource, eventController);\n\n            if (data.type === 'text' && buffer.hasOwnProperty('initialize')) {\n                buffer.initialize(codec, bufferController, data);\n            }\n\n            return bufferController;\n        },\n\n        createFragmentInfoController = function(bufferController, data) {\n            var fragmentInfoController = null;\n\n            if (bufferController && data && data.type) {\n                fragmentInfoController = this.system.getObject(\"fragmentInfoController\");\n                fragmentInfoController.initialize(data.type, this.fragmentController, bufferController);\n            }\n\n            return fragmentInfoController;\n        },\n\n        initializeProtectionController = function () {\n            var deferred = null,\n                data,\n                audioCodec = null,\n                videoCodec = null,\n                ksSelected,\n                self = this;\n\n            data = this.manifestExt.getVideoData(manifest, periodInfo.index);\n            if (data) {\n                videoCodec = this.manifestExt.getCodec(data);\n                contentProtection = this.manifestExt.getContentProtectionData(data);\n            }\n            data = this.manifestExt.getSpecificAudioData(manifest, periodInfo.index, defaultAudioLang);\n            if (data) {\n                audioCodec = this.manifestExt.getCodec(data);\n            }\n\n            if (!contentProtection) {\n                return Q.when(true);\n            }\n\n            if (!this.capabilities.supportsEncryptedMedia()) {\n                // No protectionController (MediaKeys not supported/enabled) but content is protected => error\n                this.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.CAPABILITY_ERR_MEDIAKEYS, \"EME is not supported/enabled\", null);\n                return Q.when(false);\n            }\n\n            if (!protectionController) {\n                return Q.when(true);\n            }\n\n            deferred = Q.defer();\n\n            ksSelected = {};\n            ksSelected[MediaPlayer.dependencies.ProtectionController.eventList.ENAME_KEY_SYSTEM_SELECTED] = function(/*event*/) {\n                self.debug.log(\"[Stream] ProtectionController initialized\");\n                protectionController.unsubscribe(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_KEY_SYSTEM_SELECTED, ksSelected);\n                deferred.resolve(true);\n            };\n            protectionController.subscribe(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_KEY_SYSTEM_SELECTED, ksSelected);\n            this.debug.log(\"[Stream] Initialize ProtectionController\");\n            protectionController.init(contentProtection, audioCodec, videoCodec);\n\n            return deferred.promise;\n        },\n\n        initializeMediaSource = function() {\n            var data,\n                videoCodec,\n                audioCodec,\n                textMimeType;\n\n            if (!manifest) {\n                return;\n            }\n\n            initializeMediaSourceFinished = false;\n            eventController = this.system.getObject(\"eventController\");\n\n            // Initialize video BufferController\n            data = this.manifestExt.getVideoData(manifest, periodInfo.index);\n\n            if (data === null) {\n                this.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.MANIFEST_ERR_NO_VIDEO, 'No Video data in manifest');\n            } else {\n                filterCodecs.call(this, data);\n                videoTrackIndex = this.manifestExt.getDataIndex(data, manifest, periodInfo.index);\n                videoCodec = this.manifestExt.getCodec(data);\n                contentProtection = this.manifestExt.getContentProtectionData(data);\n\n                if (videoCodec === null) {\n                    this.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CODEC_UNSUPPORTED, 'Video codec information not available', {codec: ''});\n                } else {\n                    videoController = createBufferController.call(this, data, videoCodec);\n                    if (this.manifestExt.getIsDynamic(manifest)) {\n                        fragmentInfoVideoController = createFragmentInfoController.call(this, videoController, data);\n                    }\n                }\n            }\n\n            // Abort if no video controller\n            if (videoController === null) {\n                initializeMediaSourceFinished = true;\n                return;\n            }\n\n            // Initialize audio BufferController\n            data = this.manifestExt.getSpecificAudioData(manifest, periodInfo.index, defaultAudioLang);\n\n            if (data === null) {\n                this.errHandler.sendWarning(MediaPlayer.dependencies.ErrorHandler.prototype.MANIFEST_ERR_NO_AUDIO, \"No audio data in manifest\");\n            } else {\n                filterCodecs.call(this, data);\n                audioTrackIndex = this.manifestExt.getDataIndex(data, manifest, periodInfo.index);\n                audioCodec = this.manifestExt.getCodec(data);\n\n                if (audioCodec === null) {\n                    this.errHandler.sendWarning(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CODEC_UNSUPPORTED, 'Audio codec information not available', {codec: ''});\n                } else {\n                    audioController = createBufferController.call(this, data, audioCodec);\n\n                    // Abort if audio track defined but failed to create audio controller\n                    if (audioController === null) {\n                        initializeMediaSourceFinished = true;\n                        return;\n                    }\n\n                    if (this.manifestExt.getIsDynamic(manifest)) {\n                        fragmentInfoAudioController = createFragmentInfoController.call(this, audioController, data);\n                    }\n                }\n            }\n\n            // Initialize text BufferController\n            data = this.manifestExt.getSpecificTextData(manifest, periodInfo.index, defaultSubtitleLang);\n\n            if (data !== null) {\n                textTrackIndex = this.manifestExt.getDataIndex(data, manifest, periodInfo.index);\n                textMimeType = this.manifestExt.getMimeType(data);\n\n                if (textMimeType === null) {\n                    this.errHandler.sendWarning(MediaPlayer.dependencies.ErrorHandler.prototype.MANIFEST_ERR_NO_TEXT, \"Text codec information not available\");\n                } else {\n                    textController = createBufferController.call(this, data, textMimeType);\n                    if (this.manifestExt.getIsDynamic(manifest)) {\n                        fragmentInfoTextController = createFragmentInfoController.call(this, textController, data);\n                    }\n                }\n            }\n\n            // Initialize EventController\n            if (eventController) {\n                eventController.addInlineEvents(this.manifestExt.getEventsForPeriod(manifest, periodInfo));\n            }\n\n            initializeMediaSourceFinished = true;\n            return;\n        },\n\n        initializePlayback = function() {\n            this.debug.log(\"[Stream] Setting duration: \" + periodInfo.duration);\n            this.mediaSourceExt.setDuration(mediaSource, periodInfo.duration);\n            initialized = true;\n        },\n\n        startFragmentInfoControllers = function() {\n            if (manifest.name !== 'MSS' || !this.manifestExt.getIsDynamic(manifest)) {\n                return;\n            }\n\n            if (fragmentInfoVideoController && dvrStarted === false) {\n                dvrStarted = true;\n                fragmentInfoVideoController.start();\n            }\n\n            if (fragmentInfoAudioController) {\n                fragmentInfoAudioController.start();\n            }\n\n            if (fragmentInfoTextController && subtitlesEnabled) {\n                fragmentInfoTextController.start();\n            }\n        },\n\n        stopFragmentInfoControllers = function() {\n            if (fragmentInfoVideoController) {\n                dvrStarted = false;\n                fragmentInfoVideoController.stop();\n            }\n\n            if (fragmentInfoAudioController) {\n                fragmentInfoAudioController.stop();\n            }\n\n            if (fragmentInfoTextController) {\n                fragmentInfoTextController.stop();\n            }\n        },\n\n        onLoaded = function() {\n            this.debug.info(\"[Stream] <video> loadedmetadata event\");\n        },\n\n        onCanPlay = function() {\n            this.debug.info(\"[Stream] <video> canplay event\");\n        },\n\n        onPlaying = function() {\n            this.debug.info(\"[Stream] <video> playing event\");\n\n            this.metricsModel.addState(\"video\", \"playing\", this.getVideoModel().getCurrentTime());\n\n            // Store start time (clock and stream time) for resynchronization purpose\n            startClockTime = new Date().getTime() / 1000;\n            startStreamTime = this.getVideoModel().getCurrentTime();\n        },\n\n        onLoadStart = function() {\n            this.debug.info(\"[Stream] <video> loadstart event\");\n        },\n\n        onPlay = function() {\n            this.debug.info(\"[Stream] <video> play event\");\n\n            //listen pause event to have correct metrics, it should be unlistened by the onBufferingCompleted callback.\n            this.videoModel.listen(\"pause\", pauseListener);\n\n            if (tmSpeed !== 1) {\n                this.setTrickModeSpeed(1);\n            } else {\n                // Set the currentTime here to be sure that videoTag is ready to accept the seek (cause IE fail on set currentTime on BufferUpdate)\n                if (playStartTime >= 0) {\n                    setVideoModelCurrentTime.call(this, playStartTime);\n                    playStartTime = -1;\n                } else {\n                    startBuffering.call(this);\n                }\n            }\n\n            this.metricsModel.addPlayList(\"video\", new Date().getTime(), this.videoModel.getCurrentTime(), \"play\");\n        },\n\n        // ORANGE : ended event\n        onEnded = function() {\n            this.debug.info(\"[Stream] <video> ended event\");\n            //add stopped state metric with reason = 1 : end of stream\n            this.metricsModel.addState(\"video\", \"stopped\", this.videoModel.getCurrentTime(), 1);\n        },\n\n        onPause = function() {\n            this.debug.info(\"[Stream] <video> pause event\");\n            startClockTime = -1;\n            startStreamTime = -1;\n            if (tmSpeed === 1) {\n                // ORANGE : add metric\n                this.metricsModel.addState(\"video\", \"paused\", this.videoModel.getCurrentTime());\n                this.metricsModel.addPlayList(\"video\", new Date().getTime(), this.videoModel.getCurrentTime(), \"pause\");\n            }\n            suspend.call(this);\n            if (manifest.name === 'MSS' && this.manifestExt.getIsDynamic(manifest)) {\n                startFragmentInfoControllers.call(this);\n            }\n        },\n\n        onError = function(event) {\n            var error = event.target.error,\n                code,\n                message = \"[Stream] <video> error: \";\n\n            if (error.code === -1) {\n                // not an error!\n                return;\n            }\n\n            switch (error.code) {\n                case 1:\n                    code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_ABORTED;\n                    message += \"fetching process aborted\";\n                    break;\n                case 2:\n                    code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_NETWORK;\n                    message += \"network error\";\n                    break;\n                case 3:\n                    code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_DECODE;\n                    message += \"media decoding error\";\n                    break;\n                case 4:\n                    code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_SRC_NOT_SUPPORTED;\n                    message += \"media format not supported\";\n                    break;\n                case 5:\n                    code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_ENCRYPTED;\n                    message += \"media is encrypted\";\n                    break;\n            }\n\n            errored = true;\n\n            this.errHandler.sendError(code, message);\n        },\n\n        onSeeking = function() {\n            var time = this.videoModel.getCurrentTime();\n\n            this.debug.info(\"[Stream] <video> seeking event: \" + time);\n\n            // Check if seeking is different from trick mode seeking, then cancel trick mode\n            if ((tmSpeed !== 1) && (time.toFixed(3) !== tmSeekValue.toFixed(3))) {\n                this.setTrickModeSpeed(1);\n                return;\n            }\n\n            // Check if seek time is less than range start, never seek before range start.\n            time = (time < this.getStartTime()) ? this.getStartTime() : time;\n\n            if (tmSpeed === 1) {\n                this.metricsModel.addState(\"video\", \"seeking\", this.getVideoModel().getCurrentTime());\n                this.metricsModel.addPlayList('video', new Date().getTime(), time, MediaPlayer.vo.metrics.PlayList.SEEK_START_REASON);\n            }\n\n            startBuffering.call(this, time);\n        },\n\n        onSeeked = function() {\n            var self = this,\n                currentTime,\n                currentVideoTime,\n                elapsedTime,\n                elapsedSeekTime,\n                elapsedVideoTime,\n                speed,\n                ratio = 0.9,\n                seekValue,\n                videoEndedEvent,\n                delay,\n                _seek = function(delay, seekValue) {\n                    if (self.videoModel.getCurrentTime() === self.getStartTime() || tmEndDetected) {\n                        self.debug.log(\"[Stream] Trick mode (x\" + tmSpeed + \"): stop\");\n                        if (tmEndDetected) {\n                            videoEndedEvent = document.createEvent(\"Event\");\n                            videoEndedEvent.initEvent(\"ended\", true, true);\n                            self.videoModel.getElement().dispatchEvent(videoEndedEvent);\n                        }\n                        return;\n                    }\n                    if (seekValue < self.getStartTime()) {\n                        seekValue = self.getStartTime();\n                    } else if (seekValue >= self.videoModel.getDuration()) {\n                        seekValue = self.videoModel.getDuration() - tmMinSeekStep;\n                        tmEndDetected = true;\n                    }\n                    if (delay > 0) {\n                        self.debug.log(\"[Stream] Trick mode (x\" + tmSpeed + \"): wait \" + delay.toFixed(3) + \" s\");\n                    }\n                    tmSeekTimeout = setTimeout(function() {\n                        tmSeekTime = new Date().getTime() / 1000;\n                        self.debug.log(\"[Stream] Trick mode (x\" + tmSpeed + \"): seek time = \" + seekValue.toFixed(3));\n                        tmSeekValue = seekValue;\n                        self.videoModel.setCurrentTime(seekValue);\n                    }, delay > 0 ? (delay * 1000) : 0);\n                };\n\n            this.debug.info(\"[Stream] <video> seeked event\");\n\n            // Notify BufferControllers that video has seeked\n            seekedBuffers.call(this);\n\n            // Trick mode\n            if (tmSpeed !== 1) {\n\n                currentTime = (new Date().getTime()) / 1000;\n                currentVideoTime = self.videoModel.getCurrentTime();\n                elapsedTime = currentTime - tmStartTime;\n                elapsedSeekTime = currentTime - tmSeekTime;\n                elapsedVideoTime = Math.abs(currentVideoTime - tmVideoStartTime);\n                speed = (elapsedVideoTime / elapsedTime);\n\n                self.debug.log(\"[Stream] Trick mode (x\" + tmSpeed + \"): elapsed time = \" + elapsedTime.toFixed(3) + \", elapsed video time = \" + elapsedVideoTime.toFixed(3) + \", speed = \" + speed.toFixed(3));\n\n                if (tmState === \"Changed\") {\n                    clearTimeout(tmSeekTimeout);\n                    // Target speed changed => reset start times, and seek\n                    tmState = \"Running\";\n                    tmStartTime = (new Date().getTime()) / 1000;\n                    tmVideoStartTime = currentVideoTime;\n                    self.debug.info(\"[Stream] Trick mode (x\" + tmSpeed + \"): videoTime = \" + tmVideoStartTime);\n                    //if trick mode speed has decreased, we have to decrease tmSeekStep\n                    tmSeekStep = Math.abs(tmPreviousSpeed / tmSpeed) > 1 ? tmSeekStep / Math.abs(tmPreviousSpeed / tmSpeed) : tmSeekStep;\n                    seekValue = currentVideoTime + (tmSeekStep * Math.sign(tmSpeed));\n                    delay = 0;\n                } else if (speed < (Math.abs(tmSpeed) * ratio)) {\n                    // Measured speed < target speed => increase seek step\n                    var speedRatio = Math.abs(tmSpeed / speed);\n                    tmSeekStep *= Math.round(speedRatio) + Math.round(speedRatio % tmMinSeekStep);\n                    self.debug.info(\"[Stream] Trick mode (x\" + tmSpeed + \"): seek step = \" + tmSeekStep);\n                    seekValue = currentVideoTime + (tmSeekStep * Math.sign(tmSpeed));\n                    delay = 0;\n                } else {\n                    // Measured speed > target speed => wait before next seek\n                    seekValue = currentVideoTime + (tmSeekStep * Math.sign(tmSpeed));\n                    delay = (Math.abs(seekValue - tmVideoStartTime) / Math.abs(tmSpeed)) - elapsedTime - elapsedSeekTime;\n                }\n\n                _seek.call(self, delay, seekValue);\n\n            }\n\n            // The current time has been changed on video model, then reactivate 'seeking' event listener\n            // (see setVideoModelCurrentTime())\n            this.videoModel.listen(\"seeking\", seekingListener);\n\n            isReloading = false;\n            startClockTime = -1;\n            startStreamTime = -1;\n        },\n\n        onProgress = function() {\n            this.debug.info(\"[Stream] <video> progress event\");\n            updateBuffer.call(this);\n        },\n\n        onTimeupdate = function() {\n            this.debug.info(\"[Stream] <video> timeupdate event: \" + this.videoModel.getCurrentTime());\n            updateBuffer.call(this);\n        },\n\n        onWaiting = function() {\n            this.debug.info(\"[Stream] <video> waiting event\");\n            if (!this.getVideoModel().isSeeking()) {\n                this.metricsModel.addState(\"video\", \"buffering\", this.getVideoModel().getCurrentTime());\n            }\n        },\n\n        onDurationchange = function() {\n            var duration = this.videoModel.getDuration();\n\n            this.debug.info(\"[Stream] <video> durationchange event: \" + duration);\n        },\n\n        onRatechange = function() {\n            this.debug.info(\"[Stream] <video> ratechange event: \" + this.videoModel.getPlaybackRate());\n            if (videoController) {\n                videoController.updateStalledState();\n            }\n            if (audioController) {\n                audioController.updateStalledState();\n            }\n            if (textController) {\n                textController.updateStalledState();\n            }\n        },\n\n        onReload = function() {\n\n            // Ask for manifest refresh\n            // Then, once manifest has been refresh and data updated, we reload session (see updateData())\n            pause.call(this);\n            isReloading = true;\n            this.system.notify(\"manifestUpdate\", true);\n        },\n\n        updateBuffer = function() {\n\n            if (videoController) {\n                videoController.updateBufferLevel(true);\n            }\n\n            if (audioController) {\n                audioController.updateBufferLevel(true);\n            }\n\n            if (textController) {\n                textController.updateBufferLevel(true);\n            }\n        },\n\n        startBuffering = function(time) {\n            this.debug.log(\"[Stream] startBuffering\" + ((time === undefined) ? \"\" : (\" at time \" + time)));\n\n            if (videoController) {\n                if (time === undefined) {\n                    videoController.start();\n                } else {\n                    videoController.seek(time);\n                }\n            }\n\n            if (audioController) {\n                if (time === undefined) {\n                    audioController.start();\n                } else {\n                    audioController.seek(time);\n                }\n            }\n\n            if (textController && subtitlesEnabled && tmSpeed === 1) {\n                if (time === undefined) {\n                    textController.start();\n                } else {\n                    textController.seek(time);\n                }\n            }\n        },\n\n        stopBuffering = function() {\n            this.debug.log(\"[Stream] stopBuffering\");\n\n            if (videoController) {\n                videoController.stop();\n            }\n\n            if (audioController) {\n                audioController.stop();\n            }\n\n            if (textController) {\n                textController.stop();\n            }\n        },\n\n        seekedBuffers = function() {\n            if (videoController) {\n                videoController.seeked();\n            }\n            if (audioController) {\n                audioController.seeked();\n            }\n            if (textController) {\n                textController.seeked();\n            }\n        },\n\n        suspend = function() {\n            if (!this.scheduleWhilePaused || this.manifestExt.getIsDynamic(manifest)) {\n                stopBuffering.call(this);\n            }\n\n            clearInterval(checkStartTimeIntervalId);\n        },\n\n        doLoad = function(manifestResult) {\n\n            var self = this;\n\n            //self.debug.log(\"Stream start loading.\");\n\n            manifest = manifestResult;\n            self.debug.log(\"[Stream] Create MediaSource\");\n\n            try {\n                mediaSource = self.mediaSourceExt.createMediaSource();\n            } catch (error) {\n                self.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CREATE_MEDIASOURCE, \"Failed to create MediaSource\", {\n                    name: error.name,\n                    message: error.message\n                });\n            }\n\n            if (mediaSource === null) {\n                return;\n            }\n\n            initializeProtectionController.call(self).then(function() {\n                self.debug.log(\"[Stream] Setup MediaSource\");\n                setUpMediaSource.call(self, mediaSource).then(\n                    function(mediaSourceResult) {\n                        mediaSource = mediaSourceResult;\n                        self.debug.log(\"[Stream] Initialize MediaSource\");\n                        initializeMediaSource.call(self);\n                        self.debug.log(\"[Stream] Initialize playback\");\n                        initializePlayback.call(self);\n                        self.debug.log(\"[Stream] Playback initialized\");\n                    }\n                );\n            });\n        },\n\n        setVideoModelCurrentTime = function(time) {\n            this.debug.log(\"[Stream] Set video model current time: \" + time);\n            this.videoModel.unlisten(\"seeking\", seekingListener);\n            this.videoModel.setCurrentTime(time);\n        },\n\n        onBufferingCompleted = function() {\n\n            // if there is at least one buffer controller that has not completed buffering yet do nothing\n            if ((videoController && !videoController.isBufferingCompleted()) || (audioController && !audioController.isBufferingCompleted())) {\n                return;\n            }\n\n            // buffering has been complted, now we can signal end of stream\n            if (mediaSource) {\n                //unlisten pause event to have correct metrics, and not catch the pause event sent before the onded event\n                this.videoModel.unlisten(\"pause\", pauseListener);\n                this.debug.info(\"[Stream] Signal end of stream\");\n                this.mediaSourceExt.signalEndOfStream(mediaSource);\n            }\n        },\n\n        // 'startTimeFound' event raised by video controller when start time has been found\n        // startTime = video live edge for live streams\n        // startTime = first video segment time for static streams\n        // => then seek every BufferController at the found start time\n        onStartTimeFound = function(startTime) {\n            this.debug.info(\"[Stream] Start time = \" + startTime);\n            // Check if initial start time is set, then overload start time\n            if (initialStartTime !== -1 &&\n                !this.manifestExt.getIsDynamic(manifest) &&\n                initialStartTime < periodInfo.duration) {\n                this.debug.info(\"[Stream] Initial start time = \" + initialStartTime);\n                startTime = initialStartTime;\n            }\n            seek.call(this, startTime, (periodInfo.index === 0) && autoPlay);\n        },\n\n        // ORANGE: 'bufferUpdated' event raised when some data has been appended into media buffers\n        // => if not started (live use case) then check for playback start time and do play\n        onBufferUpdated = function() {\n            var videoRange,\n                audioRange,\n                startTime;\n\n            this.debug.info(\"[Stream] Check start time\");\n\n            // Check if video buffer is not empty\n            videoRange = this.sourceBufferExt.getBufferRange(videoController.getBuffer(), seekTime, videoController.getSegmentDuration());\n            if (videoRange === null) {\n                return;\n            }\n\n            startTime = Math.max(seekTime, videoRange.start);\n\n            if (audioController) {\n                // Check if audio buffer is not empty\n                audioRange = this.sourceBufferExt.getBufferRange(audioController.getBuffer(), seekTime, audioController.getSegmentDuration());\n                if (audioRange === null) {\n                    return;\n                }\n                this.debug.info(\"[Stream] Check start time: A[\" + audioRange.start + \"-\" + audioRange.end + \"], V[\" + videoRange.start + \"-\" + videoRange.end + \"]\");\n                // Check if audio and video can be synchronized (if some audio sample is available at returned start time)\n                if (audioRange.end < startTime) {\n                    return;\n                }\n                startTime = Math.max(startTime, audioRange.start);\n            }\n\n            this.debug.info(\"[Stream] Check start time: OK => \" + startTime);\n\n            // Unmap \"bufferUpdated\" handler\n            this.system.unmapHandler(\"bufferUpdated\");\n\n            // Set current time on video if 'play' event has already been raised.\n            // If 'play' event has not yet been raised, the the current time will be set afterwards\n            if (!this.videoModel.isPaused()) {\n                setVideoModelCurrentTime.call(this, startTime);\n            } else {\n                playStartTime = startTime;\n            }\n\n            play.call(this);\n        },\n\n        selectTrack = function(controller, track, currentIndex) {\n            var index = -1;\n\n            if (!controller) {\n                return currentIndex;\n            }\n\n            if (currentIndex === -1) {\n                return currentIndex;\n            }\n\n            // Get data index corresponding to the new selected track\n            index = this.manifestExt.getDataIndex(track, manifest, periodInfo.index);\n\n            // Check if different track selected\n            if (index !== currentIndex) {\n                if (manifest.name === 'MSS' && this.manifestExt.getIsDynamic(manifest)) {\n                    // If live MSS, refresh the manifest to get new selected track segments info\n                    this.system.notify(\"manifestUpdate\");\n                } else {\n                    // Else update controller data directly\n                    controller.updateData(track, periodInfo);\n                }\n            }\n\n            return index;\n        },\n\n        filterCodecs = function(data) {\n            var codec,\n                i;\n            // Filter codecs that are not supported\n            // But keep at least codec from lowest representation\n            i = 1;\n            while (i < data.Representation_asArray.length) {\n                codec = this.manifestExt.getCodecForRepresentation(data.Representation_asArray[i]);\n                if (codec) {\n                    if (!this.capabilities.supportsCodec(this.videoModel.getElement(), codec)) {\n                        this.debug.warn('[Stream] codec not supported: ' + codec);\n                        data.Representation_asArray.splice(i, 1);\n                        i--;\n                    }\n                }\n                i++;\n            }\n        },\n\n        updateData = function(updatedPeriodInfo) {\n            var videoData,\n                data;\n\n            manifest = this.manifestModel.getValue();\n            periodInfo = updatedPeriodInfo;\n            this.debug.log(\"[Stream] Manifest updated ... set new data on buffers.\");\n\n            if (videoController) {\n                videoData = videoController.getData();\n\n                if (!!videoData && videoData.hasOwnProperty(\"id\")) {\n                    data = this.manifestExt.getDataForId(videoData.id, manifest, periodInfo.index);\n                } else {\n                    data = this.manifestExt.getDataForIndex(videoTrackIndex, manifest, periodInfo.index);\n                }\n                filterCodecs.call(this, data);\n                videoController.updateData(data, periodInfo);\n            }\n\n            if (audioController) {\n                data = this.manifestExt.getDataForIndex(audioTrackIndex, manifest, periodInfo.index);\n                filterCodecs.call(this, data);\n                audioController.updateData(data, periodInfo);\n            }\n\n            if (textController) {\n                data = this.manifestExt.getDataForIndex(textTrackIndex, manifest, periodInfo.index);\n                textController.updateData(data, periodInfo);\n            }\n\n            if (eventController) {\n                var events = this.manifestExt.getEventsForPeriod(manifest, periodInfo);\n                eventController.addInlineEvents(events);\n            }\n\n            if (isReloading && videoController) {\n                this.system.unmapHandler(\"bufferUpdated\");\n                this.system.mapHandler(\"bufferUpdated\", undefined, onBufferUpdated.bind(this));\n                // Call load on video controller in order to get new stream start time (=live edge for live streams)\n                videoController.load();\n            }\n\n            if (dvrStarted) {\n                startFragmentInfoControllers.call(this);\n            }\n        },\n\n        streamsComposed = function() {\n            var time = this.videoModel.getCurrentTime();\n            textController.seek(time);\n            textController.seeked();\n        },\n\n        // Called when a BufferController failed to download or buffer a segment\n        onSegmentLoadingFailed = function(segmentRequest) {\n            var self = this;\n\n            this.debug.log(\"[Stream] Segment loading failed: start time = \" + segmentRequest.startTime + \", duration = \" + segmentRequest.duration);\n\n            if (this.manifestExt.getIsDynamic(manifest) && reloadTimeout === null) {\n                // For Live streams, then we try to reload the session\n                isReloading = true;\n                var delay = segmentRequest.duration;\n                this.debug.info(\"[Stream] Reload session in \" + delay + \" s.\");\n                reloadTimeout = setTimeout(function() {\n                    reloadTimeout = null;\n                    //pause.call(self);\n                    isReloading = true;\n                    self.debug.info(\"[Stream] Reload session (update manifest)\");\n                    self.system.notify(\"manifestUpdate\", true);\n                    stopFragmentInfoControllers.call(self);\n                }, delay * 1000);\n            } else {\n                // For VOD streams, we seek at recovery time\n                seek.call(this, (segmentRequest.startTime + segmentRequest.duration));\n            }\n        },\n\n        onVisibilitychange = function() {\n\n            if (document.hidden === true || startClockTime === -1) {\n                return;\n            }\n\n            // If current document get focus back, then check if resynchronization is required\n            var clockTime = new Date().getTime() / 1000,\n                streamTime = this.getVideoModel().getCurrentTime(),\n                elapsedClockTime = clockTime - startClockTime,\n                elapsedStreamTime = streamTime - startStreamTime;\n\n            this.debug.log(\"[Stream] VisibilityChange: elapsedClockTime = \" + elapsedClockTime + \", elapsedStreamTime = \" + elapsedStreamTime + \" (\" + (elapsedClockTime - elapsedStreamTime) + \")\");\n\n            if ((elapsedClockTime - elapsedStreamTime) > 1) {\n                onReload.call(this);\n            }\n\n        };\n\n    return {\n        system: undefined,\n        videoModel: undefined,\n        manifestLoader: undefined,\n        manifestModel: undefined,\n        mediaSourceExt: undefined,\n        sourceBufferExt: undefined,\n        manifestExt: undefined,\n        fragmentController: undefined,\n        fragmentExt: undefined,\n        protectionExt: undefined,\n        capabilities: undefined,\n        debug: undefined,\n        metricsExt: undefined,\n        errHandler: undefined,\n        timelineConverter: undefined,\n        scheduleWhilePaused: undefined,\n        textTrackExtensions: undefined,\n        // ORANGE : add metricsModel\n        metricsModel: undefined,\n        eventBus: undefined,\n        notify: undefined,\n\n        setup: function() {\n            this.system.mapHandler(\"startTimeFound\", undefined, onStartTimeFound.bind(this));\n            this.system.mapHandler(\"segmentLoadingFailed\", undefined, onSegmentLoadingFailed.bind(this));\n            this.system.mapHandler(\"bufferingCompleted\", undefined, onBufferingCompleted.bind(this));\n\n            /* @if PROTECTION=true */\n            // Protection event handlers\n            this[MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR] = onProtectionError.bind(this);\n            /* @endif */\n\n            playListener = onPlay.bind(this);\n            pauseListener = onPause.bind(this);\n            errorListener = onError.bind(this);\n            seekingListener = onSeeking.bind(this);\n            seekedListener = onSeeked.bind(this);\n            waitingListener = onWaiting.bind(this);\n            progressListener = onProgress.bind(this);\n            ratechangeListener = onRatechange.bind(this);\n            timeupdateListener = onTimeupdate.bind(this);\n            durationchangeListener = onDurationchange.bind(this);\n            loadedListener = onLoaded.bind(this);\n            canplayListener = onCanPlay.bind(this);\n            playingListener = onPlaying.bind(this);\n            loadstartListener = onLoadStart.bind(this);\n\n            // ORANGE : add Ended Event listener\n            endedListener = onEnded.bind(this);\n\n            visibilitychangeListener = onVisibilitychange.bind(this);\n        },\n\n        load: function(manifest, periodInfoValue) {\n            periodInfo = periodInfoValue;\n            doLoad.call(this, manifest);\n        },\n\n        setVideoModel: function(value) {\n            this.videoModel = value;\n            this.videoModel.listen(\"play\", playListener);\n            this.videoModel.listen(\"pause\", pauseListener);\n            this.videoModel.listen(\"error\", errorListener);\n            this.videoModel.listen(\"seeking\", seekingListener);\n            this.videoModel.listen(\"seeked\", seekedListener);\n            this.videoModel.listen(\"waiting\", waitingListener);\n            this.videoModel.listen(\"timeupdate\", timeupdateListener);\n            this.videoModel.listen(\"durationchange\", durationchangeListener);\n            this.videoModel.listen(\"progress\", progressListener);\n            this.videoModel.listen(\"ratechange\", ratechangeListener);\n            this.videoModel.listen(\"loadedmetadata\", loadedListener);\n            this.videoModel.listen(\"ended\", endedListener);\n            this.videoModel.listen(\"canplay\", canplayListener);\n            this.videoModel.listen(\"playing\", playingListener);\n            this.videoModel.listen(\"loadstart\", loadstartListener);\n\n            //document.addEventListener(\"visibilitychange\", visibilitychangeListener);\n        },\n\n        setInitialStartTime: function(startTime) {\n            var time = parseFloat(startTime);\n            if (!isNaN(time)) {\n                initialStartTime = time;\n            }\n        },\n\n        getAudioTracks: function() {\n            return this.manifestExt.getAudioDatas(manifest, periodInfo.index);\n        },\n\n        setAudioTrack: function(audioTrack) {\n            if (fragmentInfoAudioController) {\n                fragmentInfoAudioController.stop();\n            }\n            audioTrackIndex = selectTrack.call(this, audioController, audioTrack, audioTrackIndex);\n        },\n\n        getSelectedAudioTrack: function() {\n            if (audioController) {\n                return this.manifestExt.getDataForIndex(audioTrackIndex, manifest, periodInfo.index);\n            }\n            return undefined;\n        },\n\n        getSubtitleTracks: function() {\n            return this.manifestExt.getTextDatas(manifest, periodInfo.index);\n        },\n\n        setSubtitleTrack: function(subtitleTrack) {\n            if (fragmentInfoTextController) {\n                fragmentInfoTextController.stop();\n            }\n            textTrackIndex = selectTrack.call(this, textController, subtitleTrack, textTrackIndex);\n        },\n\n        getSelectedSubtitleTrack: function() {\n            if (textController && subtitlesEnabled) {\n                return this.manifestExt.getDataForIndex(textTrackIndex, manifest, periodInfo.index);\n            }\n            return undefined;\n        },\n\n        initProtection: function(protectionCtrl) {\n            protectionController = protectionCtrl;\n            if (protectionController) {\n                protectionController.subscribe(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR, this);\n            }\n        },\n\n        getVideoModel: function() {\n            return this.videoModel;\n        },\n\n        getManifestExt: function() {\n            var self = this;\n            return self.manifestExt;\n        },\n\n        setAutoPlay: function(value) {\n            autoPlay = value;\n        },\n\n        setDefaultAudioLang: function(language) {\n            defaultAudioLang = language;\n        },\n\n        setDefaultSubtitleLang: function(language) {\n            defaultSubtitleLang = language;\n        },\n\n        getAutoPlay: function() {\n            return autoPlay;\n        },\n\n        reset: function() {\n            var deferred = Q.defer(),\n                self = this;\n\n            this.debug.info(\"[Stream] Reset\");\n\n            stopBuffering.call(this);\n\n            stopFragmentInfoControllers.call(this);\n\n            pause.call(this);\n\n            // Trick mode seeking timeout\n            clearTimeout(tmSeekTimeout);\n\n            // Stop reload timeout\n            clearTimeout(reloadTimeout);\n\n            //if player is in trick mode, restore mute state.\n            if (tmSpeed !== 1) {\n                this.videoModel.setMute(muteState);\n            }\n\n            //document.removeEventListener(\"visibilityChange\");\n\n            this.videoModel.unlisten(\"play\", playListener);\n            this.videoModel.unlisten(\"pause\", pauseListener);\n            this.videoModel.unlisten(\"error\", errorListener);\n            this.videoModel.unlisten(\"seeking\", seekingListener);\n            this.videoModel.unlisten(\"seeked\", seekedListener);\n            this.videoModel.unlisten(\"waiting\", waitingListener);\n            this.videoModel.unlisten(\"timeupdate\", timeupdateListener);\n            this.videoModel.unlisten(\"durationchange\", durationchangeListener);\n            this.videoModel.unlisten(\"progress\", progressListener);\n            this.videoModel.unlisten(\"ratechange\", ratechangeListener);\n            this.videoModel.unlisten(\"loadedmetadata\", loadedListener);\n            this.videoModel.unlisten(\"ended\", endedListener);\n            this.videoModel.unlisten(\"canplay\", canplayListener);\n            this.videoModel.unlisten(\"playing\", playingListener);\n            this.videoModel.unlisten(\"loadstart\", loadstartListener);\n\n            this.system.unmapHandler(\"streamsComposed\", undefined, streamsComposed);\n\n            this.system.unmapHandler(\"bufferUpdated\");\n            this.system.unmapHandler(\"startTimeFound\");\n            this.system.unmapHandler(\"segmentLoadingFailed\");\n            this.system.unmapHandler(\"bufferingCompleted\");\n\n            tearDownMediaSource.call(this).then(\n                function() {\n                    if (protectionController) {\n                        protectionController.unsubscribe(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR, self);\n                    }\n\n                    protectionController = undefined;\n                    self.fragmentController = undefined;\n\n                    deferred.resolve();\n                });\n\n            return deferred.promise;\n        },\n\n        getDuration: function() {\n            return periodInfo.duration;\n        },\n\n        getStartTime: function() {\n            return periodInfo.start;\n        },\n\n        getPeriodIndex: function() {\n            return periodInfo.index;\n        },\n\n        getId: function() {\n            return periodInfo.id;\n        },\n\n        getPeriodInfo: function() {\n            return periodInfo;\n        },\n\n        getMinbufferTime: function() {\n            if (!videoController) {\n                return MediaPlayer.dependencies.BufferExtensions.DEFAULT_MIN_BUFFER_TIME;\n            }\n            return videoController.getMinbufferTime();\n        },\n\n        getLiveDelay: function() {\n            if (!videoController) {\n                return MediaPlayer.dependencies.BufferExtensions.DEFAULT_LIVE_DELAY;\n            }\n            return videoController.getLiveDelay();\n        },\n\n        startEventController: function() {\n            eventController.start();\n        },\n\n        resetEventController: function() {\n            eventController.reset();\n        },\n\n        enableSubtitles: function(enabled) {\n            var track;\n\n            if (enabled !== subtitlesEnabled) {\n                subtitlesEnabled = enabled;\n                track = this.textTrackExtensions.getCurrentTextTrack(this.videoModel.getElement());\n                this.textTrackExtensions.cleanSubtitles();\n\n                if (textController) {\n                    if (enabled) {\n                        if (manifest.name === 'MSS' && this.manifestExt.getIsDynamic(manifest)) {\n                            // In case of MSS live streams, refresh manifest before activating subtitles\n                            this.system.mapHandler(\"streamsComposed\", undefined, streamsComposed.bind(this), true);\n                            this.system.notify(\"manifestUpdate\");\n                        } else {\n                            streamsComposed.call(this);\n                        }\n                        // show subtitle here => useful for full TTML file\n                        if (track && track.kind !== 'metadata' && track.mode !== 'showing') {\n                            track.mode = \"showing\";\n                        }else if (track) {\n                            track.mode = \"hidden\";\n                        }\n                    } else {\n                        if (fragmentInfoTextController) {\n                            fragmentInfoTextController.stop();\n                        }\n                        // hide subtitle here\n                        if (track) {\n                            track.mode = \"disabled\";\n                        }\n                        textController.stop();\n                    }\n                }\n            }\n        },\n\n        setTrickModeSpeed: function(speed) {\n            var funcs = [],\n                self = this,\n                enableTrickMode = (speed !== 1) ? true : false,\n                currentVideoTime,\n                seekValue,\n                restoreMute = function() {\n                    if (self.videoModel.getCurrentTime() > (currentVideoTime + 1)) {\n                        self.videoModel.unlisten(\"timeupdate\", restoreMute);\n                        self.debug.info(\"[Stream] Set mute: \" + muteState + \", the mute state before using trick mode.\");\n                        self.videoModel.setMute(muteState);\n                    }\n                };\n\n            if (speed === tmSpeed) {\n                return;\n            }\n\n            if (!videoController) {\n                return;\n            }\n\n            self.debug.info(\"[Stream] Trick mode: speed = \" + speed);\n\n            if (enableTrickMode && tmState === \"Stopped\") {\n                //unlisten pause event to have correct metrics\n                this.videoModel.unlisten(\"pause\", pauseListener);\n                self.debug.info(\"[Stream] Set mute: true\");\n                muteState = self.videoModel.getMute();\n                if (!muteState) {\n                    self.videoModel.setMute(true);\n                }\n                self.videoModel.pause();\n            } else if (!enableTrickMode) {\n                //stop trick mode, add a trick mode metric\n                self.metricsModel.addPlayList('video', new Date().getTime(), tmVideoStartTime, 'trickMode', tmSpeed);\n                tmSpeed = 1;\n                clearTimeout(tmSeekTimeout);\n                stopBuffering.call(self);\n            }\n\n            funcs.push(videoController.setTrickMode(enableTrickMode, speed > 1));\n            if (audioController) {\n                funcs.push(audioController.setTrickMode(enableTrickMode, speed > 1));\n            }\n\n            Q.all(funcs).then(function() {\n                tmPreviousSpeed = tmSpeed;\n                tmSpeed = speed;\n                currentVideoTime = self.videoModel.getCurrentTime();\n\n                if (!enableTrickMode) {\n                    //listen pause event to have correct metrics\n                    self.videoModel.listen(\"pause\", pauseListener);\n                    self.debug.info(\"[Stream] Trick mode: Stopped, current time = \" + currentVideoTime);\n                    tmState = \"Stopped\";\n                    self.videoModel.listen(\"timeupdate\", restoreMute);\n                    currentVideoTime = tmEndDetected ? self.getStartTime() : currentVideoTime;\n                    seek.call(self, currentVideoTime, true);\n                } else {\n                    if (tmState === \"Running\") {\n                        //trick mode speed has changed, add a trick mode metric for the previous speed\n                        self.metricsModel.addPlayList('video', new Date().getTime(), tmVideoStartTime, 'trickMode', tmPreviousSpeed);\n                        tmState = \"Changed\";\n                    } else if (tmState === \"Stopped\") {\n                        tmEndDetected = false;\n                        tmState = \"Running\";\n                        tmSeekStep = tmMinSeekStep = videoController.getSegmentDuration();\n                        tmStartTime = tmSeekTime = (new Date().getTime()) / 1000;\n                        tmVideoStartTime = currentVideoTime;\n                        self.debug.info(\"[Stream] Trick mode (x\" + tmSpeed + \"): videoTime = \" + tmVideoStartTime);\n                        seekValue = currentVideoTime + (tmSeekStep * Math.sign(tmSpeed));\n                        seekValue = Math.round((seekValue - (seekValue % tmMinSeekStep)) * 1000) / 1000;\n                        self.debug.info(\"[Stream] Trick mode (x\" + tmSpeed + \"): seek step = \" + tmSeekStep);\n                        tmSeekValue = seekValue;\n                        seek.call(self, seekValue);\n                    }\n                }\n            });\n        },\n\n        getTrickModeSpeed: function() {\n            return tmSpeed;\n        },\n\n        updateData: updateData,\n        play: play,\n        seek: seek,\n        pause: pause\n    };\n};\n\nMediaPlayer.dependencies.Stream.prototype = {\n    constructor: MediaPlayer.dependencies.Stream\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.dependencies.StreamController = function() {\n    \"use strict\";\n\n    /*\n     * StreamController aggregates all streams defined as Period sections in the manifest file\n     * and implements corresponding logic to switch between them.\n     */\n\n    var source,\n        running = false,\n        streams = [],\n        activeStream,\n        protectionController,\n        ownProtectionController = false,\n        //TODO set correct value for threshold\n        STREAM_BUFFER_END_THRESHOLD = 6,\n        STREAM_END_THRESHOLD = 0.2,\n        autoPlay = true,\n        isPeriodSwitchingInProgress = false,\n        timeupdateListener,\n        seekingListener,\n        progressListener,\n        pauseListener,\n        playListener,\n        protectionData,\n        defaultAudioLang = 'und',\n        defaultSubtitleLang = 'und',\n        subtitlesEnabled = false,\n        reloadStream = false,\n        deferredLoading = null,\n\n        isSafari = (fingerprint_browser().name === \"Safari\"),\n\n        /*\n         * Replaces the currently displayed <video> with a new data and corresponding <video> element.\n         *\n         * @param fromVideoModel Currently used video data\n         * @param toVideoModel New video data to be displayed\n         *\n         * TODO - move method to appropriate place - VideoModelExtensions??\n         */\n        switchVideoModel = function(fromVideoModel, toVideoModel) {\n            var activeVideoElement = fromVideoModel.getElement(),\n                newVideoElement = toVideoModel.getElement();\n\n            if (!newVideoElement.parentNode) {\n                activeVideoElement.parentNode.insertBefore(newVideoElement, activeVideoElement);\n            }\n\n            // We use width property to hide/show video element because when using display=\"none\"/\"block\" playback\n            // sometimes stops after switching.\n            activeVideoElement.style.width = \"0px\";\n            newVideoElement.style.width = \"100%\";\n\n            copyVideoProperties(activeVideoElement, newVideoElement);\n            detachVideoEvents.call(this, fromVideoModel);\n            attachVideoEvents.call(this, toVideoModel);\n\n            return true;\n        },\n\n        attachVideoEvents = function(videoModel) {\n            videoModel.listen(\"seeking\", seekingListener);\n            videoModel.listen(\"progress\", progressListener);\n            videoModel.listen(\"timeupdate\", timeupdateListener);\n            videoModel.listen(\"pause\", pauseListener);\n            videoModel.listen(\"play\", playListener);\n        },\n\n        detachVideoEvents = function(videoModel) {\n            videoModel.unlisten(\"seeking\", seekingListener);\n            videoModel.unlisten(\"progress\", progressListener);\n            videoModel.unlisten(\"timeupdate\", timeupdateListener);\n            videoModel.unlisten(\"pause\", pauseListener);\n            videoModel.unlisten(\"play\", playListener);\n        },\n\n        copyVideoProperties = function(fromVideoElement, toVideoElement) {\n            [\"controls\", \"loop\", \"muted\", \"playbackRate\", \"volume\"].forEach(function(prop) {\n                toVideoElement[prop] = fromVideoElement[prop];\n            });\n        },\n\n        /*\n         * Called when more data is buffered.\n         * Used to determine the time current stream is almost buffered and we can start buffering of the next stream.\n         * TODO move to ???Extensions class\n         */\n        onProgress = function() {\n\n            var ranges = activeStream.getVideoModel().getElement().buffered;\n\n            // nothing is buffered\n            if (!ranges.length) {\n                return;\n            }\n\n            var lastRange = ranges.length - 1,\n                bufferEndTime = ranges.end(lastRange),\n                remainingBufferDuration = activeStream.getStartTime() + activeStream.getDuration() - bufferEndTime;\n\n            if (remainingBufferDuration < STREAM_BUFFER_END_THRESHOLD) {\n                activeStream.getVideoModel().unlisten(\"progress\", progressListener);\n                onStreamBufferingEnd();\n            }\n        },\n\n        switchStream = function(from, to, seekTo) {\n\n            if (isPeriodSwitchingInProgress || !from || !to || from === to) {\n                return;\n            }\n\n            isPeriodSwitchingInProgress = true;\n\n            from.pause();\n            activeStream = to;\n\n            switchVideoModel.call(this, from.getVideoModel(), to.getVideoModel());\n\n            if (seekTo) {\n                this.seek(from.getVideoModel().getCurrentTime());\n            } else {\n                this.seek(to.getStartTime());\n            }\n\n            this.play();\n            from.resetEventController();\n            activeStream.startEventController();\n            isPeriodSwitchingInProgress = false;\n        },\n\n\n        /*\n         * Called when current playback positon is changed.\n         * Used to determine the time current stream is finished and we should switch to the next stream.\n         * TODO move to ???Extensions class\n         */\n        onTimeupdate = function() {\n\n            if (!activeStream) {\n                return;\n            }\n\n            var self = this,\n                time = new Date(),\n                streamEndTime = activeStream.getStartTime() + activeStream.getDuration(),\n                videoElement = activeStream.getVideoModel().getElement(),\n                currentTime = videoElement.currentTime,\n                playBackQuality = self.videoExt.getPlaybackQuality(videoElement);\n\n            self.metricsModel.addPlaybackQuality(\"video\", time, playBackQuality, currentTime);\n            self.metricsModel.addVideoResolution(\"video\", time, videoElement.videoWidth, videoElement.videoHeight, currentTime);\n\n            if (!getNextStream()) {\n                return;\n            }\n\n            // Sometimes after seeking timeUpdateHandler is called before seekingHandler and a new period starts\n            // from beginning instead of from a chosen position. So we do nothing if the player is in the seeking state\n            if (activeStream.getVideoModel().getElement().seeking) {\n                return;\n            }\n\n            // check if stream end is reached\n            if (streamEndTime - currentTime < STREAM_END_THRESHOLD) {\n                switchStream.call(this, activeStream, getNextStream());\n            }\n        },\n\n        /*\n         * Called when Seeking event is occured.\n         * TODO move to ???Extensions class\n         */\n        onSeeking = function() {\n            var seekingTime = activeStream.getVideoModel().getCurrentTime(),\n                seekingStream = getStreamForTime(seekingTime);\n\n            if (seekingStream && seekingStream !== activeStream) {\n                switchStream.call(this, activeStream, seekingStream, seekingTime);\n            }\n        },\n\n        onPause = function() {\n            this.manifestUpdater.stop();\n        },\n\n        onPlay = function() {\n            this.manifestUpdater.start();\n        },\n\n        /*\n         * Handles the current stream buffering end moment to start the next stream buffering\n         */\n        onStreamBufferingEnd = function() {\n            var nextStream = getNextStream();\n            if (nextStream) {\n                nextStream.seek(nextStream.getStartTime());\n            }\n        },\n\n        getNextStream = function() {\n            var nextIndex = activeStream.getPeriodIndex() + 1;\n            return (nextIndex < streams.length) ? streams[nextIndex] : null;\n        },\n\n        getStreamForTime = function(time) {\n            var duration = 0,\n                stream = null,\n                ln = streams.length,\n                i = 0;\n\n            if (ln > 0) {\n                duration += streams[0].getStartTime();\n            }\n\n            for (i = 0; i < ln; i += 1) {\n                stream = streams[i];\n                duration += stream.getDuration();\n\n                if (time < duration) {\n                    return stream;\n                }\n            }\n        },\n\n        //  TODO move to ???Extensions class\n        createVideoModel = function() {\n            var model = this.system.getObject(\"videoModel\"),\n                video = document.createElement(\"video\");\n            model.setElement(video);\n            return model;\n        },\n\n        removeVideoElement = function(element) {\n            if (element.parentNode) {\n                element.parentNode.removeChild(element);\n            }\n        },\n\n        composeStreams = function() {\n            var manifest = this.manifestModel.getValue(),\n                metrics = this.metricsModel.getMetricsFor(\"stream\"),\n                manifestUpdateInfo = this.metricsExt.getCurrentManifestUpdate(metrics),\n                periodInfo,\n                periods,\n                pLen,\n                sLen,\n                pIdx,\n                sIdx,\n                period,\n                mpd,\n                stream;\n\n            if (!manifest) {\n                return false;\n            }\n\n            // Specific use case of \"start-over\" or \"session DVR\" live streams\n            // We set this information in the manifest, to be used by MssFragmentController for DVR window updating\n            if (source.startOver) {\n                manifest.startOver = true;\n            } \n\n            this.debug.info(\"[StreamController] composeStreams\");\n\n            if (this.capabilities.supportsEncryptedMedia()) {\n                if (!protectionController) {\n                    protectionController = this.system.getObject(\"protectionController\");\n                    /*this.eventBus.dispatchEvent({\n                        type: MediaPlayer.events.PROTECTION_CREATED,\n                        data: {\n                            controller: protectionController,\n                            manifest: manifest\n                        }\n                    });*/\n                    ownProtectionController = true;\n                }\n                protectionController.setMediaElement(this.videoModel.getElement());\n                if (protectionData) {\n                    protectionController.setProtectionData(protectionData);\n                }\n            }\n\n            mpd = this.manifestExt.getMpd(manifest);\n            if (activeStream) {\n                periodInfo = activeStream.getPeriodInfo();\n                mpd.isClientServerTimeSyncCompleted = periodInfo.mpd.isClientServerTimeSyncCompleted;\n                mpd.clientServerTimeShift = periodInfo.mpd.clientServerTimeShift;\n            }\n\n            periods = this.manifestExt.getRegularPeriods(manifest, mpd);\n            if (periods.length === 0) {\n                return false;\n            }\n\n            for (pIdx = 0, pLen = periods.length; pIdx < pLen; pIdx += 1) {\n                period = periods[pIdx];\n                for (sIdx = 0, sLen = streams.length; sIdx < sLen; sIdx += 1) {\n                    // If the stream already exists we just need to update the values we got from the updated manifest\n                    if (streams[sIdx].getId() === period.id) {\n                        stream = streams[sIdx];\n                        this.debug.info(\"[StreamController] update stream data\");\n                        stream.updateData(period);\n                    }\n                }\n                // If the Stream object does not exist we probably loaded the manifest the first time or it was\n                // introduced in the updated manifest, so we need to create a new Stream and perform all the initialization operations\n                if (!stream) {\n                    this.debug.info(\"[StreamController] Create stream\");\n                    stream = this.system.getObject(\"stream\");\n                    stream.setVideoModel(pIdx === 0 ? this.videoModel : createVideoModel.call(this));\n                    stream.initProtection(protectionController);\n                    stream.setAutoPlay(autoPlay);\n                    stream.setDefaultAudioLang(defaultAudioLang);\n                    stream.setDefaultSubtitleLang(defaultSubtitleLang);\n                    stream.enableSubtitles(subtitlesEnabled);\n                    stream.setInitialStartTime(source.startTime);\n                    stream.load(manifest, period);\n                    streams.push(stream);\n                }\n\n                this.metricsModel.addManifestUpdatePeriodInfo(manifestUpdateInfo, period.id, period.index, period.start, period.duration);\n                stream = null;\n            }\n\n            // If the active stream has not been set up yet, let it be the first Stream in the list\n            if (!activeStream) {\n                activeStream = streams[0];\n                attachVideoEvents.call(this, activeStream.getVideoModel());\n            }\n\n            this.metricsModel.updateManifestUpdateInfo(manifestUpdateInfo, {\n                currentTime: this.videoModel.getCurrentTime(),\n                buffered: this.videoModel.getElement().buffered,\n                presentationStartTime: periods[0].start,\n                clientTimeOffset: mpd.clientServerTimeShift\n            });\n\n            if (deferredLoading) {\n                deferredLoading.resolve();\n                deferredLoading = null;\n            }\n\n            return true;\n        },\n\n        manifestUpdate = function(reload) {\n            if (reload === true) {\n                reloadStream = true;\n            }\n            this.refreshManifest();\n        },\n\n        manifestHasUpdated = function() {\n\n            // Check if stopping\n            if (!running) {\n                if (deferredLoading) {\n                    deferredLoading.resolve();\n                    deferredLoading = null;\n                }\n                return;\n            }\n\n            this.debug.info(\"[StreamController] Manifest updated\");\n\n            var result = composeStreams.call(this);\n\n            if (result) {\n                this.system.notify(\"streamsComposed\");\n            } else {\n                this.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.MANIFEST_ERR_NO_STREAM, \"No stream/period is provided in the manifest\");\n            }\n\n            if (deferredLoading) {\n                deferredLoading.resolve();\n                deferredLoading = null;\n            }\n        },\n\n        loadNativeHlsStream = function (source) {\n            // If HLS+FP on Safari then we do use specific Stream instance\n            if (isSafari && source.protocol === 'HLS') {\n                var stream = this.system.getObject(\"hlsStream\");\n                stream.setVideoModel(this.videoModel);\n                stream.setProtectionData(protectionData);\n                stream.setAutoPlay(autoPlay);\n                stream.setDefaultAudioLang(defaultAudioLang);\n                stream.setDefaultSubtitleLang(defaultSubtitleLang);\n                stream.enableSubtitles(subtitlesEnabled);\n                streams.push(stream);\n                activeStream = stream;\n                attachVideoEvents.call(this, activeStream.getVideoModel());\n                stream.load(source.url);\n                return true;\n            }\n\n            return false;\n        };\n\n    return {\n        system: undefined,\n        videoModel: undefined,\n        parser: undefined,\n        manifestLoader: undefined,\n        manifestUpdater: undefined,\n        manifestModel: undefined,\n        manifestExt: undefined,\n        fragmentExt: undefined,\n        capabilities: undefined,\n        debug: undefined,\n        metricsModel: undefined,\n        metricsExt: undefined,\n        videoExt: undefined,\n        errHandler: undefined,\n        eventBus: undefined,\n        notify: undefined,\n        subscribe: undefined,\n        unsubscribe: undefined,\n\n        setup: function() {\n            this.system.mapHandler(\"manifestUpdate\", undefined, manifestUpdate.bind(this));\n            this.system.mapHandler(\"manifestUpdated\", undefined, manifestHasUpdated.bind(this));\n            timeupdateListener = onTimeupdate.bind(this);\n            progressListener = onProgress.bind(this);\n            seekingListener = onSeeking.bind(this);\n            pauseListener = onPause.bind(this);\n            playListener = onPlay.bind(this);\n        },\n\n        getManifestExt: function() {\n            return activeStream.getManifestExt();\n        },\n\n        setAutoPlay: function(value) {\n            autoPlay = value;\n        },\n\n        getAutoPlay: function() {\n            return autoPlay;\n        },\n\n        getVideoModel: function() {\n            return this.videoModel;\n        },\n\n        setVideoModel: function(value) {\n            this.videoModel = value;\n        },\n\n        getAudioTracks: function() {\n            if (activeStream) {\n                return activeStream.getAudioTracks();\n            }\n            return null;\n        },\n\n        getSelectedAudioTrack: function() {\n\n            if (activeStream) {\n                return activeStream.getSelectedAudioTrack();\n            }\n\n            return undefined;\n        },\n\n        setAudioTrack: function(audioTrack) {\n            if (activeStream) {\n                activeStream.setAudioTrack(audioTrack);\n            }\n        },\n\n        getSubtitleTracks: function() {\n            if (activeStream) {\n                return activeStream.getSubtitleTracks();\n            }\n            return null;\n        },\n\n        setSubtitleTrack: function(subtitleTrack) {\n            if (activeStream) {\n                activeStream.setSubtitleTrack(subtitleTrack);\n            }\n        },\n\n        getSelectedSubtitleTrack: function() {\n\n            if (activeStream) {\n                return activeStream.getSelectedSubtitleTrack();\n            }\n\n            return undefined;\n        },\n\n        getMinbufferTime: function() {\n            if (!activeStream) {\n                return MediaPlayer.dependencies.BufferExtensions.DEFAULT_MIN_BUFFER_TIME;\n            }\n            return activeStream.getMinbufferTime();\n        },\n\n        getLiveDelay: function() {\n            if (!activeStream) {\n                return MediaPlayer.dependencies.BufferExtensions.DEFAULT_LIVE_DELAY;\n            }\n            return activeStream.getLiveDelay();\n        },\n\n        load: function(newSource) {\n            var self = this;\n\n            running = true;\n\n            source = newSource;\n\n            if (source.protData) {\n                protectionData = source.protData;\n            }\n\n            if (loadNativeHlsStream.call(this, source)) {\n                return;\n            }\n\n            reloadStream = false;\n\n            deferredLoading = Q.defer();\n            self.debug.info(\"[StreamController] load url: \" + source.url);\n            self.manifestLoader.load(source.url).then(\n                function(manifest) {\n                    self.manifestModel.setValue(manifest);\n                    //ORANGE : add Metadata metric\n                    self.metricsModel.addMetaData();\n                    self.debug.info(\"[StreamController] Manifest has loaded.\");\n                    //self.debug.log(self.manifestModel.getValue());\n                    self.manifestUpdater.start();\n                },\n                function(err) {\n                    deferredLoading.resolve();\n                    deferredLoading = null;\n                    // err is undefined in the case the request has been aborted\n                    if (err) {\n                        self.errHandler.sendError(err.name, err.message, err.data);\n                    }\n                }\n            );\n        },\n\n        refreshManifest: function(url) {\n            var manifest = this.manifestModel.getValue(),\n                manifestUrl = url ? url : (manifest.hasOwnProperty(\"Location\") ? manifest.Location : manifest.mpdUrl);\n\n            this.debug.log(\"[StreamController] Refresh manifest: \" + manifestUrl);\n\n            var self = this;\n            this.manifestLoader.abort();\n            this.manifestLoader.load(manifestUrl, true).then(\n                function(manifestResult) {\n                    self.manifestModel.setValue(manifestResult);\n                    self.debug.log(\"[StreamController] Manifest has been refreshed\");\n                    reloadStream = false;\n                },\n                function(err) {\n                    // err is undefined in the case the request has been aborted\n                    if (err === undefined) {\n                        return;\n                    }\n\n                    // Url is refreshed\n                    if (url) {\n                        // Raise an error only in case we try to reload the session\n                        // to recover some segment downloading error\n                        if (reloadStream) {\n                            self.errHandler.sendError(err.name, err.message, err.data);\n                        }\n                    } else {\n                        // If internal manifest updating (for ex. track switching),\n                        // then raise a warning and ask for refreshing the url (in case it is no more valid or expired)\n                        self.errHandler.sendWarning(err.name, err.message, err.data);\n                        self.eventBus.dispatchEvent({\n                            type: \"manifestUrlUpdate\",\n                            data: {\n                                url: manifestUrl\n                            }\n                        });\n                    }\n                }\n            );\n        },\n\n        reset: function(reason) {\n            var teardownComplete = {},\n                funcs = [],\n                stream,\n                i,\n                self = this;\n\n            this.debug.info(\"[StreamController] Reset\");\n\n            if (!!activeStream) {\n                detachVideoEvents.call(this, activeStream.getVideoModel());\n            }\n\n            running = false;\n\n            self.manifestLoader.abort();\n            self.manifestUpdater.stop();\n            self.parser.reset();\n\n            teardownComplete[MediaPlayer.models.ProtectionModel.eventList.ENAME_TEARDOWN_COMPLETE] = function() {\n                // Complete ProtectionController teardown process\n                ownProtectionController = false;\n                protectionController = null;\n                protectionData = null;\n\n                self.manifestModel.setValue(null);\n\n                self.metricsModel.addState('video', 'stopped', self.videoModel.getCurrentTime(), reason);\n                self.metricsModel.clearAllCurrentMetrics();\n                self.notify(MediaPlayer.dependencies.StreamController.eventList.ENAME_TEARDOWN_COMPLETE);\n            };\n\n            // Wait for current loading process (manifest download and updating) to be achieved\n            Q.when(deferredLoading ? deferredLoading.promise : true).then(function () {\n\n                self.pause();\n\n                isPeriodSwitchingInProgress = false;\n\n                // Reset the streams\n                for (i = 0; i < streams.length; i += 1) {\n                    stream = streams[i];\n                    funcs.push(stream.reset());\n                    if (stream !== activeStream) {\n                        removeVideoElement(stream.getVideoModel().getElement());\n                    }\n                }\n\n                // Reset the video model (stalled states)\n                self.videoModel.reset();\n\n                Q.all(funcs).then(\n                    function() {\n                        streams = [];\n                        activeStream = null;\n\n                        // Teardown the protection system\n                        if (!protectionController) {\n                            teardownComplete[MediaPlayer.models.ProtectionModel.eventList.ENAME_TEARDOWN_COMPLETE]();\n                        } else if (ownProtectionController) {\n                            protectionController.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_TEARDOWN_COMPLETE, teardownComplete, undefined, true);\n                            protectionController.teardown();\n                        } else {\n                            protectionController.setMediaElement(null);\n                            teardownComplete[MediaPlayer.models.ProtectionModel.eventList.ENAME_TEARDOWN_COMPLETE]();\n                        }\n                    }\n                );\n            });\n        },\n\n        setDefaultAudioLang: function(language) {\n            defaultAudioLang = language;\n        },\n\n        setDefaultSubtitleLang: function(language) {\n            defaultSubtitleLang = language;\n        },\n\n        enableSubtitles: function(enabled) {\n            subtitlesEnabled = enabled;\n            if (activeStream) {\n                activeStream.enableSubtitles(enabled);\n            }\n        },\n\n        setTrickModeSpeed: function(speed) {\n            if (activeStream) {\n                activeStream.setTrickModeSpeed(speed);\n            }\n        },\n\n        getTrickModeSpeed: function() {\n            if (activeStream) {\n                return activeStream.getTrickModeSpeed();\n            }\n            return 0;\n        },\n\n        play: function() {\n            activeStream.play();\n        },\n\n        pause: function() {\n            if (activeStream) {\n                activeStream.pause();\n            }\n        },\n\n        seek: function(time, autoplay) {\n            if (activeStream) {\n                activeStream.seek(time, autoplay);\n            }\n        },\n    };\n};\n\nMediaPlayer.dependencies.StreamController.prototype = {\n    constructor: MediaPlayer.dependencies.StreamController\n};\n\nMediaPlayer.dependencies.StreamController.eventList = {\n    ENAME_STREAMS_COMPOSED: \"streamsComposed\",\n    ENAME_TEARDOWN_COMPLETE: \"streamTeardownComplete\"\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Akamai Technologies\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.utils.TokenAuthentication = function () {\n    \"use strict\";\n    var tokenAuthentication = {type:MediaPlayer.utils.TokenAuthentication.TYPE_QUERY};\n    return {\n        debug:undefined,\n        getTokenAuthentication:function () {\n\n            return tokenAuthentication;\n\n        },\n        setTokenAuthentication:function (object) {\n\n            tokenAuthentication = object;\n\n        },\n        checkRequestHeaderForToken:function(request) {\n\n            if (tokenAuthentication.name !== undefined &&\n                request.getResponseHeader(tokenAuthentication.name) !== null) {\n\n                tokenAuthentication.token = request.getResponseHeader(tokenAuthentication.name);\n                this.debug.log(tokenAuthentication.name+\" received: \" + tokenAuthentication.token);\n\n           }\n        },\n        addTokenAsQueryArg:function(url) {\n\n            if(tokenAuthentication.name !== undefined && tokenAuthentication.token !== undefined) {\n                if (tokenAuthentication.type === MediaPlayer.utils.TokenAuthentication.TYPE_QUERY) {\n\n                    var modifier = url.indexOf('?') === -1 ? '?' : '&';\n                    url += modifier + tokenAuthentication.name +\"=\" + tokenAuthentication.token;\n                    this.debug.log(tokenAuthentication.name+\" is being appended on the request url with a value of : \" + tokenAuthentication.token);\n\n                }\n            }\n\n            return url;\n        },\n        setTokenInRequestHeader:function(request) {\n\n            if (tokenAuthentication.type === MediaPlayer.utils.TokenAuthentication.TYPE_HEADER) {\n\n                request.setRequestHeader(tokenAuthentication.name, tokenAuthentication.token);\n                this.debug.log(tokenAuthentication.name+\" is being set in the request header with a value of : \" + tokenAuthentication.token);\n\n            }\n\n            return request;\n        }\n    };\n};\n\nMediaPlayer.utils.TokenAuthentication.TYPE_QUERY = \"query\";\nMediaPlayer.utils.TokenAuthentication.TYPE_HEADER = \"header\";","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Akamai Technologies\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.models.URIQueryAndFragmentModel = function () {\n    \"use strict\";\n\n    var URIFragmentDataVO = new MediaPlayer.vo.URIFragmentData(),\n        URIQueryData = [],\n\n        reset = function () {\n            URIFragmentDataVO = new MediaPlayer.vo.URIFragmentData();\n            URIQueryData = [];\n        },\n\n        parseURI = function (uri) {\n\n            var URIFragmentData = [],\n                testQuery = new RegExp(/[?]/),\n                testFragment = new RegExp(/[#]/),\n                isQuery = testQuery.test(uri),\n                isFragment = testFragment.test(uri),\n                mappedArr;\n\n            function reduceArray(previousValue, currentValue, index, array) {\n                var arr =  array[0].split(/[=]/);\n                array.push({key:arr[0], value:arr[1]});\n                array.shift();\n                return array;\n            }\n\n            function mapArray(currentValue, index, array) {\n                if (index > 0)\n                {\n                    if (isQuery && URIQueryData.length === 0) {\n                        URIQueryData = array[index].split(/[&]/);\n                    } else if (isFragment) {\n                        URIFragmentData = array[index].split(/[&]/);\n                    }\n                }\n\n                return array;\n            }\n\n            mappedArr = uri.split(/[?#]/).map(mapArray);\n\n            if (URIQueryData.length > 0) {\n                URIQueryData = URIQueryData.reduce(reduceArray, null);\n            }\n\n            if (URIFragmentData.length > 0) {\n                URIFragmentData = URIFragmentData.reduce(reduceArray, null);\n                URIFragmentData.forEach(function (object) {\n                    URIFragmentDataVO[object.key] = object.value;\n                });\n            }\n\n            return uri;\n        };\n\n    return {\n        parseURI:parseURI,\n        reset:reset,\n        //ORANGE: fix bug on not updating URIFragmentDataVO \n        getURIFragmentData: function() {\n            return URIFragmentDataVO;\n        },\n        getURIQueryData:URIQueryData\n    };\n};\n\nMediaPlayer.models.URIQueryAndFragmentModel.prototype = {\n    constructor: MediaPlayer.models.URIQueryAndFragmentModel\n};\n","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.models.VideoModel = function () {\n    \"use strict\";\n\n    var element,\n        stalledStreams = {},\n        TTMLRenderingDiv = null,\n\n        isStalled = function () {\n            for (var type in stalledStreams) {\n                if (stalledStreams[type] === true) {\n                    return true;\n                }\n            }\n            return false;\n        },\n\n        stallStream = function (type, stalled) {\n            stalledStreams[type] = stalled;\n            this.debug.info(\"<video> # stalled = \" + stalled + \", type = \" + type);\n            this.setPlaybackRate(isStalled() ? 0 : 1);\n        };\n\n    return {\n        system: undefined,\n        debug: undefined,\n\n        setup: function () {\n        },\n\n        reset: function () {\n            stalledStreams = [];\n        },\n\n        play: function () {\n            this.debug.info(\"<video> # play()\");\n            element.play();\n        },\n\n        pause: function () {\n            this.debug.info(\"<video> # pause()\");\n            element.pause();\n        },\n\n        isPaused: function () {\n            return element.paused;\n        },\n\n        isSeeking: function () {\n            return element.seeking;\n        },\n\n        getDuration: function () {\n            return element.duration;\n        },\n\n        getPlaybackRate: function () {\n            return element.playbackRate;\n        },\n\n        setPlaybackRate: function (value) {\n            this.debug.info(\"<video> # playbackRate = \" + value);\n            element.playbackRate = value;\n        },\n\n        getMute: function () {\n            return element.muted;\n        },\n\n        setMute: function (value) {\n            element.muted = value;\n        },\n\n        getVolume: function () {\n            return element.volume;\n        },\n\n        setVolume: function (value) {\n            element.volume = value;\n        },\n\n        getCurrentTime: function () {\n            return element.currentTime;\n        },\n\n        setCurrentTime: function (currentTime) {\n            this.debug.info(\"<video> # currentTime = \" + currentTime);\n            element.currentTime = currentTime;\n        },\n\n        listen: function (type, callback) {\n            element.addEventListener(type, callback, false);\n        },\n\n        unlisten: function (type, callback) {\n            element.removeEventListener(type, callback, false);\n        },\n\n        // ORANGE : register listener on video element parent\n        listenOnParent: function (type, callback) {\n            element.parentElement.addEventListener(type, callback, false);\n        },\n\n        unlistenOnParent: function (type, callback) {\n            element.parentElement.removeEventListener(type, callback, false);\n        },\n\n        getElement: function () {\n            return element;\n        },\n\n        setElement: function (value) {\n            element = value;\n        },\n\n        setSource: function (source) {\n            if (source) {\n                this.debug.info(\"<video> # set source\");\n                element.src = source;\n            } else {\n                this.debug.info(\"<video> # reset source\");\n                element.removeAttribute('src');\n                element.load();\n            }\n        },\n\n        isStalled: function () {\n            return element.playbackRate === 0;\n        },\n\n        getTTMLRenderingDiv: function() {\n            return TTMLRenderingDiv;\n        },\n\n        setTTMLRenderingDiv: function(div) {\n            TTMLRenderingDiv = div;\n            // The styling will allow the captions to match the video window size and position.\n            TTMLRenderingDiv.style.position = 'absolute';\n            TTMLRenderingDiv.style.display = 'flex';\n            TTMLRenderingDiv.style.overflow = 'hidden';\n            TTMLRenderingDiv.style.pointerEvents = 'none';\n            TTMLRenderingDiv.style.top = 0;\n            TTMLRenderingDiv.style.left = 0;\n        },\n\n        stallStream: stallStream\n    };\n};\n\nMediaPlayer.models.VideoModel.prototype = {\n    constructor: MediaPlayer.models.VideoModel\n};\n","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.dependencies.VideoModelExtensions = function () {\n    \"use strict\";\n\n    return {\n        getPlaybackQuality: function (videoElement) {\n            var hasWebKit = (\"webkitDroppedFrameCount\" in videoElement),\n                hasQuality = (\"getVideoPlaybackQuality\" in videoElement),\n                result = null;\n\n            if (hasQuality) {\n                result = videoElement.getVideoPlaybackQuality();\n            }\n            // ORANGE : add totalVideoFrames\n            else if (hasWebKit) {\n                result = {droppedVideoFrames: videoElement.webkitDroppedFrameCount, creationTime: new Date(), totalVideoFrames: videoElement.webkitDecodedFrameCount};\n            }\n\n            return result;\n        }\n    };\n};\n\nMediaPlayer.dependencies.VideoModelExtensions.prototype = {\n    constructor: MediaPlayer.dependencies.VideoModelExtensions\n};","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.dependencies.XHRLoader = function() {\n    \"use strict\";\n\n    var _xhr = null,\n        _url = null,\n        _responseType = null,\n        _range = null,\n        _onprogress = null,\n        _retryAttempts = 0,\n        _retryInterval = 0,\n        _retryCount = 0,\n        _retryTimeout = null,\n        _deferred = null,\n\n        _abort = function() {\n\n            if (_xhr !== null && _xhr.readyState > 0 && _xhr.readyState < 4) {\n                _xhr.abort();\n            } else if (_retryTimeout) {\n                clearTimeout(_retryTimeout);\n                _retryTimeout = null;\n                _deferred.reject();\n            }\n        },\n\n        _load = function() {\n            var needFailureReport = true,\n\n                onprogress = function(event) {\n                    if (_onprogress) {\n                        _onprogress(_xhr, event);\n                    }\n                },\n\n                onabort = function() {\n                    _xhr.aborted = true;\n                },\n\n                onload = function() {\n                    if (_xhr.status < 200 || _xhr.status > 299) {\n                        return;\n                    }\n\n                    if (_xhr.status === 200 && _xhr.readyState === 4) {\n                        // The request succeeded\n                        // => return the response the responseURL in case of URL redirection\n                        needFailureReport = false;\n\n                        // Add endDate attribute to store request end time\n                        _xhr.endDate = new Date();\n\n                        _deferred.resolve(_xhr);\n                    }\n                },\n\n                onloadend = function() {\n\n                    if (!needFailureReport) {\n                        return;\n                    }\n                    needFailureReport = false;\n\n                    // Add endDate attribute to store request end time\n                    _xhr.endDate = new Date();\n\n                    // The request failed\n                    _retryCount++;\n                    if (!_xhr.aborted && _retryAttempts > 0 && _retryCount <= _retryAttempts) {\n                        // Retry the request\n                        _retryTimeout = setTimeout(function() {\n                            _load();\n                        }, _retryInterval);\n                    } else {\n                        _deferred.reject(_xhr);\n                    }\n                };\n\n            try {\n                _xhr = new XMLHttpRequest();\n                _xhr.open(\"GET\", _url, true);\n\n                if (_responseType) {\n                    _xhr.responseType = _responseType;\n                }\n\n                if (_range) {\n                    _xhr.setRequestHeader('Range', 'bytes=' + _range);\n                }\n\n                _xhr.onprogress = onprogress;\n                _xhr.onabort = onabort;\n                _xhr.onload = onload;\n                _xhr.onloadend = onloadend;\n                _xhr.onerror = onloadend;\n\n                // Add startDate attribute to store request start time\n                _xhr.startDate = new Date();\n\n                _xhr.send();\n            } catch (e) {\n                _xhr.onerror();\n            }\n        };\n\n    return {\n\n        initialize: function(responseType, retryAttempts, retryInterval, onprogress) {\n            _responseType = responseType;\n            _retryAttempts = retryAttempts;\n            _retryInterval = retryInterval;\n            _onprogress = onprogress;\n        },\n\n        load: function(url, range) {\n            _url = url;\n            _range = range;\n            _retryCount = 0;\n            _deferred = Q.defer();\n            _load();\n            return _deferred.promise;\n        },\n\n        abort: _abort\n    };\n};\n\nMediaPlayer.dependencies.XHRLoader.prototype = {\n    constructor: MediaPlayer.dependencies.XHRLoader\n};\n","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Akamai Technologies\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Akamai Technologies nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.utils.TTMLParser = function() {\n    \"use strict\";\n\n    /*\n     * This TTML parser follows \"TTML Simple Delivery Profile for Closed Captions (US)\" spec - http://www.w3.org/TR/ttml10-sdp-us/\n     *\n     * ORANGE: Some strict limitations of US profile removed to allow for non-US TTML2 implmentations used in Europe:\n     *         - no requirement for US profile\n     *         - offset-style format allowed for <timeExpression>\n     * */\n\n    var SECONDS_IN_HOUR = 60 * 60,\n        SECONDS_IN_MIN = 60,\n        TTAF_URI = \"http://www.w3.org/2006/10/ttaf1\",\n        TTAF_PARAMETER_URI = \"http://www.w3.org/2006/10/ttaf1#parameter\",\n        TTAF_STYLE_URI = \"http://www.w3.org/2006/10/ttaf1#styling\",\n        TTML_URI = \"http://www.w3.org/ns/ttml\",\n        TTML_PARAMETER_URI = \"http://www.w3.org/ns/ttml#parameter\",\n        TTML_STYLE_URI = \"http://www.w3.org/ns/ttml#styling\",\n        SMPTE_TT_URI = \"http://www.smpte-ra.org/schemas/2052-1/2010/smpte-tt\",\n        globalPrefTTNameSpace = [TTML_URI, TTAF_URI],\n        globalPrefStyleNameSpace =  [TTML_STYLE_URI, TTAF_STYLE_URI],\n        globalPrefParameterNameSpace = [TTML_PARAMETER_URI, TTAF_PARAMETER_URI],\n        globalPrefSMPTENameSpace = [SMPTE_TT_URI],\n\n        // R0028 - A document must not contain a <timeExpression> value that does not conform to the subset of clock-time that\n        // matches either of the following patterns: hh:mm:ss.mss or hh:mm:ss:ff, where hh denotes hours (00-23),\n        // mm denotes minutes (00-59), ss denotes seconds (00-59), mss denotes milliseconds (000-999), and ff denotes frames (00-frameRate - 1).\n        // R0030 - For time expressions that use the hh:mm:ss.mss format, the following constraints apply:\n        // - Exactly 2 digits must be used in each of the hours, minutes, and second components (include leading zeros).\n        // - Exactly 3 decimal places must be used for the milliseconds component (include leading zeros).\n        // R0031 -For time expressions that use the hh:mm:ss:ff format, the following constraints apply:\n        // - Exactly 2 digits must be used in each of the hours, minutes, second, and frame components (include leading zeros).\n\n        // Orange: the restrictions above are for US profile only.\n        //         in general, TTML allows other syntax representations, see https://dvcs.w3.org/hg/ttml/raw-file/tip/ttml2/spec/ttml2.html#timing-value-timeExpression\n        //         we have added support for offset-time, a pretty popular one.\n\n        timingRegexClockTime = /^(0[0-9]|1[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])((\\.[0-9][0-9][0-9])|(:[0-9][0-9]))$/,\n        timingRegexOffsetTime = /^\\d+(\\.\\d+|)(h|m|s|ms|f)$/,\n        xmlDoc = null,\n        nodeTt = null,\n        nodeHead = null,\n        nodeLayout = null,\n        nodeStyling = null,\n        nodeBody = null,\n        frameRate = null,\n        tabStyles = [],\n        tabRegions = [],\n        tabImages = [],\n\n        parseTimings = function(timingStr) {\n\n            var timeParts,\n                parsedTime,\n                metric;\n\n            if (timingRegexClockTime.test(timingStr)) {\n\n                timeParts = timingStr.split(\":\");\n\n                parsedTime = (parseFloat(timeParts[0]) * SECONDS_IN_HOUR +\n                    parseFloat(timeParts[1]) * SECONDS_IN_MIN +\n                    parseFloat(timeParts[2]));\n\n                // R0031 -For time expressions that use the hh:mm:ss:ff format, the following constraints apply:\n                //  - A ttp:frameRate attribute must be present on the tt element.\n                //  - A ttp:frameRateMultiplier attribute may be present on the tt element.\n\n                // ORANGE: removed the restrictions above.\n                //         now if no frameRate is defined in tt, the :ff information is ignored.\n\n                if (timeParts[3]) {\n                    if (frameRate && !isNaN(frameRate)) {\n                        parsedTime += parseFloat(timeParts[3]) / frameRate;\n                    }\n                }\n                return parsedTime;\n            }\n\n            if (timingRegexOffsetTime.test(timingStr)) {\n\n                if (timingStr.substr(timingStr.length - 2) == 'ms') {\n                    parsedTime = parseFloat(timingStr.substr(0, timingStr.length - 3));\n                    metric = timingStr.substr(timingStr.length - 2);\n                } else {\n                    parsedTime = parseFloat(timingStr.substr(0, timingStr.length - 2));\n                    metric = timingStr.substr(timingStr.length - 1);\n                }\n\n                switch (metric) {\n                    case 'h':\n                        parsedTime = parsedTime * 60 * 60;\n                        break;\n                    case 'm':\n                        parsedTime = parsedTime * 60;\n                        break;\n                    case 's':\n                        break;\n                    case 'ms':\n                        parsedTime = parsedTime * 0.01;\n                        break;\n                    case 'f':\n                        if (frameRate && !isNaN(frameRate)) {\n                            parsedTime = parsedTime / frameRate;\n                        } else {\n                            return NaN;\n                        }\n                        break;\n                }\n\n                return parsedTime;\n            }\n\n            return NaN;\n        },\n\n        passStructuralConstraints = function() {\n            var passed = false;\n\n            nodeTt = xmlDoc ? this.domParser.getChildNode(xmlDoc, \"tt\") : null;\n            nodeHead = nodeTt ? this.domParser.getChildNode(nodeTt, \"head\") : null;\n            nodeLayout = nodeHead ? this.domParser.getChildNode(nodeHead, \"layout\") : null;\n            nodeStyling = nodeHead ? this.domParser.getChildNode(nodeHead, \"styling\") : null;\n            nodeBody = nodeTt ? this.domParser.getChildNode(nodeTt, \"body\") : null;\n\n            // R001 - A document must contain a tt element.\n            // R002 - A document must contain both a head and body element.\n            // R003 - A document must contain both a styling and a layout element.\n            if (nodeTt && nodeHead && /*nodeLayout && nodeStyling &&*/ nodeBody) {\n                passed = true;\n            }\n\n            // R0008 - A document must contain a ttp:profile element where the use attribute of that element is specified as http://www.w3.org/ns/ttml/profile/sdp-us.\n            // ORANGE: The R0008 requirement is removed in the parser implementation to make it work with non-US profiles\n            return passed;\n        },\n\n        findStyleElement = function(nodeTab, styleElementName, defaultTTMLValue) {\n            var styleName,\n                regionName,\n                resu = null,\n                i = 0;\n\n            for (i = 0; i < nodeTab.length; i += 1) {\n                //search styleElementName in node Element\n                resu = findParameterElement.call(this, [nodeTab[i]], globalPrefStyleNameSpace, styleElementName);\n\n                if (resu) {\n                    return resu;\n                }\n\n                //search style reference in node Element\n                styleName = findParameterElement.call(this, [nodeTab[i]], globalPrefTTNameSpace, 'style');\n                if (styleName) {\n                    //search if styleElementName is defined in the specific style reference\n                    resu = searchInTab.call(this, tabStyles, styleName, styleElementName);\n                    if (resu) {\n                        return resu;\n                    }\n\n                    //search if others styles are referenced in the selected one\n                    styleName = searchInTab.call(this, tabStyles, styleName, 'style');\n\n                    while (styleName) {\n                        //search in this other style\n                        resu = searchInTab.call(this, tabStyles, styleName, styleElementName);\n                        if (resu) {\n                            return resu;\n                        }\n                        styleName = searchInTab.call(this, tabStyles, styleName, 'style');\n                    }\n                }\n\n                //search region reference in node Element\n                regionName = findParameterElement.call(this, [nodeTab[i]], globalPrefTTNameSpace, 'region');\n                if (regionName) {\n                    //region reference has been found in the node element, search styleElementName definition in this specified region\n                    resu = searchInTab.call(this, tabRegions, regionName, styleElementName);\n\n                    if (resu) {\n                        return resu;\n                    }\n\n                    styleName = searchInTab.call(this, tabRegions, regionName, 'style');\n                    //search style reference in this specified region Element\n\n                    if (styleName) {\n                        //specified style has been detected\n                        //browse attributes of this style to detect styleElementName attribute\n                        resu = searchInTab.call(this, tabStyles, styleName, styleElementName);\n                        if (resu) {\n                            return resu;\n                        }\n\n                        //search if others styles are referenced in the selected one\n                        styleName = searchInTab.call(this, tabStyles, styleName, 'style');\n\n                        while (styleName) {\n                            //search in this other style\n                            resu = searchInTab.call(this, tabStyles, styleName, styleElementName);\n                            if (resu) {\n                                return resu;\n                            }\n                            styleName = searchInTab.call(this, tabStyles, styleName, 'style');\n                        }\n                    }\n                }\n            }\n\n            return defaultTTMLValue !== undefined ? defaultTTMLValue : null;\n        },\n\n        searchInTab = function(tab, elementNameReference, styleElementName) {\n            var i = 0,\n                returnValue = null,\n                j = 0;\n\n            for (i = 0; i < tab[elementNameReference].length; i += 1) {\n                //search with style nameSpaces\n                for (j = 0; j < globalPrefStyleNameSpace.length; j += 1) {\n                    returnValue = tab[elementNameReference].getNamedItem(styleElementName);\n                    if (!returnValue) {\n                        returnValue = tab[elementNameReference].getNamedItemNS(globalPrefStyleNameSpace[j], styleElementName);\n                    }\n                    if (returnValue) {\n                        return returnValue.nodeValue;\n                    }\n                }\n                //search with main nameSpaces\n                for (j = 0; j < globalPrefTTNameSpace.length; j += 1) {\n                    returnValue = tab[elementNameReference].getNamedItem(styleElementName);\n                    if (!returnValue) {\n                        returnValue = tab[elementNameReference].getNamedItemNS(globalPrefTTNameSpace[j], styleElementName);\n                    }\n                    if (returnValue) {\n                        return returnValue.nodeValue;\n                    }\n                }\n            }\n\n            return null;\n        },\n\n        findParameterElement = function(nodeTab, nameSpaceTab, parameterElementName) {\n            var parameterValue = null,\n                i = 0,\n                k = 0;\n            //search for each node in the noteTab, if the parameterElementName is defined\n            for (i = 0; i < nodeTab.length; i += 1) {\n                for (k = 0; k < nameSpaceTab.length; k += 1) {\n                    parameterValue = this.domParser.getAttributeValue(nodeTab[i], parameterElementName, nameSpaceTab[k]);\n                    if (parameterValue) {\n                        return parameterValue;\n                    }\n                }\n            }\n\n            return parameterValue;\n        },\n\n        computeCellResolution = function(cellResolution) {\n            if (!cellResolution) {\n                //default cell resolution defined in TTML documentation\n                cellResolution = '32 15';\n            }\n\n            var computedCellResolution = cellResolution,\n                i = 0;\n\n            computedCellResolution = computedCellResolution.split(' ');\n\n            for (i = 0; i < computedCellResolution.length; i += 1) {\n                computedCellResolution[i] = parseFloat(computedCellResolution[i]);\n            }\n\n            return computedCellResolution;\n        },\n\n        getStyle = function(nodeElementsTab, rootExtent){\n            var cssStyle = {\n                    backgroundColor: null,\n                    color: null,\n                    fontSize: null,\n                    fontFamily: null,\n                    fontStyle: null,\n                    textOutline: {\n                        color: null,\n                        with: null\n                    },\n                    textAlign: null,\n                    displayAlign: null,\n                    origin: null,\n                    extent: null,\n                    cellResolution: null,\n                    rootExtent: rootExtent,\n                    showBackground: null\n                };\n\n            cssStyle.backgroundColor = findStyleElement.call(this, nodeElementsTab, 'backgroundColor', 'transparent');\n            cssStyle.color = findStyleElement.call(this, nodeElementsTab, 'color');\n            cssStyle.fontSize = findStyleElement.call(this, nodeElementsTab, 'fontSize');\n            cssStyle.fontFamily = findStyleElement.call(this, nodeElementsTab, 'fontFamily');\n            cssStyle.fontStyle = findStyleElement.call(this, nodeElementsTab, 'fontStyle', 'normal');\n            cssStyle.textOutline = findStyleElement.call(this, nodeElementsTab, 'textOutline');\n            cssStyle.extent = findStyleElement.call(this, nodeElementsTab, 'extent');\n            cssStyle.origin = findStyleElement.call(this, nodeElementsTab, 'origin');\n            cssStyle.textAlign = findStyleElement.call(this, nodeElementsTab, 'textAlign', 'start');\n            cssStyle.displayAlign = findStyleElement.call(this, nodeElementsTab, 'displayAlign', 'before');\n            cssStyle.showBackground = findStyleElement.call(this, nodeElementsTab, 'showBackground');\n            cssStyle.cellResolution = findParameterElement.call(this, nodeElementsTab, globalPrefParameterNameSpace, 'cellResolution');\n            cssStyle.cellResolution = computeCellResolution(cssStyle.cellResolution);\n\n            return cssStyle;\n        },\n\n        internalParse = function(data) {\n            var captionArray = [],\n                errorMsg,\n                regions,\n                region,\n                previousStartTime = null,\n                previousEndTime = null,\n                startTime,\n                endTime,\n                cssStyle = null,\n                caption,\n                divBody,\n                i,\n                textDatas,\n                j,\n                k,\n                rootExtent,\n                textNodes,\n                textValue = \"\",\n                imageRef,\n                ttmlRenderingType = \"\",\n                lastCaption;\n\n            try {\n\n                if (this.videoModel.getTTMLRenderingDiv() !== null) {\n                    ttmlRenderingType = 'html';\n                }\n\n                xmlDoc = this.domParser.createXmlTree(data);\n\n                if (!passStructuralConstraints.call(this)) {\n                    errorMsg = \"TTML document has incorrect structure\";\n                    return Q.reject(errorMsg);\n                }\n\n                for (i = 0; i < globalPrefParameterNameSpace.length; i += 1) {\n                    frameRate = this.domParser.getAttributeValue(nodeTt, 'frameRate', globalPrefParameterNameSpace[i]) ? parseInt(frameRate, 10) : null;\n                }\n\n                divBody = this.domParser.getChildNodes(nodeBody, 'div');\n\n                if (!divBody || divBody.length === 0) {\n                    errorMsg = \"TTML body document does not contain any div\";\n                    return Q.reject(errorMsg);\n                }\n\n                //get all styles informations\n                tabStyles = this.domParser.getAllSpecificNodes(nodeTt, 'style');\n                //get all regions informations\n                tabRegions = this.domParser.getAllSpecificNodes(nodeTt, 'region');\n                //get all images url\n                tabImages = this.domParser.getAllSpecificNodes(nodeTt, 'image');\n                //search if there is a root container size\n                rootExtent = findStyleElement.call(this, [nodeTt], 'extent');\n\n                //browse all the different div elements\n                for (k = 0; k < divBody.length; k += 1) {\n                    //is it images subtitles?\n                    imageRef = findParameterElement.call(this, [divBody[k]], globalPrefSMPTENameSpace, 'backgroundImage');\n                    if (imageRef && tabImages[imageRef.substring(1)] !== undefined) {\n\n                        startTime = parseTimings(findParameterElement.call(this, [divBody[k]], globalPrefTTNameSpace, 'begin'));\n                        endTime = parseTimings(findParameterElement.call(this, [divBody[k]], globalPrefTTNameSpace, 'end'));\n                        \n                        cssStyle = getStyle.call(this, [divBody[k], nodeTt], rootExtent);\n                       \n                        caption = {\n                            start: startTime,\n                            end: endTime,\n                            data: 'data:image/' + tabImages[imageRef.substring(1)].imagetype.nodeValue + ';base64, ' + this.domParser.getChildNode(tabImages[imageRef.substring(1)], '#text').nodeValue,\n                            type: 'image',\n                            line: 80,\n                            style: cssStyle\n                        };\n                        captionArray.push(caption);\n                    }\n                    regions = this.domParser.getChildNodes(divBody[k], 'p');\n\n                    if (!regions || regions.length === 0) {\n                        errorMsg = \"TTML document does not contain any cues\";\n                    } else {\n                        for (i = 0; i < regions.length; i += 1) {\n                            caption = null;\n                            cssStyle = null;\n                            region = regions[i];\n\n                            startTime = parseTimings(findParameterElement.call(this, [region], globalPrefTTNameSpace, 'begin'));\n                            endTime = parseTimings(findParameterElement.call(this, [region], globalPrefTTNameSpace, 'end'));\n\n                            if (isNaN(startTime) || isNaN(endTime) || (endTime < startTime)) {\n                                errorMsg = \"TTML document has incorrect timing value\";\n                            } else {\n                                 //is it images subtitles?\n                                imageRef = findParameterElement.call(this, [region], globalPrefSMPTENameSpace, 'backgroundImage');\n                                if (imageRef && tabImages[imageRef.substring(1)] !== undefined) {\n                                    cssStyle = getStyle.call(this, [region, divBody[k], nodeTt], rootExtent);\n                                    caption = {\n                                        start: startTime,\n                                        end: endTime,\n                                        data: 'data:image/' + tabImages[imageRef.substring(1)].imagetype.nodeValue + ';base64, ' + this.domParser.getChildNode(tabImages[imageRef.substring(1)], '#text').nodeValue,\n                                        type: 'image',\n                                        line: 80,\n                                        style: cssStyle\n                                    };\n                                }\n\n                                textDatas = this.domParser.getChildNodes(region, 'span');\n                                //subtitles are set in span\n                                if (textDatas.length > 0) {\n                                    for (j = 0; j < textDatas.length; j++) {\n                                        if (j > 0) {\n                                            textValue += '\\n';\n                                        }\n                                        /******************** Find style informations ***************************************\n                                         *   1- in subtitle paragraph ToDo\n                                         *   2- in style element referenced in the subtitle paragraph\n                                         *   3- in region ToDo\n                                         *   4- in style referenced in the region referenced in the subtitle paragraph\n                                         *   5- in the main div ToDo\n                                         *   6- in the style of the main div\n                                         **************************************************************************************/\n                                        //search style informations once. \n                                        if (j === 0) {\n                                            cssStyle = getStyle.call(this, [textDatas[j], region, nodeBody, nodeTt, divBody[k]], rootExtent);\n                                        }\n\n                                        textNodes = this.domParser.getTextNodesIn(textDatas[j]);\n\n                                        for (var r = 0; r < textNodes.length; r += 1) {\n                                            if (r > 0) {\n                                                textValue += '\\n';\n                                            }\n                                            textValue += textNodes[r].textContent;\n                                        }\n                                    }\n                                    //line and position element have no effect on IE\n                                    //For Chrome line = 80 is a percentage workaround to reorder subtitles\n                                    caption = {\n                                        start: startTime,\n                                        end: endTime,\n                                        data: textValue,\n                                        type: 'text',\n                                        line: 80,\n                                        style: cssStyle\n                                    };\n                                    textValue = \"\";\n                                    captionArray.push(caption);\n                                } else {\n                                    cssStyle = getStyle.call(this, [region, nodeBody, nodeTt], rootExtent);\n\n                                    //line and position element have no effect on IE\n                                    //For Chrome line = 80 is a percentage workaround to reorder subtitles\n                                    //try to detect multi lines subtitle\n                                    if (i > 0) {\n                                        previousStartTime = parseTimings(findParameterElement.call(this, [regions[i - 1]], globalPrefTTNameSpace, 'begin'));\n                                        previousEndTime = parseTimings(findParameterElement.call(this, [regions[i - 1]], globalPrefTTNameSpace, 'end'));\n                                    }\n                                    //workaround to be able to show subtitles on two lines even if startTime and endTime are not equals to the previous values.\n                                    if ((startTime === previousStartTime && endTime === previousEndTime) || (startTime >= previousStartTime && endTime <= previousEndTime)) {\n                                        if (region.textContent !== \"\") {\n                                            //if rendering is done in an internal div, do not add subtitle text with the same time.\n                                            if (ttmlRenderingType === 'html') {\n                                                caption = {\n                                                    start: startTime,\n                                                    end: endTime,\n                                                    data: region.textContent,\n                                                    type: 'text',\n                                                    line: 80,\n                                                    style: cssStyle\n                                                };\n                                            } else {\n                                                if (startTime >= previousStartTime && endTime <= previousEndTime) {\n                                                    lastCaption = captionArray[captionArray.length - 1];\n                                                    lastCaption.end = startTime;\n                                                } else {\n                                                    lastCaption = captionArray.pop();\n                                                }\n                                                caption = {\n                                                    start: startTime,\n                                                    end: endTime,\n                                                    data: lastCaption.data + '\\n' + region.textContent,\n                                                    type: 'text',\n                                                    line: 80,\n                                                    style: cssStyle\n                                                };\n                                            }\n                                        }\n                                    } else {\n\n                                        textNodes = this.domParser.getTextNodesIn(region);\n\n                                        for (j = 0; j < textNodes.length; j += 1) {\n                                            if (j > 0) {\n                                                textValue += '\\n';\n                                            }\n                                            textValue += textNodes[j].textContent;\n                                        }\n                                        if (textValue !== \"\") {\n                                            caption = {\n                                                start: startTime,\n                                                end: endTime,\n                                                data: textValue,\n                                                type: 'text',\n                                                line: 80,\n                                                style: cssStyle\n                                            };\n                                            textValue = \"\";\n                                        }\n                                    }\n                                    if (caption !== null) {\n                                        captionArray.push(caption);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (captionArray.length > 0) {\n                    return Q.when(captionArray);\n                } else {\n                    return Q.reject(errorMsg);\n                }\n\n            } catch (err) {\n                errorMsg = err.message;\n                return Q.reject(errorMsg);\n            }\n        };\n\n    return {\n        domParser: undefined,\n        videoModel: undefined,\n        parse: internalParse\n\n    };\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Akamai Technologies\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Akamai Technologies nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.utils.TTMLRenderer = function() {\n    \"use strict\";\n    var ttmlDiv,\n        subtitleDivTab = [],\n\n        onFullScreenChange = function() {\n            var i = 0;\n\n            for (i = 0; i < subtitleDivTab.length; i++) {\n                applySubtitlesCSSStyle(subtitleDivTab[i], subtitleDivTab[i].ttmlStyle, ttmlDiv);\n            }\n        },\n\n        onSeeking = function() {\n            //used for FF, when the user wants to seek, cueExit is not always sent.\n            this.cleanSubtitles();\n        },\n\n        createSubtitleDiv = function() {\n            var subtitleDiv = document.createElement(\"div\");\n\n            subtitleDiv.style.position = 'absolute';\n            subtitleDiv.style.display = 'flex';\n            subtitleDiv.style.flexDirection = 'row';\n            subtitleDiv.style.overflow = 'initial';\n            subtitleDiv.style.pointerEvents = 'none';\n\n            ttmlDiv.appendChild(subtitleDiv);\n\n            return subtitleDiv;\n        },\n\n        removeSubtitleDiv = function(div) {\n            if (ttmlDiv.hasChildNodes()) {\n                ttmlDiv.removeChild(div);\n            }\n        },\n\n        computeFontSize = function(fontSize, cellUnit) {\n            var computedFontSize,\n                i;\n            if (fontSize && fontSize[fontSize.length - 1] === '%') {\n                computedFontSize = parseFloat(fontSize.substr(0, fontSize.length - 1)) / 100 * cellUnit[1] + 'px';\n            } else if (fontSize && fontSize[fontSize.length - 1] === 'x') {\n                //case in pixels\n                computedFontSize = fontSize;\n            } else if (fontSize && fontSize[fontSize.length - 1] === 'c') {\n                var cellsSize = fontSize.replace(/\\s/g, '').split('c');\n\n                for (i = 0; i < cellsSize.length; i += 1) {\n                    cellsSize[i] = parseFloat(cellsSize[i]);\n                }\n\n                if (isNaN(cellsSize[1])) {\n                    computedFontSize = cellsSize[0] * cellUnit[1] + 'px';\n                } else {\n                    computedFontSize = cellsSize[1] * cellUnit[1] + 'px';\n                }\n            } else { //default value defined in TTML\n                computedFontSize = cellUnit[1] + 'px';\n            }\n\n            return computedFontSize;\n        },\n\n        computeTextOutline = function(textOutline, cellUnit, defaultColor) {\n            var computedTextOutline = {\n                    color: defaultColor,\n                    width: null\n                },\n                formatTextOutlineWidth,\n                textOutlineWidthIndex = 0;\n\n            if (textOutline) {\n                textOutline = textOutline.split(' ');\n\n                //detect if outline color has been defined, if not, outline color should be set to color value\n                if (textOutline[0] && isNaN(textOutline[0][0])) {\n                    computedTextOutline.color = textOutline[0];\n                    textOutlineWidthIndex = 1;\n                } else {\n                    computedTextOutline.color = defaultColor;\n                }\n\n                if (computedTextOutline.color && computedTextOutline.color[0] === '#') {\n                    computedTextOutline.color = hex2rgba_convert(computedTextOutline.color);\n                }\n\n                //detect text outline width, the first length value\n                if (textOutline[textOutlineWidthIndex]) {\n                    //get the last character for text Outline width definition\n                    formatTextOutlineWidth = textOutline[textOutlineWidthIndex][textOutline[textOutlineWidthIndex].length - 1];\n                    switch (formatTextOutlineWidth) {\n                        //definition in cell.\n                        case 'c':\n                            textOutline[textOutlineWidthIndex] = textOutline[textOutlineWidthIndex].split('c');\n                            if (textOutline[textOutlineWidthIndex][0]) {\n                                computedTextOutline.width = textOutline[textOutlineWidthIndex][0] * cellUnit[1] + 'px';\n                            }\n                            break;\n                        case 'x':\n                            //definition in pixel\n                            computedTextOutline.width = textOutline[textOutlineWidthIndex];\n                            break;\n                    }\n                }\n            }\n            return computedTextOutline;\n        },\n\n        hex2rgba_convert = function(hex) {\n            hex = hex.replace('#', '');\n            var r = parseInt(hex.substring(0, 2), 16),\n                g = parseInt(hex.substring(2, 4), 16),\n                b = parseInt(hex.substring(4, 6), 16),\n                a = hex.length > 6 ? parseInt(hex.substring(6, 8), 16) : 255,\n                result = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';\n\n            return result;\n        },\n\n        rgbaTTMLToCss = function(rgbaTTML) {\n            var rgba,\n                resu = rgbaTTML,\n                alpha;\n\n            rgba = rgbaTTML.replace(/^(rgb|rgba)\\(/,'').replace(/\\)$/,'').replace(/\\s/g,'').split(',');\n            if (rgba[rgba.length - 1] > 1) {\n                alpha = parseInt(rgba[rgba.length - 1], 10) / 255;\n                resu = 'rgba('+rgba[0]+','+rgba[1]+','+rgba[2]+','+alpha+')';\n            }\n            return resu;\n        },\n\n        applySubtitlesCSSStyle = function(div, cssStyle, renderingDiv) {\n            var origin,\n                extent,\n                textOutline,\n                rootExtent,\n                cellUnit = [renderingDiv.clientWidth / cssStyle.cellResolution[0], renderingDiv.clientHeight / cssStyle.cellResolution[1]];\n\n            if (div) {\n                if (cssStyle.backgroundColor && cssStyle.backgroundColor[0] === '#') {\n                    cssStyle.backgroundColor = hex2rgba_convert(cssStyle.backgroundColor);\n                }else if (cssStyle.backgroundColor && cssStyle.backgroundColor[3] === 'a') {//detect backgroundColor with an alpha\n                    cssStyle.backgroundColor = rgbaTTMLToCss(cssStyle.backgroundColor);\n                }\n\n                if (cssStyle.color && cssStyle.color[0] === '#') {\n                    cssStyle.color = hex2rgba_convert(cssStyle.color);\n                }else if (cssStyle.color && cssStyle.color[3] === 'a') {//detect backgroundColor with an alpha\n                    cssStyle.color = rgbaTTMLToCss(cssStyle.color);\n                }\n\n                if (cssStyle.origin && cssStyle.origin[cssStyle.origin.length - 1] === '%') {\n                    origin = cssStyle.origin.split('%');\n                    div.style.left = parseInt(origin[0], 10) + '%';\n                    div.style.top = parseInt(origin[1], 10) + '%';\n                    if (cssStyle.extent && cssStyle.extent[cssStyle.extent.length - 1] === '%') {\n                        extent = cssStyle.extent.split('%');\n                        div.style.width = parseInt(extent[0], 10) + '%';\n                        div.style.height = parseInt(extent[1], 10) + '%';\n                    }\n                } else if (cssStyle.origin && cssStyle.origin[cssStyle.origin.length - 1] === 'x') {\n                    origin = cssStyle.origin.split('px');\n                    if (cssStyle.rootExtent && cssStyle.rootExtent[cssStyle.rootExtent.length - 1] === 'x') {\n                        rootExtent = cssStyle.rootExtent.split('px');\n                        var temp = (origin[0] / rootExtent[0]) * renderingDiv.clientWidth;\n                        div.style.left = temp / renderingDiv.clientWidth * 100 + '%';\n                        temp = (origin[1] / rootExtent[1]) * renderingDiv.clientHeight;\n                        div.style.top = temp / renderingDiv.clientHeight * 100 + '%';\n                        if (cssStyle.extent && cssStyle.extent[cssStyle.extent.length - 1] === 'x') {\n                            extent = cssStyle.extent.split('px');\n                            temp = (extent[0] / rootExtent[0]) * renderingDiv.clientWidth;\n                            div.style.width = temp / renderingDiv.clientWidth * 100 + '%';\n                            temp = (extent[1] / rootExtent[1]) * renderingDiv.clientHeight;\n                            div.style.height = temp / renderingDiv.clientHeight * 100 + '%';\n                        }\n                    } else {\n                        div.style.left = origin[0] + \"px\";\n                        div.style.top = origin[1] + \"px\";\n                    }\n                }else if (cssStyle.origin && cssStyle.origin[cssStyle.origin.length - 1] === 'c') {\n                    origin = cssStyle.origin.split('c');\n                    div.style.left = (origin[0] * cellUnit[0]) + \"px\";\n                    div.style.top = (origin[1] * cellUnit[1]) + \"px\";\n                    if (cssStyle.extent && cssStyle.extent[cssStyle.extent.length - 1] === 'c') {\n                        extent = cssStyle.extent.split('c');\n                        div.style.width = (extent[0] * cellUnit[0]) + \"px\";\n                        div.style.height = (extent[1] * cellUnit[1]) + \"px\";\n                    }\n                }\n\n                textOutline = computeTextOutline(cssStyle.textOutline, cellUnit, cssStyle.color);\n                div.style.webkitTextStrokeWidth = textOutline.width;\n                div.style.webkitTextStroke = textOutline.color;\n                switch (cssStyle.textAlign) {\n                    //Values in TTML : left | center | right | start | end\n                    //Values in css : left|right|center|justify|initial|inherit\n                    case 'start':\n                        div.style.justifyContent = 'flex-start';\n                        break;\n                    case 'end':\n                        div.style.justifyContent = 'flex-end';\n                        break;\n                    case 'center':\n                        div.style.justifyContent = 'center';\n                        break;\n                    case 'right':\n                        div.style.justifyContent = 'flex-end';\n                        break; \n                    case 'left':\n                        div.style.justifyContent = 'flex-start';\n                        break; \n                    default:\n                        div.style.justifyContent = 'flex-start';\n                }\n\n                switch (cssStyle.displayAlign) {\n                    //Values in TTML : before | center | after\n                    //Values in css : flex-start| center | flex-end\n                    case 'before':\n                        div.style.alignItems = 'flex-start';\n                        break;\n                    case 'center':\n                        div.style.alignItems = cssStyle.displayAlign;\n                        break;\n                    case 'after':\n                        div.style.alignItems = 'flex-end';\n                        break;                        \n                    default:\n                        div.style.alignItems = 'flex-start';\n                }\n\n                div.style.fontStyle = cssStyle.fontStyle;\n                if (cssStyle.showBackground && cssStyle.showBackground === 'whenActive') {\n                    div.style.backgroundColor = 'transparent';\n                }else {\n                    div.style.backgroundColor = cssStyle.backgroundColor;\n                }\n                div.style.color = cssStyle.color;\n                div.style.fontSize = computeFontSize(cssStyle.fontSize, cellUnit);\n                div.style.fontFamily = cssStyle.fontFamily;\n            }\n        };\n\n    return {\n        videoModel: undefined,\n\n        initialize: function(renderingDiv) {\n            ttmlDiv = renderingDiv;\n            document.addEventListener('webkitfullscreenchange', onFullScreenChange.bind(this));\n            document.addEventListener('mozfullscreenchange', onFullScreenChange.bind(this));\n            document.addEventListener('fullscreenchange', onFullScreenChange.bind(this));\n            this.videoModel.listen(\"seeking\", onSeeking.bind(this));\n        },\n\n        cleanSubtitles: function() {\n            var i = 0;\n\n            for (i = 0; i < subtitleDivTab.length; i++) {\n                removeSubtitleDiv(subtitleDivTab[i]);\n            }\n            subtitleDivTab = [];\n        },\n\n        onCueEnter: function(e) {\n            var newDiv = createSubtitleDiv();\n\n            if (e.currentTarget.style) {\n                applySubtitlesCSSStyle(newDiv, e.currentTarget.style, ttmlDiv);\n                newDiv.ttmlStyle = e.currentTarget.style;\n            }\n\n            if (e.currentTarget.type !== 'image') {\n                var p = document.createElement('p');\n                newDiv.appendChild(p);\n                p.innerText = e.currentTarget.text;\n                p.style.marginTop = 'auto';\n                if (newDiv.ttmlStyle && newDiv.ttmlStyle.showBackground && newDiv.ttmlStyle.showBackground === 'whenActive') {\n                    p.style.backgroundColor = e.currentTarget.style.backgroundColor;\n                }\n            } else {\n                var img = new Image();\n                img.style.height = 'auto';\n                img.style.width = 'auto';\n                img.src = e.currentTarget.text;\n                newDiv.appendChild(img);\n            }\n            newDiv.data = e.currentTarget.text;\n            subtitleDivTab.push(newDiv);\n        },\n\n        onCueExit: function(e) {\n            var i = 0;\n\n            for (i = 0; i < subtitleDivTab.length; i++) {\n                if ((e.currentTarget.text === subtitleDivTab[i].data) && (subtitleDivTab[i].ttmlStyle === e.currentTarget.style)) {\n                    break;\n                }\n            }\n            removeSubtitleDiv(subtitleDivTab[i]);\n            subtitleDivTab.splice(i, 1);\n        }\n    };\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Akamai Technologies\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Akamai Technologies nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.dependencies.TextController = function() {\n\n    var LOADING = \"LOADING\",\n        //LOADED = \"LOADED\",\n        READY = \"READY\",\n        initialized = false,\n        periodInfo = null,\n        mediaSource,\n        data,\n        buffer,\n        availableRepresentations,\n        state = READY,\n        setState = function(value) {\n            this.debug.log(\"TextController setState to:\" + value);\n            state = value;\n        },\n        startPlayback = function() {\n\n            if (!initialized || state !== READY) {\n                return;\n            }\n\n            var self = this;\n            // TODO Multiple tracks can be handled here by passing in quality level.\n            self.indexHandler.getInitRequest(availableRepresentations[0]).then(\n                function(request) {\n                    //self.debug.log(\"Loading text track initialization: \" + request.url);\n                    //self.debug.log(request);\n                    self.fragmentLoader.load(request).then(onBytesLoaded.bind(self, request), onBytesError.bind(self, request));\n                    setState.call(self, LOADING);\n                }\n            );\n        },\n        doStart = function() {\n            startPlayback.call(this);\n        },\n\n        updateRepresentations = function(data, periodInfo) {\n            var adaptations,\n                manifest = this.manifestModel.getValue(),\n                idx;\n\n            idx = this.manifestExt.getDataIndex(data, manifest, periodInfo.index);\n\n            adaptations = this.manifestExt.getAdaptationsForPeriod(manifest, periodInfo);\n            return this.manifestExt.getRepresentationsForAdaptation(manifest, adaptations[idx]);\n        },\n\n        onBytesLoaded = function(request, response) {\n            var self = this;\n            //self.debug.log(\" Text track Bytes finished loading: \" + request.url);\n            // ORANGE: add request parameter to retrieve startTime and timescale in fragmentController\n            self.fragmentController.process(response.data, request).then(\n                function(data) {\n                    if (data !== null) {\n                        //self.debug.log(\"Push text track bytes: \" + data.byteLength);\n                        self.sourceBufferExt.append(buffer, data, self.videoModel);\n                    }\n                }\n            );\n        },\n\n        onBytesError = function( /*request*/ ) {};\n\n    return {\n        videoModel: undefined,\n        fragmentLoader: undefined,\n        fragmentController: undefined,\n        indexHandler: undefined,\n        sourceBufferExt: undefined,\n        manifestModel: undefined,\n        manifestExt: undefined,\n        debug: undefined,\n        initialize: function(periodInfo, data, buffer, videoModel, source) {\n            var self = this;\n\n            self.setVideoModel(videoModel);\n            self.setBuffer(buffer);\n            self.setMediaSource(source);\n\n            self.updateData(data, periodInfo);\n\n            initialized = true;\n            \n            startPlayback.call(self);\n        },\n\n        setPeriodInfo: function(value) {\n            periodInfo = value;\n        },\n\n        getPeriodIndex: function() {\n            return periodInfo.index;\n        },\n\n        getVideoModel: function() {\n            return this.videoModel;\n        },\n\n        setVideoModel: function(value) {\n            this.videoModel = value;\n        },\n\n        getData: function() {\n            return data;\n        },\n\n        setData: function(value) {\n            data = value;\n        },\n\n        getBuffer: function() {\n            return buffer;\n        },\n\n        setBuffer: function(value) {\n            buffer = value;\n        },\n\n        setMediaSource: function(value) {\n            mediaSource = value;\n        },\n\n        updateData: function(dataValue, periodInfoValue) {\n            data = dataValue;\n            periodInfo = periodInfoValue;\n\n            availableRepresentations = updateRepresentations.call(this, data, periodInfo);\n            setState.call(this, READY);\n            startPlayback.call(this);\n        },\n\n        reset: function(errored) {\n            if (!errored) {\n                this.sourceBufferExt.abort(mediaSource, buffer);\n                this.sourceBufferExt.removeSourceBuffer(mediaSource, buffer);\n            }\n        },\n\n        start: doStart\n    };\n};\n\nMediaPlayer.dependencies.TextController.prototype = {\n    constructor: MediaPlayer.dependencies.TextController\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Akamai Technologies\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Akamai Technologies nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.dependencies.TextSourceBuffer = function () {\n\n    var video,\n        data,\n        mimeType,\n\n        decodeUtf8 = function(arrayBuffer) {\n            var result = \"\",\n                i = 0,\n                c = 0,\n                c2 = 0,\n                c3 = 0,\n                data = new Uint8Array(arrayBuffer);\n\n            // If we have a BOM skip it\n            if (data.length >= 3 && data[0] === 0xef && data[1] === 0xbb && data[2] === 0xbf) {\n                i = 3;\n            }\n\n            while (i < data.length) {\n                c = data[i];\n\n                if (c < 128) {\n                    result += String.fromCharCode(c);\n                    i++;\n                } else if (c > 191 && c < 224) {\n                    if (i + 1 >= data.length) {\n                        throw \"UTF-8 Decode failed. Two byte character was truncated.\";\n                    }\n                    c2 = data[i + 1];\n                    result += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n                    i += 2;\n                } else {\n                    if (i + 2 >= data.length) {\n                        throw \"UTF-8 Decode failed. Multi byte character was truncated.\";\n                    }\n                    c2 = data[i + 1];\n                    c3 = data[i + 2];\n                    result += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n                    i += 3;\n                }\n            }\n            return result;\n        },\n\n        buffered = {\n            length: 0,\n            ranges: [],\n\n            start: function(index) {\n                return this.ranges[index].start;\n            },\n\n            end: function(index) {\n                return this.ranges[index].end;\n            },\n\n            addRange: function(start, end) {\n                var i = 0,\n                    rangesUpdated = false,\n                    tolerance = 0.01;\n\n                //detect discontinuity in ranges.\n                for (i = 0; i < this.ranges.length; i++) {\n                    if (this.ranges[i].end <= (start + tolerance) && this.ranges[i].end >= (start - tolerance)) {\n                        rangesUpdated = true;\n                        this.ranges[i].end = end;\n                    }\n\n                    if (this.ranges[i].start <= (end + tolerance) && this.ranges[i].start >= (end - tolerance)) {\n                        rangesUpdated = true;\n                        this.ranges[i].start = start;\n                    }\n                }\n\n                if (!rangesUpdated) {\n                    this.ranges.push({\n                        start: start,\n                        end: end\n                    });\n                    this.length = this.length + 1;\n\n                    // TimeRanges must be normalized\n                    this.ranges.sort(function(a, b) {\n                        return a.start - b.start;\n                    });\n                }\n            },\n\n            removeRange: function(start, end) {\n                var i = 0;\n                for (i = this.ranges.length - 1; i >= 0; i -= 1) {\n                    if (((end === undefined || end === -1) || (this.ranges[i].end <= end)) &&\n                        ((start === undefined || start === -1) || (this.ranges[i].start >= start))) {\n                        this.ranges.splice(i, 1);\n                    }\n                }\n\n                this.length = this.ranges.length;\n            },\n\n            reset: function() {\n                this.length = 0;\n                this.ranges = [];\n            }\n        };\n\n    return {\n        system:undefined,\n        eventBus:undefined,\n        errHandler: undefined,\n        textTrackExtensions: undefined,\n        buffered: buffered,\n\n        initialize: function (type, bufferController) {\n            mimeType = type;\n            video = bufferController.getVideoModel().getElement();\n            data = bufferController.getData();\n            buffered.reset();\n        },\n\n        remove: function(start, end) {\n            if (start < 0 || start >= end) {\n                throw \"INVALID_ACCESS_ERR\";\n            }\n\n            this.textTrackExtensions.deleteCues(video, false, start, end);\n            this.buffered.removeRange(start, end);\n        },\n\n        append: function (bytes, request) {\n            var self = this,\n                ccContent = decodeUtf8(bytes),\n                cues = self.getParser().parse(ccContent, request);\n\n            if (video.textTracks.length === 0) {\n                // We need to create the TextTrack\n                self.textTrackExtensions.addTextTrack(video, [], data.Representation_asArray[0].id, data.lang, true);\n            }\n\n            if (video.textTracks.length === 0) {\n                // Failed to create TextTrack, should never happen\n                return;\n            }\n\n            self.textTrackExtensions.addCues(video.textTracks[0], cues);\n\n            if (request) {\n                self.buffered.addRange(request.startTime, request.startTime + request.duration);\n            }\n        },\n\n        abort: function() {\n            this.textTrackExtensions.deleteCues(video);\n            this.buffered.reset();\n        },\n\n        getParser: function() {\n            var parser;\n\n            if (mimeType === \"text/vtt\") {\n                parser = this.system.getObject(\"vttParser\");\n            } /*else if (mimeType === \"application/ttml+xml\") {\n                parser = this.system.getObject(\"ttmlParser\");\n            }*/\n\n            return parser;\n        },\n\n        addEventListener: function (type, listener, useCapture) {\n            this.eventBus.addEventListener(type, listener, useCapture);\n        },\n\n        removeEventListener: function (type, listener, useCapture) {\n            this.eventBus.removeEventListener(type, listener, useCapture);\n        }\n    };\n};\n\nMediaPlayer.dependencies.TextSourceBuffer.prototype = {\n    constructor: MediaPlayer.dependencies.TextSourceBuffer\n};\n","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Akamai Technologies nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// Orange: This Source Buffer processes TTML+XML subtitles encapsulated in the mp4\n//         This format is used by smoothstreaming headends\n\nMediaPlayer.dependencies.TextTTMLXMLMP4SourceBuffer = function() {\n\n    var video,\n        mimeType,\n        currentLang,\n        currentId,\n\n        // We need to simulate TimeRanges, as defined \n        // by Media Streaming Extensions.\n        // start() and end() functions must be provided,\n        // as player checks the buffer level using these\n\n        buffered = {\n            length: 0,\n            ranges: [],\n\n            start: function(index) {\n                return this.ranges[index].start;\n            },\n\n            end: function(index) {\n                return this.ranges[index].end;\n            },\n\n            addRange: function(start, end) {\n                var i = 0,\n                    rangesUpdated = false,\n                    tolerance = 0.01;\n\n                //detect discontinuity in ranges.\n                for (i = 0; i < this.ranges.length; i++) {\n                    if (this.ranges[i].end <= (start + tolerance) && this.ranges[i].end >= (start - tolerance)) {\n                        rangesUpdated = true;\n                        this.ranges[i].end = end;\n                    }\n\n                    if (this.ranges[i].start <= (end + tolerance) && this.ranges[i].start >= (end - tolerance)) {\n                        rangesUpdated = true;\n                        this.ranges[i].start = start;\n                    }\n                }\n\n                if (!rangesUpdated) {\n                    this.ranges.push({\n                        start: start,\n                        end: end\n                    });\n                    this.length = this.length + 1;\n\n                    // TimeRanges must be normalized\n                    this.ranges.sort(function(a, b) {\n                        return a.start - b.start;\n                    });\n                }\n            },\n\n            removeRange: function(start, end) {\n                var i = 0;\n                for (i = this.ranges.length - 1; i >= 0; i -= 1) {\n                    if (((end === undefined || end === -1) || (this.ranges[i].end <= end)) &&\n                        ((start === undefined || start === -1) || (this.ranges[i].start >= start))) {\n                        this.ranges.splice(i, 1);\n                    }\n                }\n\n                this.length = this.ranges.length;\n            },\n\n            reset: function() {\n                this.length = 0;\n                this.ranges = [];\n            }\n        };\n\n    return {\n        updating: false,\n        system: undefined,\n        eventBus: undefined,\n        buffered: buffered,\n        textTrackExtensions: undefined,\n        ttmlParser: undefined,\n        debug: undefined,\n        manifestModel: undefined,\n\n        initialize: function(type, bufferController, subtitleData) {\n            mimeType = type;\n            video = bufferController.getVideoModel().getElement();\n            buffered.reset();\n            currentLang = subtitleData.lang;\n            currentId = subtitleData.id;\n        },\n        remove: function(start, end) {\n            /*If start is negative or greater than duration, then throw an INVALID_ACCESS_ERR exception and abort these steps.\n            If end is less than or equal to start, then throw an INVALID_ACCESS_ERR exception and abort these steps.\n            If this object has been removed from the sourceBuffers attribute of the parent media source then throw an INVALID_STATE_ERR exception and abort these steps.\n            If the updating attribute equals true, then throw an INVALID_STATE_ERR exception and abort these steps.\n            If the readyState attribute of the parent media source is in the \"ended\" state then run the following steps:\n\n            Set the readyState attribute of the parent media source to \"open\"\n            Queue a task to fire a simple event named sourceopen at the parent media source .\n            Set the updating attribute to true.\n            Queue a task to fire a simple event named updatestart at this SourceBuffer object.\n            Return control to the caller and run the rest of the steps asynchronously.\n            Run the coded frame removal algorithm with start and end as the start and end of the removal range.\n            Set the updating attribute to false.\n            Queue a task to fire a simple event named update at this SourceBuffer object.\n            Queue a task to fire a simple event named updateend at this SourceBuffer object.*/\n            if (start < 0 || start >= end) {\n                throw \"INVALID_ACCESS_ERR\";\n            }\n\n            this.getTextTrackExtensions().deleteCues(video, false, start, end);\n            this.buffered.removeRange(start, end);\n        },\n\n        append: function(bytes) {\n            var self = this,\n                file = mp4lib.deserialize(bytes),\n                moov = file.getBoxByType('moov'),\n                mvhd,\n                moof,\n                mdat,\n                traf,\n                tfhd,\n                tfdt,\n                trun,\n                subs,\n                fragmentStart,\n                fragmentDuration = 0,\n                ttmlData,\n                encoding = 'utf-8';\n\n            //no mp4, all the subtitles are in one xml file\n            if (mimeType === 'application/ttml+xml') {\n                this.track = this.textTrackExtensions.addTextTrack(video, [], currentId, currentLang, true);\n\n                //detect utf-16 encoding\n                if (self.isUTF16(bytes)) {\n                    encoding = 'utf-16';\n                }\n\n                this.convertUTFToString(bytes, encoding)\n                    .then(function(result) {\n                        self.ttmlParser.parse(result).then(function(cues) {\n                            if (cues) {\n\n                                self.textTrackExtensions.addCues(self.track, cues);\n                                self.buffered.addRange(0, video.duration);\n                                self.eventBus.dispatchEvent({\n                                    type: \"updateend\"\n                                });\n                            }\n                        }, function( /*error*/ ) {\n                            //self.debug.error(\"[TextTTMLXMLMP4SourceBuffer] error parsing TTML \"+error);\n                        });\n                    });\n                return;\n            }\n\n            if (moov) {\n                // This must be an init segment, if it has a moov box.\n                // We need it to read the timescale, as it will be \n                // used to compute fragments time ranges.\n\n                mvhd = moov.getBoxByType('mvhd');\n                self.timescale = mvhd.timescale;\n\n                // Also, it is a good moment to set up a text track on videoElement\n                // TODO: set up name and language \n                this.track = this.textTrackExtensions.addTextTrack(video, [], currentId, currentLang, true);\n                this.eventBus.dispatchEvent({\n                    type: \"updateend\"\n                });\n                return;\n            }\n\n            moof = file.getBoxByType('moof');\n            if (moof) {\n\n                // This is a subtitles track fragment\n                // let's decode the data and add captions to video element\n                mdat = file.getBoxByType('mdat');\n\n                // We need to update TimeRanges.                            \n                // assume that there is a single text sample in fragment\n                traf = moof.getBoxByType('traf');\n                tfhd = traf.getBoxByType('tfhd');\n                tfdt = traf.getBoxByType('tfdt');\n                trun = traf.getBoxByType('trun');\n                subs = traf.getBoxByType('subs');\n\n                fragmentStart = tfdt.baseMediaDecodeTime / self.timescale;\n                fragmentDuration = 0;\n                if (trun.flags & 0x000100) {\n                    fragmentDuration = trun.samples_table[0].sample_duration / self.timescale;\n                } else {\n                    fragmentDuration = tfhd.default_sample_duration / self.timescale;\n                }\n\n                self.buffered.addRange(fragmentStart, fragmentStart + fragmentDuration);\n                \n                if (subs) {\n                    for (var i = 0; i < subs.entry_count; i++) {\n                        for (var j = 0; j < subs.entry[i].subsample_count; j++) {\n                            //the first subsample is the one in which TTML text is set\n                            ttmlData = mdat.data.subarray(0, subs.entry[i].subSampleEntries[0].subsample_size);\n                            break;\n                        }\n                    }\n                } else {\n                    ttmlData = mdat.data;\n                }\n\n                //detect utf-16 encoding\n                if (self.isUTF16(ttmlData)) {\n                    encoding = 'utf-16';\n                }\n                // parse data and add to cues\n                self.convertUTFToString(ttmlData, encoding)\n                    .then(function(result) {\n                        self.ttmlParser.parse(result).then(function(cues) {\n                            var i,\n                            manifest = self.manifestModel.getValue();\n\n                            if (cues) {\n                                if (manifest.name === 'MSS') {\n                                    for (i = 0; i < cues.length; i += 1) {\n                                        cues[i].start = cues[i].start + fragmentStart;\n                                        cues[i].end = cues[i].end + fragmentStart;\n                                    }\n                                }\n\n                                self.textTrackExtensions.addCues(self.track, cues);\n\n                                self.eventBus.dispatchEvent({\n                                    type: \"updateend\"\n                                });\n                            }\n                        }, function( /*error*/ ) {\n                            //self.debug.error(\"[TextTTMLXMLMP4SourceBuffer] error parsing TTML \"+error);\n                        });\n                    });\n            }\n            return;\n        },\n\n        convertUTFToString: function(buf, encoding) {\n            var deferred = Q.defer(),\n                blob = new Blob([buf], {\n                    type: \"text/xml\"\n                }),\n                f = new FileReader();\n\n            f.onload = function(e) {\n                deferred.resolve(e.target.result);\n            };\n            f.readAsText(blob, encoding);\n\n            return deferred.promise;\n        },\n\n        /**\n         * UTF-16 (LE or BE)\n         *\n         * RFC2781: UTF-16, an encoding of ISO 10646\n         *\n         * @link http://www.ietf.org/rfc/rfc2781.txt\n         * @private\n         * @ignore\n         */\n        isUTF16: function(data) {\n            var i = 0;\n            var len = data && data.length;\n            var pos = null;\n            var b1, b2, next, prev;\n\n            if (len < 2) {\n                if (data[0] > 0xFF) {\n                    return false;\n                }\n            } else {\n                b1 = data[0];\n                b2 = data[1];\n                if (b1 === 0xFF && // BOM (little-endian)\n                    b2 === 0xFE) {\n                    return true;\n                }\n                if (b1 === 0xFE && // BOM (big-endian)\n                    b2 === 0xFF) {\n                    return true;\n                }\n\n                for (; i < len; i++) {\n                    if (data[i] === 0x00) {\n                        pos = i;\n                        break;\n                    } else if (data[i] > 0xFF) {\n                        return false;\n                    }\n                }\n\n                if (pos === null) {\n                    return false; // Non ASCII\n                }\n\n                next = data[pos + 1]; // BE\n                if (next !== void 0 && next > 0x00 && next < 0x80) {\n                    return true;\n                }\n\n                prev = data[pos - 1]; // LE\n                if (prev !== void 0 && prev > 0x00 && prev < 0x80) {\n                    return true;\n                }\n            }\n\n            return false;\n        },\n\n        UpdateLang: function(id, lang){\n            currentId = id;\n            currentLang = lang;\n        },\n\n        abort: function() {\n            this.getTextTrackExtensions().deleteCues(video, true);\n        },\n\n        getTextTrackExtensions: function() {\n            return this.textTrackExtensions;\n        },\n\n        addEventListener: function(type, listener, useCapture) {\n            this.eventBus.addEventListener(type, listener, useCapture);\n            if (!this.updating)\n                this.eventBus.dispatchEvent({\n                    type: \"updateend\"\n                });\n        },\n\n        removeEventListener: function(type, listener, useCapture) {\n            this.eventBus.removeEventListener(type, listener, useCapture);\n        }\n    };\n};\n\nMediaPlayer.dependencies.TextTTMLXMLMP4SourceBuffer.prototype = {\n    constructor: MediaPlayer.dependencies.TextTTMLXMLMP4SourceBuffer\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Akamai Technologies\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Akamai Technologies nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.utils.TextTrackExtensions = function() {\n    \"use strict\";\n    var Cue,\n        currentLanguage = \"\",\n        ttmlRenderer = null;\n\n    return {\n        system: undefined,\n        eventBus: undefined,\n        videoModel: undefined,\n        debug: undefined,\n        config: undefined,\n\n        setup: function() {\n            Cue = window.VTTCue || window.TextTrackCue;\n        },\n\n        cueEnter: function(subtitle_style, subtitle_text, subtitle_type) {\n            this.eventBus.dispatchEvent({\n                type: \"cueEnter\",\n                data: {\n                    text: subtitle_text,\n                    style: subtitle_style,\n                    type: subtitle_type\n                }\n            });\n        },\n\n        cueExit: function(subtitle_style, subtitle_text, subtitle_type) {\n            this.eventBus.dispatchEvent({\n                type: \"cueExit\",\n                data: {\n                    text: subtitle_text,\n                    style: subtitle_style,\n                    type: subtitle_type\n                }\n            });\n        },\n\n        getCurrentTextTrack: function(video){\n            for(var i=0; i< video.textTracks.length; i++){\n                if(video.textTracks[i].label === 'hascaption'){\n                    return video.textTracks[i];\n                }\n            }\n            return null;\n        },\n\n        addTextTrack: function(video, captionData, label, scrlang, isDefaultTrack) {\n            var track = null,\n                currentItem = null,\n                subtitleDisplayMode = 'subtitles',\n                renderingDiv = this.videoModel.getTTMLRenderingDiv(),\n                i;\n\n            //no function removeTextTrack is defined\n            //add one, only if it's necessary\n            //deleteCues will be very efficient in this case\n            track = this.getCurrentTextTrack(video);\n            if (!track) {\n                if (renderingDiv) {\n                    ttmlRenderer = this.system.getObject(\"ttmlRenderer\");\n                    ttmlRenderer.initialize(renderingDiv);\n                }\n                subtitleDisplayMode = renderingDiv !== null ? 'metadata' : 'subtitles';\n                if (subtitleDisplayMode === 'subtitles') {\n                    subtitleDisplayMode = this.config.getParam(\"TextTrackExtensions.displayModeExtern\", \"boolean\") === true ? 'metadata' : 'subtitles';\n                }\n                //TODO: Ability to define the KIND in the MPD - ie subtitle vs caption....\n                track = video.addTextTrack(subtitleDisplayMode, 'hascaption', scrlang);\n                currentLanguage = scrlang;\n                // track.default is an object property identifier that is a reserved word\n                // The following jshint directive is used to suppressed the warning \"Expected an identifier and instead saw 'default' (a reserved word)\"\n                /*jshint -W024 */\n                track.default = isDefaultTrack;\n                if (subtitleDisplayMode !== 'metadata') {\n                    track.mode = \"showing\";\n                }else{\n                    track.mode = \"hidden\";\n                }\n\n            } else {\n                this.cleanSubtitles();\n                track.default = isDefaultTrack;\n                if (track.mode !== 'showing' && track.kind !== 'metadata') {\n                    track.mode = \"showing\";\n                }\n                currentLanguage = scrlang;\n            }\n\n            for (i = 0; i < captionData.length; i += 1) {\n                currentItem = captionData[i];\n                track.addCue(new Cue(currentItem.start, currentItem.end, currentItem.data));\n            }\n\n            return track;\n        },        \n\n        onCueEnter: function(e) {\n            var renderingDiv = this.videoModel.getTTMLRenderingDiv();\n\n            if (e.currentTarget.type === 'image' && renderingDiv === null) {\n                this.debug.warn(\"[TextTrackExtensions] Rendering image subtitles without div is impossible\");\n            }\n\n            if (renderingDiv) {\n                ttmlRenderer.onCueEnter(e);\n            }\n            this.cueEnter(e.currentTarget.style, e.currentTarget.text, e.currentTarget.type);\n        },\n\n        onCueExit: function(e) {\n            var renderingDiv = this.videoModel.getTTMLRenderingDiv();\n\n            if (renderingDiv) {\n                ttmlRenderer.onCueExit(e);\n            }\n            this.cueExit(e.currentTarget.style, e.currentTarget.text);\n        },\n\n        // Orange: addCues added so it is possible to add cues during playback,\n        //         not only during track initialization\n\n        addCues: function(track, captionData) {\n            var i = 0,\n                currentItem = null,\n                newCue = null;\n\n            for (i = 0; i < captionData.length; i += 1) {\n                currentItem = captionData[i];\n                if (currentItem.start < currentItem.end) {\n                    newCue = new Cue(currentItem.start, currentItem.end, currentItem.data);\n\n                    newCue.id = currentLanguage;\n                    newCue.type = currentItem.type;\n                    newCue.onenter = this.onCueEnter.bind(this);\n                    newCue.onexit = this.onCueExit.bind(this);\n                    newCue.snapToLines = false;\n                    newCue.line = currentItem.line;\n\n                    if (currentItem.style) {\n                        newCue.style = currentItem.style;\n                    }\n\n                    track.addCue(newCue);\n                }\n            }\n        },\n\n        deleteCues: function(video, disabled, start, end) {\n            var track = null,\n                cues = null,\n                lastIdx = null,\n                currentTrackMode,\n                i = 0;\n\n            //when multiple tracks are supported - iterate through and delete all cues from all tracks.\n            if (video) {\n                track = video.textTracks[0];\n                if (track) {\n                    currentTrackMode = track.mode;\n                    //if track mode is disabled, the cues are not accessible\n                    //we have to change the mode value to be sure the delete process is correctly executed.\n                    if (currentTrackMode === 'disabled') {\n                        track.mode = 'hidden';\n                    }\n                    cues = track.cues;\n                    if (cues) {\n                        lastIdx = cues.length - 1;\n\n                        for (i = lastIdx; i >= 0; i -= 1) {\n                            if (((end === undefined || end === -1) || (cues[i].endTime <= end)) &&\n                                ((start === undefined || start === -1) || (cues[i].startTime >= start))) {\n                                track.removeCue(cues[i]);\n                            }\n                        }\n                    }\n                    track.mode = currentTrackMode;\n                }\n            }\n        },\n\n        cleanSubtitles: function() {\n            var renderingDiv = this.videoModel.getTTMLRenderingDiv();\n            if (renderingDiv && ttmlRenderer) {\n                ttmlRenderer.cleanSubtitles();\n            }\n        },\n    };\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Akamai Technologies\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Akamai Technologies nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.utils.VTTParser = function () {\n    \"use strict\";\n\n    var REGEXP_TIMESTAMPMAP = /X-TIMESTAMP-MAP=(.+)/,\n        REGEXP_ATTRIBUTES = /\\s*(.+?)\\s*:((?:\\\".*?\\\")|.*?)(?:,|$)/g,\n        REGEXP_CUE = /(\\S*)[\\s]*-->[\\s]*(\\S*)(.*)/g,\n        REGEXP_LINEBREAK = /(?:\\r\\n|\\r|\\n)/gm,\n\n        parseTimestamp = function(stime) {\n            var timeArray = stime.split(\":\"),\n                len = timeArray.length,\n                time = 0;\n\n            for (var i = 0; i < len; i++) {\n                time += parseFloat(timeArray[i], 10) * Math.pow(60, (len-i-1));\n            }\n\n            return time;\n        },\n\n        parseTimestampMap = function (data) {\n            var match,\n                attrs,\n                name,\n                value,\n                local = null,\n                mpegts = null;\n\n            match = REGEXP_TIMESTAMPMAP.exec(data);\n\n            if (!match) {\n                return -1;\n            }\n            attrs = match[1];\n\n            while ((match = REGEXP_ATTRIBUTES.exec(attrs)) !== null) {\n                name = match[1];\n                value = match[2];\n                switch(name) {\n                    case 'MPEGTS':\n                        mpegts = parseInt(value, 10);\n                        break;\n                    case 'LOCAL':\n                        local = parseTimestamp(value);\n                }\n            }\n\n            if (local === null || mpegts === null) {\n                return -1;\n            }\n\n            // var timestampMap = this.manifestModel.getValue().timestampMap;\n            // if (!timestampMap) {\n            //     return -1;\n            // }\n\n            // var time = timestampMap.local + ((mpegts - timestampMap.mpegts) / 90000.0);\n\n            return {\n                local: local,\n                mpegts: mpegts\n            };\n        },\n\n        getTimestampOffset = function (timestampMap, request) {\n\n            if (timestampMap === -1) {\n                return 0;\n            }\n\n            var streamTimestampMap = this.manifestModel.getValue().timestampMap;\n            if (!streamTimestampMap) {\n                // If MPEGTS timestamp mapping not yet set, then consider segment start time\n                return timestampMap.local - request.startTime;\n            }\n\n            var mpegtsOffset = ((timestampMap.mpegts - streamTimestampMap.mpegts) / 90000.0);\n\n            return (timestampMap.local - streamTimestampMap.local - mpegtsOffset);\n        };\n\n    return {\n        manifestModel: undefined,\n\n        parse: function (data, request) {\n            var cues = [],\n                cue = null,\n                line,\n                cueInfo,\n                i;\n\n            var offset = getTimestampOffset.call(this, parseTimestampMap(data), request);\n            \n            var lines = data.split(REGEXP_LINEBREAK);            \n\n            for (i = 0; i < lines.length; i++) {\n                line = lines[i].trim();\n                if (line.length === 0) {\n                    continue;\n                }\n                if (lines[i].match(REGEXP_CUE)) {\n                    if (cue !== null) {\n                        cues.push(cue);\n                    }\n                    // Start of new cue\n                    cueInfo = lines[i].split(REGEXP_CUE);\n                    cue = {\n                        type: 'text',\n                        line: 80,\n                        start: parseTimestamp(cueInfo[1]) - offset,\n                        end: parseTimestamp(cueInfo[2]) - offset,\n                        // Do not set style, would need to be converted from VTT to TTML in case TTML renderer is used\n                        //style: cueInfo[3].trim(),\n                        data: ''\n                    };\n                } else if (cue !== null) {\n                    cue.data += ((cue.data.length === 0) ? '' : '\\n') + lines[i];\n                }\n            }\n            if (cue !== null) {\n                cues.push(cue);\n            }\n\n            return cues;\n        }\n    };\n};\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.rules.AbandonRequestsRule = function() {\n    \"use strict\";\n\n    var GRACE_TIME_THRESHOLD = 0.5,\n        ABANDON_MULTIPLIER = 2;\n\n    return {\n        debug: undefined,\n        metricsExt:undefined,\n\n        name: \"AbandonRequestRule\",\n\n        execute: function(request, callback) {\n            var now = new Date().getTime(),\n                type = request.streamType,\n                elapsedTime,\n                measuredBandwidth,\n                estimatedTimeOfDownload,\n                switchRequest = new MediaPlayer.rules.SwitchRequest(MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE, MediaPlayer.rules.SwitchRequest.prototype.WEAK);\n\n                if (request.firstByteDate === null || request.aborted) {\n                    this.debug.log(\"[AbandonRequestsRule][\" + type + \"] Request has already been aborted.\");\n                    callback(switchRequest);\n                    return;\n                }\n\n                elapsedTime = (now - request.firstByteDate.getTime()) / 1000;\n\n                if (request.bytesLoaded < request.bytesTotal && elapsedTime >= (request.duration * GRACE_TIME_THRESHOLD)) {\n\n                    measuredBandwidth = request.bytesLoaded / elapsedTime;\n                    estimatedTimeOfDownload = request.bytesTotal / measuredBandwidth;\n\n                    if ((estimatedTimeOfDownload) > (request.duration * ABANDON_MULTIPLIER)) {\n                        switchRequest = new MediaPlayer.rules.SwitchRequest(0, MediaPlayer.rules.SwitchRequest.prototype.STRONG);\n                        this.debug.info(\"[AbandonRequestsRule][\" + type + \"] BW = \" + (measuredBandwidth * 8 / 1000).toFixed(3) + \" kb/s => switch to lowest quality\");\n                    }\n                }\n\n            callback(switchRequest);\n        },\n    };\n};\n\nMediaPlayer.rules.AbandonRequestsRule.prototype = {\n    constructor: MediaPlayer.rules.AbandonRequestsRule\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.rules.BaseRulesCollection = function () {\n    \"use strict\";\n\n    var rules = [],\n        adandonFragmentRules = [];\n\n    return {\n        downloadRatioRule: undefined,\n        insufficientBufferRule: undefined,\n        droppedFramesRule: undefined,\n        abandonRequestRule:undefined,\n \n        getRules: function (type) {\n            switch (type) {\n                case MediaPlayer.rules.BaseRulesCollection.prototype.QUALITY_SWITCH_RULES:\n                    return rules;\n                case MediaPlayer.rules.BaseRulesCollection.prototype.ABANDON_FRAGMENT_RULES:\n                    return adandonFragmentRules;\n                default:\n                    return null;\n            }\n        },\n\n        setup: function () {\n            rules.push(this.downloadRatioRule);\n            rules.push(this.insufficientBufferRule);\n            rules.push(this.droppedFramesRule);\n            adandonFragmentRules.push(this.abandonRequestRule);\n        }\n    };\n};\n\nMediaPlayer.rules.BaseRulesCollection.prototype = {\n    constructor: MediaPlayer.rules.BaseRulesCollection,\n    QUALITY_SWITCH_RULES: \"qualitySwitchRules\",\n    ABANDON_FRAGMENT_RULES: \"abandonFragmentRules\"\n};\n","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.rules.DownloadRatioRule = function() {\n    \"use strict\";\n\n    return {\n        debug: undefined,\n        manifestExt: undefined,\n        metricsExt: undefined,\n        manifestModel: undefined,\n        config: undefined,\n\n        name: \"DownloadRatioRule\",\n\n        checkIndex: function(current, metrics, data) {\n            var requests = this.metricsExt.getHttpRequests(metrics),\n                lastRequest = null,\n                downloadTime,\n                totalTime,\n                calculatedBandwidth,\n                currentBandwidth,\n                latencyInBandwidth,\n                switchUpRatioSafetyFactor,\n                currentRepresentation,\n                count,\n                bandwidths = [],\n                i,\n                q = MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE,\n                totalBytesLength = 0,\n                p = MediaPlayer.rules.SwitchRequest.prototype.DEFAULT;\n\n            if (data && data.hasOwnProperty('type')) {\n                latencyInBandwidth = this.config.getParamFor(data.type, \"ABR.latencyInBandwidth\", \"boolean\", true);\n                switchUpRatioSafetyFactor = this.config.getParamFor(data.type, \"ABR.switchUpRatioSafetyFactor\", \"number\", 1.5);\n                //this.debug.log(\"Checking download ratio rule...\");\n                this.debug.log(\"[DownloadRatioRule][\" + data.type + \"] Checking download ratio rule... (current = \" + current + \")\");\n\n                if (!metrics) {\n                    this.debug.log(\"[DownloadRatioRule][\" + data.type + \"] No metrics, bailing.\");\n                    return new MediaPlayer.rules.SwitchRequest();\n                }\n\n                // Get last valid request\n                i = requests.length - 1;\n                while (i >= 0 && lastRequest === null) {\n                    if (requests[i].tfinish && requests[i].trequest && requests[i].tresponse && requests[i].bytesLength > 0) {\n                        lastRequest = requests[i];\n                    }\n                    i--;\n                }\n\n                if (lastRequest === null) {\n                    this.debug.log(\"[DownloadRatioRule][\" + data.type + \"] No valid requests made for this stream yet, bailing.\");\n                    return new MediaPlayer.rules.SwitchRequest();\n                }\n\n                totalTime = (lastRequest.tfinish.getTime() - lastRequest.trequest.getTime()) / 1000;\n                downloadTime = (lastRequest.tfinish.getTime() - lastRequest.tresponse.getTime()) / 1000;\n\n                if (totalTime <= 0) {\n                    this.debug.log(\"[DownloadRatioRule][\" + data.type + \"] Don't know how long the download of the last fragment took, bailing.\");\n                    return new MediaPlayer.rules.SwitchRequest();\n                }\n\n                if (lastRequest.mediaduration === null ||\n                    lastRequest.mediaduration === undefined ||\n                    lastRequest.mediaduration <= 0 ||\n                    isNaN(lastRequest.mediaduration)) {\n                    this.debug.log(\"[DownloadRatioRule][\" + data.type + \"] Don't know the duration of the last media fragment, bailing.\");\n                    return new MediaPlayer.rules.SwitchRequest();\n                }\n\n                totalBytesLength = lastRequest.bytesLength;\n\n                this.debug.log(\"[DownloadRatioRule][\" + data.type + \"] DL: \" + Number(downloadTime.toFixed(3)) + \"s, Total: \" + Number(totalTime.toFixed(3)) + \"s, Length: \" + totalBytesLength);\n\n                // Take average bandwidth over 3 requests\n                count = 1;\n                while (i >= 0 && count < 3) {\n                    if (requests[i].tfinish && requests[i].trequest && requests[i].tresponse && requests[i].bytesLength > 0) {\n                        var _totalTime = (requests[i].tfinish.getTime() - requests[i].trequest.getTime()) / 1000;\n                        var _downloadTime = (requests[i].tfinish.getTime() - requests[i].tresponse.getTime()) / 1000;\n                        this.debug.log(\"[DownloadRatioRule][\" + data.type + \"] DL: \" + Number(_downloadTime.toFixed(3)) + \"s, Total: \" + Number(_totalTime.toFixed(3)) + \"s, Length: \" + requests[i].bytesLength);\n                        totalTime += _totalTime;\n                        downloadTime += _downloadTime;\n                        totalBytesLength += requests[i].bytesLength;\n                        count += 1;\n                    }\n                    i--;\n                }\n\n                // Set length in bits\n                totalBytesLength *= 8;\n\n                calculatedBandwidth = latencyInBandwidth ? (totalBytesLength / totalTime) : (totalBytesLength / downloadTime);\n\n                this.debug.log(\"[DownloadRatioRule][\" + data.type + \"] BW = \" + Math.round(calculatedBandwidth / 1000) + \" kb/s\");\n\n                if (isNaN(calculatedBandwidth)) {\n                    return new MediaPlayer.rules.SwitchRequest();\n                }\n\n                count = this.manifestExt.getRepresentationCount(data);\n                currentRepresentation = this.manifestExt.getRepresentationFor(current, data);\n                currentBandwidth = this.manifestExt.getBandwidth(currentRepresentation);\n                for (i = 0; i < count; i += 1) {\n                    bandwidths.push(this.manifestExt.getRepresentationBandwidth(data, i));\n                }\n                if (calculatedBandwidth <= currentBandwidth) {\n                    for (i = current - 1; i > 0; i -= 1) {\n                        if (bandwidths[i] <= calculatedBandwidth) {\n                            break;\n                        }\n                    }\n                    q = i;\n                    p = MediaPlayer.rules.SwitchRequest.prototype.WEAK;\n\n                    this.debug.info(\"[DownloadRatioRule][\" + data.type + \"] SwitchRequest: q=\" + q + \"/\" + (count - 1) + \" (\" + bandwidths[q] + \"), p=\" + p);\n                    return new MediaPlayer.rules.SwitchRequest(q, p);\n                } else {\n                    for (i = count - 1; i > current; i -= 1) {\n                        if (calculatedBandwidth > (bandwidths[i] * switchUpRatioSafetyFactor)) {\n                            //this.debug.log(\"[DownloadRatioRule][\" + data.type + \"] bw = \" + calculatedBandwidth + \" results[i] * switchUpRatioSafetyFactor =\" + (bandwidths[i] * switchUpRatioSafetyFactor) + \" with i=\" + i);\n                            break;\n                        }\n                    }\n\n                    q = i;\n                    p = MediaPlayer.rules.SwitchRequest.prototype.STRONG;\n\n                    this.debug.info(\"[DownloadRatioRule][\" + data.type + \"] SwitchRequest: q=\" + q + \"/\" + (count - 1) + \" (\" + bandwidths[q] + \"), p=\" + p);\n                    return new MediaPlayer.rules.SwitchRequest(q, p);\n                }\n            } else {\n                return new MediaPlayer.rules.SwitchRequest();\n            }\n        }\n    };\n};\n\nMediaPlayer.rules.DownloadRatioRule.prototype = {\n    constructor: MediaPlayer.rules.DownloadRatioRule\n};","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.rules.DroppedFramesRule = function() {\n    \"use strict\";\n\n    var MIN_ELAPSED_TIME = 1,\n        lastPlaybackQuality = null,\n        currentDroppedFrames = -1,\n        currentTotalVideoFrames = -1,\n\n        getDroppedFrames = function(playbackQuality) {\n            var elapsedTime;\n\n            if (lastPlaybackQuality === null) {\n                lastPlaybackQuality = playbackQuality;\n                return;\n            }\n\n            // Check sufficient elapsed media time to determine frame rate\n            elapsedTime = playbackQuality.mt - lastPlaybackQuality.mt;\n            if (elapsedTime < MIN_ELAPSED_TIME) {\n                return;\n            }\n\n            currentDroppedFrames = playbackQuality.droppedFrames - lastPlaybackQuality.droppedFrames;\n            currentTotalVideoFrames = playbackQuality.totalVideoFrames - lastPlaybackQuality.totalVideoFrames;\n\n            lastPlaybackQuality = playbackQuality;\n        };\n\n    return {\n        debug: undefined,\n        metricsExt: undefined,\n        manifestModel: undefined,\n        config: undefined,\n\n        name: \"DroppedFramesRule\",\n\n        checkIndex: function(current, metrics, data, playerState) {\n            var droppedFramesMaxRatio = this.config.getParamFor(data.type, \"ABR.droppedFramesMaxRatio\", \"number\", 0.30),\n                droppedFramesMinRatio = this.config.getParamFor(data.type, \"ABR.droppedFramesMinRatio\", \"number\", 0.10),\n                playbackQuality = this.metricsExt.getCurrentPlaybackQuality(metrics),\n                q = MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE,\n                p = MediaPlayer.rules.SwitchRequest.prototype.DEFAULT,\n                ratio;\n\n            if (data === null) {\n                return new MediaPlayer.rules.SwitchRequest();\n            }\n\n            if (data.type !== \"video\") {\n                return new MediaPlayer.rules.SwitchRequest();\n            }\n\n            if (playbackQuality === null) {\n                // No PlaybackQuality metric => start of a new stream => reset lastPlaybackQuality\n                lastPlaybackQuality = null;\n                currentDroppedFrames = currentTotalVideoFrames = -1;\n                return new MediaPlayer.rules.SwitchRequest();\n            }\n\n            // Check if we start buffering the stream. In this case we ignore the rule and reset lastPlaybackQuality\n            if (playerState === 'buffering') {\n                lastPlaybackQuality = null;\n                currentDroppedFrames = currentTotalVideoFrames = -1;\n                return new MediaPlayer.rules.SwitchRequest();\n            }\n\n            //this.debug.info(\"[DroppedFramesRule][\"+data.type+\"] PlaybackQuality = \" + JSON.stringify(playbackQuality));\n\n            // Determine number of dropped frames and fps\n            getDroppedFrames(playbackQuality);\n\n            if (currentDroppedFrames === -1) {\n                return new MediaPlayer.rules.SwitchRequest();\n            }\n\n            ratio = currentDroppedFrames / currentTotalVideoFrames;\n\n            this.debug.info(\"[DroppedFramesRule][\"+data.type+\"] DroppedFrames:\" + currentDroppedFrames + \", totalVideoFrames:\" + currentTotalVideoFrames + \" => ratio = \" + ratio);\n\n            if (ratio > droppedFramesMaxRatio && current > 0) {\n                // If too much dropped frames, then switch to lower representation\n                q = current - 1;\n                p = MediaPlayer.rules.SwitchRequest.prototype.STRONG;\n            } else if (ratio > droppedFramesMinRatio) {\n                // Still some dropped frames, then stay at current quality\n                q = current;\n                p = MediaPlayer.rules.SwitchRequest.prototype.STRONG;\n            }\n\n            this.debug.info(\"[DroppedFramesRule][\" + data.type + \"] SwitchRequest: q=\" + q + \", p=\" + p);\n\n            return new MediaPlayer.rules.SwitchRequest(q, p);\n        }\n    };\n};\n\nMediaPlayer.rules.DroppedFramesRule.prototype = {\n    constructor: MediaPlayer.rules.DroppedFramesRule\n};","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.rules.InsufficientBufferRule = function() {\n    \"use strict\";\n\n    return {\n        debug: undefined,\n        manifestExt: undefined,\n        metricsExt: undefined,\n        manifestModel: undefined,\n        config: undefined,\n        isStartBuffering: {},\n\n        name: \"InsufficientBufferRule\",\n\n        checkIndex: function(current, metrics, data, playerState) {\n            var bufferLevel = this.metricsExt.getCurrentBufferLevel(metrics),\n                minBufferTime,\n                switchLowerBufferRatio,\n                switchLowerBufferTime,\n                switchDownBufferRatio,\n                switchDownBufferTime,\n                switchUpBufferRatio,\n                switchUpBufferTime,\n                mpd,\n                q = current,\n                p = MediaPlayer.rules.SwitchRequest.prototype.DEFAULT;\n\n\n            if (data === null) {\n                return new MediaPlayer.rules.SwitchRequest();\n            }\n\n            // Check if we start buffering the stream. In this case we ignore the rule\n            if (playerState === 'buffering') {\n                this.isStartBuffering[data.type] = true;\n            }\n\n            if (bufferLevel === null) {\n                return new MediaPlayer.rules.SwitchRequest();\n            }\n\n            this.debug.info(\"[InsufficientBufferRule][\" + data.type + \"] Checking buffer level ... (current = \" + current +\n                \", buffer level = \" + (Math.round(bufferLevel.level * 100) / 100) +\n                \", buffering = \" + this.isStartBuffering[data.type] + \")\");\n\n\n            mpd = this.manifestExt.getMpd(this.manifestModel.getValue());\n            if (mpd) {\n                minBufferTime = this.config.getParamFor(data.type, \"BufferController.minBufferTime\", \"number\", mpd.manifest.minBufferTime);\n                switchLowerBufferRatio = this.config.getParamFor(data.type, \"ABR.switchLowerBufferRatio\", \"number\", 0.25);\n                switchLowerBufferTime = this.config.getParamFor(data.type, \"ABR.switchLowerBufferTime\", \"number\", switchLowerBufferRatio * minBufferTime);\n                switchDownBufferRatio = this.config.getParamFor(data.type, \"ABR.switchDownBufferRatio\", \"number\", 0.5);\n                switchDownBufferTime = this.config.getParamFor(data.type, \"ABR.switchDownBufferTime\", \"number\", switchDownBufferRatio * minBufferTime);\n                switchUpBufferRatio = this.config.getParamFor(data.type, \"ABR.switchUpBufferRatio\", \"number\", 0.75);\n                switchUpBufferTime = this.config.getParamFor(data.type, \"ABR.switchUpBufferTime\", \"number\", switchUpBufferRatio * minBufferTime);\n\n                if ((bufferLevel.level < switchDownBufferTime) && (this.isStartBuffering[data.type])) {\n                    return new MediaPlayer.rules.SwitchRequest();\n                } else {\n                    if (bufferLevel.level >= switchDownBufferTime) {\n                        this.isStartBuffering[data.type] = false;\n                    }\n\n                    var max = this.manifestExt.getRepresentationCount(data);\n\n                    max -= 1; // 0 based\n\n                    if (bufferLevel.level <= switchLowerBufferTime) {\n                        q = 0;\n                        p = MediaPlayer.rules.SwitchRequest.prototype.STRONG;\n                    } else if (bufferLevel.level <= switchDownBufferTime) {\n                        q = (current > 0) ? (current - 1) : 0;\n                        p = MediaPlayer.rules.SwitchRequest.prototype.DEFAULT;\n                    }\n\n                    this.debug.info(\"[InsufficientBufferRule][\" + data.type + \"] SwitchRequest: q=\" + q + \", p=\" + p);\n                    return new MediaPlayer.rules.SwitchRequest(q, p);\n\n                }\n            } else {\n                this.debug.log(\"[InsufficientBufferRule][\" + data.type + \"] Manifest not present yet\");\n                return new MediaPlayer.rules.SwitchRequest();\n            }\n        }\n    };\n};\n\nMediaPlayer.rules.InsufficientBufferRule.prototype = {\n    constructor: MediaPlayer.rules.OInsufficientBufferRule\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.rules.LimitSwitchesRule = function () {\n    \"use strict\";\n\n    /*\n     * This rule is intended to limit the number of switches that can happen.\n     * We might get into a situation where there quality is bouncing around a ton.\n     * This can create an unpleasant experience, so let the stream settle down.\n     */\n\n    var MAX_SWITCHES = 10,\n        VALIDATION_TIME = 20000,\n        WAIT_COUNT = 5,\n        waiting = 0;\n\n    return {\n        debug: undefined,\n\n        name: \"LimitSwitchesRule\",\n\n        checkIndex: function (current, metrics /*, data*/) {\n            if (waiting > 0) {\n                waiting -= 1;\n                return new MediaPlayer.rules.SwitchRequest(current, MediaPlayer.rules.SwitchRequest.prototype.STRONG);\n            }\n\n            var self = this,\n                panic = false,\n                rs,\n                now = new Date().getTime(),\n                delay,\n                i,\n                numSwitches = metrics.RepSwitchList.length;\n\n            //self.debug.log(\"Checking limit switches rule...\");\n\n            for (i = numSwitches - 1; i >= 0; i -= 1) {\n                rs = metrics.RepSwitchList[i];\n                delay = now - rs.t.getTime();\n\n                if (delay >= VALIDATION_TIME) {\n                    self.debug.log(\"Reached time limit, bailing.\");\n                    break;\n                }\n\n                if (i >= MAX_SWITCHES) {\n                    self.debug.log(\"Found too many switches within validation time, force the stream to not change.\");\n                    panic = true;\n                    break;\n                }\n            }\n\n            if (panic) {\n                self.debug.log(\"Wait some time before allowing another switch.\");\n                waiting = WAIT_COUNT;\n                return new MediaPlayer.rules.SwitchRequest(current, MediaPlayer.rules.SwitchRequest.prototype.STRONG);\n            } else {\n                return new MediaPlayer.rules.SwitchRequest(MediaPlayer.rules.SwitchRequest.prototype.NO_CHANGE, MediaPlayer.rules.SwitchRequest.prototype.STRONG);\n            }\n        }\n    };\n};\n\nMediaPlayer.rules.LimitSwitchesRule.prototype = {\n    constructor: MediaPlayer.rules.LimitSwitchesRule\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.rules.SwitchRequest = function (q, p) {\n    \"use strict\";\n    this.quality = q;\n    this.priority = p;\n\n    if (this.quality === undefined) {\n        this.quality = 999;\n    }\n\n    if (this.priority === undefined) {\n        this.priority = 0.5;\n    }\n};\n\nMediaPlayer.rules.SwitchRequest.prototype = {\n    constructor: MediaPlayer.rules.SwitchRequest,\n    NO_CHANGE: 999,\n    DEFAULT: 0.5,\n    STRONG: 1,\n    WEAK: 0\n};","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n\n/**\n * Defines the public interface for all ProtectionModel implementations.\n *\n * ProtectionModel implementations provide access to particular versions\n * of the Encrypted Media Extensions (EME) APIs that have been implemented\n * in a user agent.  Developers wishing to add support for a new EME version\n * found in a target user-agent should add a new instance of this interface\n * to the\n *\n * Applications should not need direct access to this object.  All interactions with\n * the protection system should be performed with\n * {@link MediaPlayer.dependencies.ProtectionController}\n *\n * @interface MediaPlayer.models.ProtectionModel\n */\n\nMediaPlayer.models.ProtectionModel = function() { };\n\n/**\n * Returns an array of all initialization data currently used by\n * active sessions.\n *\n * @function\n * @name MediaPlayer.models.ProtectionModel#getAllInitData\n * @returns {ArrayBuffer[]} an array of initialization data buffers\n */\n\n/**\n * Determine if the user-agent supports one of the given key systems and\n * content type configurations. Sends ENAME_KEY_SYSTEM_ACCESS_COMPLETE event\n * with a KeySystemAccess object as event data\n *\n * @function\n * @name MediaPlayer.models.ProtectionModel#requestKeySystemAccess\n * @param {Object[]} ksConfigurations array of desired key system\n * configurations in priority order (highest priority first)\n * @param {MediaPlayer.dependencies.protection.KeySystem} ksConfigurations.ks\n * the key system\n * @param {MediaPlayer.vo.protection.KeySystemConfiguration[]} ksConfigurations.configs\n * array of acceptable key system configurations\n * for this key system in priority order (highest priority first)\n */\n\n/**\n * Selects the key system to use for all future operations on this\n * ProtectionModel.  Sends ENAME_KEY_SYSTEM_SELECTED with no data\n *\n * @function\n * @name MediaPlayer.models.ProtectionModel#selectKeySystem\n * @param keySystemAccess {MediaPlayer.vo.protection.KeySystemAccess} the key\n * system access token representing a supported key system\n */\n\n/**\n * Associate this protection model with a HTMLMediaElement\n *\n * @function\n * @name MediaPlayer.models.ProtectionModel#setMediaElement\n * @param mediaElement {HTMLMediaElement} the media element to\n * which we should associate this protection model and all current\n * key sessions\n */\n\n/**\n * Creates a new key session using the given initData and type. Sends\n * ENAME_KEY_SESSION_CREATED event with MediaPlayer.vo.protection.SessionToken\n * as data.\n *\n * @function\n * @name MediaPlayer.models.ProtectionModel#createKeySession\n * @param {ArrayBuffer} initData PSSH box for the currently selected\n * key system.\n * @param {string} sessionType the desired session type.  One of \"temporary\",\n * \"persistent-license\", \"persistent-release-message\".  CDM implementations\n * are not required to support anything except \"temporary\"\n */\n\n/**\n * Update the given key session with a key (or any other message\n * intended for the CDM)\n *\n * @function\n * @name MediaPlayer.models.ProtectionModel#updateKeySession\n * @param {MediaPlayer.vo.protection.SessionToken} sessionToken the session\n * token\n * @param {ArrayBuffer} message the message that should be delivered to the CDM\n * for this session\n */\n\n/**\n * Loads the persisted key session data associated with the given sessionID\n * into a new session.  Sends ENAME_KEY_SESSION_CREATED event with\n * {@MediaPlayer.vo.protection.SessionToken} as data.\n *\n * @function\n * @name MediaPlayer.models.ProtectionModel#loadKeySession\n * @param {string} sessionID the session ID corresponding to the persisted\n * session data to be loaded\n */\n\n/**\n * Removes any persisted key session data associated with the given session.\n * Also closes the session.  Sends ENAME_KEY_SESSION_REMOVED and\n * ENAME_KEY_SESSION_CLOSED with sessionID as data\n *\n * @function\n * @name MediaPlayer.models.ProtectionModel#removeKeySession\n * @param {MediaPlayer.vo.protection.SessionToken} sessionToken the session\n * token\n */\n\n/**\n * Close the given session and release all associated keys.  Following\n * this call, the sessionToken becomes invalid.  Sends ENAME_KEY_SESSION_CLOSED\n * with sessionID as data\n *\n * @function\n * @name MediaPlayer.models.ProtectionModel#closeKeySession\n * @param sessionToken the session token\n */\n\n/**\n * Sets the certificate to be used by the CDM for encrypting messages\n *\n * @function\n * @name MediaPlayer.models.ProtectionModel#setServerCertificate\n * @param {ArrayBuffer} serverCertificate\n */\n\n/**\n * Currently selected key system.  Will be null or undefined if no key\n * system has yet been selected\n *\n * @instance\n * @name keySystem\n * @memberof MediaPlayer.models.ProtectionModel\n * @readonly\n * @type MediaPlayer.dependencies.protection.KeySystem\n */\n\n\n/**\n * Event IDs for events sent by ProtectionModel implementations. Use these\n * event names when subscribing or unsubscribing from ProtectionModel events.\n *\n * @enum {String}\n */\nMediaPlayer.models.ProtectionModel.eventList = {\n    /**\n     * Event ID for needkey/encrypted events\n     *\n     * @constant\n     */\n    ENAME_NEED_KEY: \"needkey\",\n    /**\n     * Event ID for events delivered when a key system access procedure\n     * has completed\n     *\n     * @constant\n     */\n    ENAME_KEY_SYSTEM_ACCESS_COMPLETE: \"keySystemAccessComplete\",\n    /**\n     * Event ID for events delivered when a key system selection procedure\n     * completes\n     *\n     * @constant\n     */\n    ENAME_KEY_SYSTEM_SELECTED: \"keySystemSelected\",\n    /**\n     * Event ID for events delivered when a HTMLMediaElement has been\n     * associated with the protection set\n     *\n     * @constant\n     */\n    ENAME_VIDEO_ELEMENT_SELECTED: \"videoElementSelected\",\n    /**\n     * Event ID for events delivered when a new server certificate has\n     * been delivered to the CDM\n     *\n     * @constant\n     */\n    ENAME_SERVER_CERTIFICATE_UPDATED: \"serverCertificateUpdated\",\n    /**\n     * Event ID for events delivered when the protection set receives\n     * a key message from the CDM\n     *\n     * @constant\n     */\n    ENAME_KEY_MESSAGE: \"keyMessage\",\n    /**\n     * Event ID for events delivered when a new key has been added\n     *\n     * @constant\n     * @deprecated The latest versions of the EME specification no longer\n     * use this event.  {@MediaPlayer.models.protectionModel.eventList.ENAME_KEY_STATUSES_CHANGED}\n     * is preferred.\n     */\n    ENAME_KEY_ADDED: \"keyAdded\",\n    /**\n     * Event ID for events delivered when an error is encountered by the CDM\n     * while processing a license server response message\n     *\n     * @constant\n     */\n    ENAME_KEY_ERROR: \"keyError\",\n    /**\n     * Event ID for events delivered when a new key sessions creation\n     * process has completed\n     *\n     * @constant\n     */\n    ENAME_KEY_SESSION_CREATED: \"keySessionCreated\",\n    /**\n     * Event ID for events delivered when a key session removal\n     * process has completed\n     *\n     * @constant\n     */\n    ENAME_KEY_SESSION_REMOVED: \"keySessionRemoved\",\n    /**\n     * Event ID for events delivered when a key session close\n     * process has completed\n     *\n     * @constant\n     */\n    ENAME_KEY_SESSION_CLOSED: \"keySessionClosed\",\n    /**\n     * Event ID for events delivered when the status of one or more\n     * decryption keys has changed\n     *\n     * @constant\n     */\n    ENAME_KEY_STATUSES_CHANGED: \"keyStatusesChanged\",\n    /**\n     * Event ID for events delivered when the process of shutting down\n     * a protection set has completed\n     *\n     * @constant\n     */\n    ENAME_TEARDOWN_COMPLETE: \"protectionTeardownComplete\",\n};\n\n/**\n * needkey/encrypted event\n */\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.vo.Error = function (code, message, data) {\n    \"use strict\";\n    this.code = code || null;\n    this.message = message || null;\n    this.data = data || null;\n};\n\nMediaPlayer.vo.Error.prototype = {\n    constructor: MediaPlayer.vo.Error\n};","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.vo.Event = function () {\n    \"use strict\";\n    this.type = null; // event type/name. mandatory\n    this.sender = null; // object that fires an event. mandatory\n    this.data = null; // object that contains additional information about the event. optional\n    this.error = null; // error object. optional\n    this.timestamp = NaN; // timestamp. mandatory\n};\n\nMediaPlayer.vo.Event.prototype = {\n    constructor: MediaPlayer.vo.Event\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.models.MetricsList = function () {\n    \"use strict\";\n\n    return {\n        TcpList: [],\n        HttpList: [],\n        RepSwitchList: [],\n        BufferedSwitchList:[],\n        BufferLevel: [],\n        PlayList: [],\n        State: [],\n        DroppedFrames: [],\n        PlaybackQuality: [],\n        VideoResolution: [],\n        DVRInfo: [],\n        ManifestUpdate: []\n    };\n};\n\nMediaPlayer.models.MetricsList.prototype = {\n    constructor: MediaPlayer.models.MetricsList\n};\n","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2014, Orange\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.vo.Mp4Track = function () {\n    \"use strict\";\n\n    this.type = 'und';\n    this.trackId = 0;\n    this.timescale = 0;\n    this.duration = 0;\n    this.codecs = \"\";\n    this.codecPrivateData = \"\";\n    this.bandwidth = \"\";\n\n    // Video related fields\n    this.width = 0;\n    this.height = 0;\n\n    // Audio related fields\n    this.language = 'und';\n    this.channels = 0;\n    this.samplingRate = 0;\n\n    // Content protection\n    this.contentProtection = undefined;\n\n    // Samples description and data\n    this.samples = [];\n    this.data = null;\n};\n\nMediaPlayer.vo.Mp4Track.prototype = {\n    constructor: MediaPlayer.vo.Mp4Track\n};\n\n\nMediaPlayer.vo.Mp4Track.Sample = function () {\n    \"use strict\";\n\n    this.dts = 0;\n    this.cts = 0;\n    this.duration = 0;\n    this.flags = 0;\n    this.data = null;\n    this.size = 0;\n};\n\nMediaPlayer.vo.Mp4Track.Sample.prototype = {\n    constructor: MediaPlayer.vo.Mp4Track.Sample\n};\n\n","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.vo.SegmentRequest = function () {\n    \"use strict\";\n    this.action = \"download\";\n    this.startTime = NaN;\n    this.streamType = null;\n    this.type = null;\n    this.duration = NaN;\n    this.timescale = NaN;\n    this.range = null;\n    this.url = null;\n    this.requestStartDate = null;\n    this.firstByteDate = null;\n    this.requestEndDate = null;\n    this.deferred = null;\n    this.quality = NaN;\n    this.index = NaN;\n    this.availabilityStartTime = null;\n    this.availabilityEndTime = null;\n    this.wallStartTime = null;\n};\n\nMediaPlayer.vo.SegmentRequest.prototype = {\n    constructor: MediaPlayer.vo.SegmentRequest,\n    ACTION_DOWNLOAD: \"download\",\n    ACTION_COMPLETE: \"complete\"\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Akamai Technologies\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.vo.URIFragmentData = function () {\n    \"use strict\";\n    this.t = null;\n    this.xywh = null;\n    this.track = null;\n    this.id = null;\n    this.s = null;\n};\n\nMediaPlayer.vo.URIFragmentData.prototype = {\n    constructor: MediaPlayer.vo.URIFragmentData\n};\n\n\n/*\n    From Spec http://www.w3.org/TR/media-frags/\n\n    temporal (t)     - This dimension denotes a specific time range in the original media, such as \"starting at second 10, continuing until second 20\";\n    spatial  (xywh)  - this dimension denotes a specific range of pixels in the original media, such as \"a rectangle with size (100,100) with its top-left at coordinate (10,10)\";\n                       Media fragments support also addressing the media along two additional dimensions (in the advanced version defined in Media Fragments 1.0 URI (advanced)):\n    track    (track) - this dimension denotes one or more tracks in the original media, such as \"the english audio and the video track\";\n    id       (id)    - this dimension denotes a named temporal fragment within the original media, such as \"chapter 2\", and can be seen as a convenient way of specifying a temporal fragment.\n\n\n    ## Note\n    Akamai is purposing to add #s=X to the ISO standard.\n        - (X) Value would be a start time to seek to at startup instead of starting at 0 or live edge\n        - Allows for seeking back before the start time unlike a temporal clipping.\n*/","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.vo.metrics.BufferLevel = function () {\n    \"use strict\";\n\n    this.t = null;      // Real-Time | Time of the measurement of the buffer level.\n    this.level = null;  // Level of the buffer in milliseconds. Indicates the playout duration for which media data of all active media components is available starting from the current playout time.\n};\n\nMediaPlayer.vo.metrics.BufferLevel.prototype = {\n    constructor: MediaPlayer.vo.metrics.BufferLevel\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.vo.metrics.BufferedSwitch = function () {\n    \"use strict\";\n\n    this.mt = null;     // Media-Time | The media presentation time of the earliest access unit (out of all media content components) played out from the Representation.\n    this.to = null;     // value of Representation@id identifying the switch-to Representation.\n    this.lto = null;    // If not present, this metrics concerns the Representation as a whole. If present, lto indicates the value of SubRepresentation@level within Representation identifying the switch-to level of the Representation.\n};\n\nMediaPlayer.vo.metrics.BufferedSwitch.prototype = {\n    constructor: MediaPlayer.vo.metrics.BufferedSwitch\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.vo.metrics.Condition = function () {\n    \"use strict\";\n\n    this.isFullScreen = null;\n    this.windowSize = null;\n    this.droppedFrames = null;\n    this.fps = null;\n    this.bandwidth = null;\n};\n\nMediaPlayer.vo.metrics.Condition.prototype = {\n    constructor: MediaPlayer.vo.metrics.Condition\n};\n","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Akamai Technologies\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.vo.metrics.DVRInfo = function () {\n    \"use strict\";\n\n    this.time = null;   // Time of the measurement of the DVR info\n    this.range = null;  // DVR range\n};\n\nMediaPlayer.vo.metrics.DVRInfo.prototype = {\n    constructor: MediaPlayer.vo.metrics.DVRInfo\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.vo.metrics.DroppedFrames = function () {\n    \"use strict\";\n\n    this.time = null;      // Real-Time | Time of the measurement of the dropped frames.\n    this.droppedFrames = null;  // Number of dropped frames.\n};\n\nMediaPlayer.vo.metrics.DroppedFrames.prototype = {\n    constructor: MediaPlayer.vo.metrics.DroppedFrames\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.vo.metrics.HTTPRequest = function () {\n    \"use strict\";\n\n    this.stream = null;         // type of stream (\"audio\" | \"video\" etc..)\n    this.tcpid = null;          // Identifier of the TCP connection on which the HTTP request was sent.\n    this.type = null;           // This is an optional parameter and should not be included in HTTP request/response transactions for progressive download.\n                                    // The type of the request:\n                                    // - MPD\n                                    // - XLink expansion\n                                    // - Initialization Segment\n                                    // - Index Segment\n                                    // - Media Segment\n                                    // - Bitstream Switching Segment\n                                    // - other\n    this.url = null;            // The original URL (before any redirects or failures)\n    this.actualurl = null;      // The actual URL requested, if different from above\n    this.range = null;          // The contents of the byte-range-spec part of the HTTP Range header.\n    this.trequest = null;       // Real-Time | The real time at which the request was sent.\n    this.tresponse = null;      // Real-Time | The real time at which the first byte of the response was received.\n    this.tfinish = null;        // Real-Time | The real time at which the request finshed.\n    this.responsecode = null;   // The HTTP response code.\n    this.interval = null;       // The duration of the throughput trace intervals (ms), for successful requests only.\n    this.mediaduration = null;  // The duration of the media requests, if available, in milliseconds.\n    this.trace = [];            // Throughput traces, for successful requests only.\n    this.startTime = null;      // the media start time of the segment\n    this.quality = null;        // the quality index of the segment\n    this.bytesLength = null;    // the segment bytes length\n};\n\nMediaPlayer.vo.metrics.HTTPRequest.prototype = {\n    constructor: MediaPlayer.vo.metrics.HTTPRequest\n};\n\nMediaPlayer.vo.metrics.HTTPRequest.Trace = function () {\n    \"use strict\";\n\n    /*\n     * s - Real-Time | Measurement period start.\n     * d - Measurement period duration (ms).\n     * b - List of integers counting the bytes received in each trace interval within the measurement period.\n     */\n    this.s = null;\n    this.d = null;\n    this.b = [];\n};\n\nMediaPlayer.vo.metrics.HTTPRequest.Trace.prototype = {\n    constructor : MediaPlayer.vo.metrics.HTTPRequest.Trace\n};\n","MediaPlayer.vo.metrics.ManifestUpdate = function () {\n    \"use strict\";\n\n    this.streamType = null;\n    this.type = null;                       // static|dynamic\n    this.requestTime = null;                // when this manifest update was requested\n    this.fetchTime = null;                  // when this manifest update was received\n    this.availabilityStartTime = null;\n    this.presentationStartTime = 0;      // the seek point (liveEdge for dynamic, Period[0].startTime for static)\n    this.clientTimeOffset = 0;           // the calculated difference between the server and client wall clock time\n    this.currentTime = null;                // actual element.currentTime\n    this.buffered = null;                   // actual element.ranges\n    this.latency = 0;                       // (static is fixed value of zero. dynamic should be ((Now-@availabilityStartTime) - elementCurrentTime)\n    this.periodInfo = [];\n    this.representationInfo = [];\n};\n\nMediaPlayer.vo.metrics.ManifestUpdate.PeriodInfo = function () {\n    \"use strict\";\n\n    this.id = null;         // Period@id\n    this.index = null;\n    this.start = null;      // Period@start\n    this.duration = null;   // Period@duration\n};\n\nMediaPlayer.vo.metrics.ManifestUpdate.RepresentationInfo = function () {\n    \"use strict\";\n\n    this.id = null;                         // Representation@id\n    this.index = null;\n    this.streamType = null;\n    this.periodIndex = null;\n    this.presentationTimeOffset = null;     // @presentationTimeOffset\n    this.startNumber = null;                // @startNumber\n    this.segmentInfoType = null;            // list|template|timeline\n};\n\nMediaPlayer.vo.metrics.ManifestUpdate.prototype = {\n    constructor: MediaPlayer.vo.metrics.ManifestUpdate\n};\n\nMediaPlayer.vo.metrics.ManifestUpdate.PeriodInfo.prototype = {\n    constructor: MediaPlayer.vo.metrics.ManifestUpdate.PeriodInfo\n};\n\nMediaPlayer.vo.metrics.ManifestUpdate.RepresentationInfo.prototype = {\n    constructor: MediaPlayer.vo.metrics.ManifestUpdate.RepresentationInfo\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.vo.metrics.PlayList = function () {\n    \"use strict\";\n\n    this.stream = null;     // type of stream (\"audio\" | \"video\" etc..)\n    this.start = null;      // Real-Time | Timestamp of the user action that starts the playback period...\n    this.mstart = null;     // Media-Time | Presentation time at which playout was requested by the user...\n    this.starttype = null;  // Type of user action which triggered playout\n                            //      - New playout request (e.g. initial playout or seeking)\n                            //      - Resume from pause\n                            //        - Other user request (e.g. user-requested quality change)\n                            //        - Start of a metrics collection period (hence earlier entries in the play list not collected)\n    this.trace = [];        // List of periods of continuous rendering of decoded samples.\n};\n\nMediaPlayer.vo.metrics.PlayList.Trace = function () {\n    \"use strict\";\n\n    /*\n     * representationid - The value of the Representation@id of the Representation from which the samples were taken.\n     * subreplevel      - If not present, this metrics concerns the Representation as a whole. If present, subreplevel indicates the greatest value of any Subrepresentation@level being rendered.\n     * start            - Real-Time | The time at which the first sample was rendered.\n     * mstart           - Media-Time | The presentation time of the first sample rendered.\n     * duration         - The duration of the continuously presented samples (which is the same in real time and media time). Continuously presented means that the media clock continued to advance at the playout speed throughout the interval.\n     * playbackspeed    - The playback speed relative to normal playback speed (i.e.normal forward playback speed is 1.0).\n     * stopreason       - The reason why continuous presentation of this Representation was stopped.\n     *                    Either:\n     *                    representation switch\n     *                    rebuffering\n     *                    user request\n     *                    end of Period\n     *                    end of content\n     *                    end of a metrics collection period\n     */\n    this.representationid = null;\n    this.subreplevel = null;\n    this.start = null;\n    this.mstart = null;\n    this.duration = null;\n    this.playbackspeed = null;\n    this.stopreason = null;\n};\n\nMediaPlayer.vo.metrics.PlayList.prototype = {\n    constructor: MediaPlayer.vo.metrics.PlayList\n};\n\n/* Public Static Constants */\nMediaPlayer.vo.metrics.PlayList.INITIAL_PLAY_START_REASON = \"initial_start\";\nMediaPlayer.vo.metrics.PlayList.SEEK_START_REASON = \"seek\";\n\nMediaPlayer.vo.metrics.PlayList.Trace.prototype = {\n    constructor: MediaPlayer.vo.metrics.PlayList.Trace()\n};\n\n/* Public Static Constants */\nMediaPlayer.vo.metrics.PlayList.Trace.USER_REQUEST_STOP_REASON = \"user_request\";\nMediaPlayer.vo.metrics.PlayList.Trace.REPRESENTATION_SWITCH_STOP_REASON = \"representation_switch\";\nMediaPlayer.vo.metrics.PlayList.Trace.END_OF_CONTENT_STOP_REASON = \"end_of_content\";\nMediaPlayer.vo.metrics.PlayList.Trace.REBUFFERING_REASON = \"rebuffering\";","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.vo.metrics.PlaybackQuality = function () {\n    \"use strict\";\n\n    this.t = null;                  // Real-Time | Time of the measurement of the playback quality\n    this.mt = null;                 // Media-Time | Media presentation time of the measurement of the playback quality\n    this.droppedFrames = null;      // Number of dropped frames\n    this.totalVideoFrames = null;   // Number of decoded video frames\n};\n\nMediaPlayer.vo.metrics.PlaybackQuality.prototype = {\n    constructor: MediaPlayer.vo.metrics.PlaybackQuality\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.vo.metrics.RepresentationSwitch = function () {\n    \"use strict\";\n\n    this.t = null;      // Real-Time | Time of the switch event.\n    this.mt = null;     // Media-Time | The media presentation time of the earliest access unit (out of all media content components) played out from the Representation.\n    this.to = null;     // value of Representation@id identifying the switch-to Representation.\n    this.lto = null;    // If not present, this metrics concerns the Representation as a whole. If present, lto indicates the value of SubRepresentation@level within Representation identifying the switch-to level of the Representation.\n};\n\nMediaPlayer.vo.metrics.RepresentationSwitch.prototype = {\n    constructor: MediaPlayer.vo.metrics.RepresentationSwitch\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.vo.metrics.Session = function () {\n    \"use strict\";\n\n    this.uri = null;\n    this.loopMode = null;\n    this.endTime = null;\n    this.playerType = null;\n};\n\nMediaPlayer.vo.metrics.Session.prototype = {\n    constructor: MediaPlayer.vo.metrics.Session\n};\n","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.vo.metrics.State = function () {\n    \"use strict\";\n\n    this.t = null;      // Real-Time | Time of the event.\n    this.current = null;    // current state\n    this.position = null;    // position in the stream\n    this.reason = null;\n};\n\nMediaPlayer.vo.metrics.State.prototype = {\n    constructor: MediaPlayer.vo.metrics.State\n};\n","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.vo.metrics.TCPConnection = function () {\n    \"use strict\";\n\n    this.tcpid = null;      // Identifier of the TCP connection on which the HTTP request was sent.\n    this.dest = null;       // IP Address of the interface over which the client is receiving the TCP data.\n    this.topen = null;      // Real-Time | The time at which the connection was opened (sending time of the initial SYN or connect socket operation).\n    this.tclose = null;     // Real-Time | The time at which the connection was closed (sending or reception time of FIN or RST or close socket operation).\n    this.tconnect = null;   // Connect time in ms (time from sending the initial SYN to receiving the ACK or completion of the connect socket operation).\n};\n\nMediaPlayer.vo.metrics.TCPConnection.prototype = {\n    constructor: MediaPlayer.vo.metrics.TCPConnection\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.vo.metrics.VideoResolution = function () {\n    \"use strict\";\n\n    this.t = null;      // Real-Time | Time of the event.\n    this.mt = null;     // Media-Time | Media presentation time of the measurement of the video resolution\n    this.width = null;  // video width\n    this.height = null; // video height\n};\n\nMediaPlayer.vo.metrics.VideoResolution.prototype = {\n    constructor: MediaPlayer.vo.metrics.VideoResolution\n};\n","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*jshint -W020 */\nDash = (function () {\n    \"use strict\";\n\n    return {\n        modules: {},\n        dependencies: {},\n        vo: {},\n        di: {}\n    };\n}());","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nDash.dependencies.BaseURLExtensions = function () {\n    \"use strict\";\n\n        // From YouTube player.  Reformatted for JSLint.\n    var parseSIDX = function (ab, ab_first_byte_offset) {\n            var d = new DataView(ab),\n                sidx = {},\n                pos = 0,\n                offset,\n                time,\n                sidxEnd,\n                i,\n                ref_type,\n                ref_size,\n                ref_dur,\n                type,\n                size,\n                charCode;\n\n            while (type !== \"sidx\" && pos < d.byteLength) {\n                size = d.getUint32(pos); // subtract 8 for including the size and type\n                pos += 4;\n\n                type = \"\";\n                for (i = 0; i < 4; i += 1) {\n                    charCode = d.getInt8(pos);\n                    type += String.fromCharCode(charCode);\n                    pos += 1;\n                }\n\n                if (type !== \"moof\" && type !== \"traf\" && type !== \"sidx\") {\n                    pos += size - 8;\n                } else if (type === \"sidx\") {\n                    // reset the position to the beginning of the box...\n                    // if we do not reset the position, the evaluation\n                    // of sidxEnd to ab.byteLength will fail.\n                    pos -= 8;\n                }\n            }\n\n            sidxEnd = d.getUint32(pos, false) + pos;\n            if (sidxEnd > ab.byteLength) {\n                throw \"sidx terminates after array buffer\";\n            }\n\n            sidx.version = d.getUint8(pos + 8);\n            pos += 12;\n\n            // skipped reference_ID(32)\n            sidx.timescale = d.getUint32(pos + 4, false);\n            pos += 8;\n\n            if (sidx.version === 0) {\n                sidx.earliest_presentation_time = d.getUint32(pos, false);\n                sidx.first_offset = d.getUint32(pos + 4, false);\n                pos += 8;\n            } else {\n                // TODO(strobe): Overflow checks\n                sidx.earliest_presentation_time = utils.Math.to64BitNumber(d.getUint32(pos + 4, false), d.getUint32(pos, false));\n                //first_offset = utils.Math.to64BitNumber(d.getUint32(pos + 8, false), d.getUint32(pos + 12, false));\n                sidx.first_offset = (d.getUint32(pos + 8, false) << 32) + d.getUint32(pos + 12, false);\n                pos += 16;\n            }\n\n            sidx.first_offset += sidxEnd + (ab_first_byte_offset || 0);\n\n            // skipped reserved(16)\n            sidx.reference_count = d.getUint16(pos + 2, false);\n            pos += 4;\n\n            sidx.references = [];\n            offset = sidx.first_offset;\n            time = sidx.earliest_presentation_time;\n\n            for (i = 0; i < sidx.reference_count; i += 1) {\n                ref_size = d.getUint32(pos, false);\n                ref_type = (ref_size >>> 31);\n                ref_size = ref_size & 0x7fffffff;\n                ref_dur = d.getUint32(pos + 4, false);\n                pos += 12;\n                if (ref_size > 0) {\n                    sidx.references.push({\n                        'size': ref_size,\n                        'type': ref_type,\n                        'offset': offset,\n                        'duration': ref_dur,\n                        'time': time,\n                        'timescale': sidx.timescale\n                    });\n                }\n                offset += ref_size;\n                time += ref_dur;\n            }\n\n            if (pos !== sidxEnd) {\n                throw \"Error: final pos \" + pos + \" differs from SIDX end \" + sidxEnd;\n            }\n\n            return sidx;\n        },\n\n        parseSegments = function (data, media, offset) {\n            var parsed,\n                ref,\n                segments,\n                segment,\n                i,\n                len,\n                start,\n                end;\n\n            parsed = parseSIDX.call(this, data, offset);\n            ref = parsed.references;\n            segments = [];\n\n            for (i = 0, len = ref.length; i < len; i += 1) {\n                segment = new Dash.vo.Segment();\n                segment.duration = ref[i].duration;\n                segment.media = media;\n                segment.startTime = ref[i].time;\n                segment.timescale = ref[i].timescale;\n\n                start = ref[i].offset;\n                end = ref[i].offset + ref[i].size - 1;\n                segment.mediaRange = start + \"-\" + end;\n\n                segments.push(segment);\n            }\n\n            this.debug.log(\"Parsed SIDX box: \" + segments.length + \" segments.\");\n            return segments;\n        },\n\n        findInit = function (data, info) {\n            var deferred = Q.defer(),\n                ftyp,\n                moov,\n                start,\n                end,\n                d = new DataView(data),\n                pos = 0,\n                type = \"\",\n                size = 0,\n                bytesAvailable,\n                i,\n                c,\n                request,\n                loaded = false,\n                irange,\n                self = this;\n\n            self.debug.log(\"Searching for initialization.\");\n\n            while (type !== \"moov\" && pos < d.byteLength) {\n                size = d.getUint32(pos); // subtract 8 for including the size and type\n                pos += 4;\n\n                type = \"\";\n                for (i = 0; i < 4; i += 1) {\n                    c = d.getInt8(pos);\n                    type += String.fromCharCode(c);\n                    pos += 1;\n                }\n\n                if (type === \"ftyp\") {\n                    ftyp = pos - 8;\n                }\n                if (type === \"moov\") {\n                    moov = pos - 8;\n                }\n                if (type !== \"moov\") {\n                    pos += size - 8;\n                }\n            }\n\n            bytesAvailable = d.byteLength - pos;\n\n            if (type !== \"moov\") {\n                // Case 1\n                // We didn't download enough bytes to find the moov.\n                // TODO : Load more bytes.\n                //        Be sure to detect EOF.\n                //        Throw error is no moov is found in the entire file.\n                //        Protection from loading the entire file?\n                self.debug.log(\"Loading more bytes to find initialization.\");\n                info.range.start = 0;\n                info.range.end = info.bytesLoaded + info.bytesToLoad;\n\n                request = new XMLHttpRequest();\n\n                request.onloadend = function () {\n                    if (!loaded) {\n                        deferred.reject(\"Error loading initialization.\");\n                    }\n                };\n\n                request.onload = function () {\n                    loaded = true;\n                    info.bytesLoaded = info.range.end;\n                    findInit.call(self, request.response).then(\n                        function (segments) {\n                            deferred.resolve(segments);\n                        }\n                    );\n                };\n\n                request.onerror = function () {\n                    deferred.reject(\"Error loading initialization.\");\n                };\n\n                request.open(\"GET\", self.tokenAuthentication.addTokenAsQueryArg(info.url));\n                request.responseType = \"arraybuffer\";\n                request.setRequestHeader(\"Range\", \"bytes=\" + info.range.start + \"-\" + info.range.end);\n                request = self.tokenAuthentication.setTokenInRequestHeader(request);\n                request.send(null);\n            } else {\n                // Case 2\n                // We have the entire range, so continue.\n                start = ftyp === undefined ? moov : ftyp;\n                end = moov + size - 1;\n                irange = start + \"-\" + end;\n\n                self.debug.log(\"Found the initialization.  Range: \" + irange);\n                deferred.resolve(irange);\n            }\n\n            return deferred.promise;\n        },\n\n        loadInit = function (media) {\n            var deferred = Q.defer(),\n                request = new XMLHttpRequest(),\n                needFailureReport = true,\n                self = this,\n                info = {\n                    url: media,\n                    range: {},\n                    searching: false,\n                    bytesLoaded: 0,\n                    bytesToLoad: 1500,\n                    request: request\n                };\n\n            self.debug.log(\"Start searching for initialization.\");\n            info.range.start = 0;\n            info.range.end = info.bytesToLoad;\n\n            request.onload = function () {\n                if (request.status < 200 || request.status > 299)\n                {\n                  return;\n                }\n                needFailureReport = false;\n\n                info.bytesLoaded = info.range.end;\n                findInit.call(self, request.response, info).then(\n                    function (range) {\n                        deferred.resolve(range);\n                    },function(){\n                        deferred.reject();\n                    }\n                );\n            };\n\n            request.onloadend = request.onerror = function () {\n                if (!needFailureReport)\n                {\n                  return;\n                }\n                needFailureReport = false;\n\n                var data = {};\n                data.url = info.url;\n                data.request = request;\n\n                self.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_INIT, null, data);\n                deferred.reject(request);\n            };\n\n            request.open(\"GET\", self.tokenAuthentication.addTokenAsQueryArg(info.url));\n            request.responseType = \"arraybuffer\";\n            request.setRequestHeader(\"Range\", \"bytes=\" + info.range.start + \"-\" + info.range.end);\n            request = self.tokenAuthentication.setTokenInRequestHeader(request);\n            request.send(null);\n            self.debug.log(\"Perform init search: \" + info.url);\n\n            return deferred.promise;\n        },\n\n        findSIDX = function (data, info) {\n            var deferred = Q.defer(),\n                d = new DataView(data),\n                request = new XMLHttpRequest(),\n                pos = 0,\n                type = \"\",\n                size = 0,\n                bytesAvailable,\n                sidxBytes,\n                sidxSlice,\n                sidxOut,\n                i,\n                c,\n                needFailureReport = true,\n                parsed,\n                ref,\n                loadMultiSidx = false,\n                self = this;\n\n            self.debug.log(\"Searching for SIDX box.\");\n            self.debug.log(info.bytesLoaded + \" bytes loaded.\");\n\n            while (type !== \"sidx\" && pos < d.byteLength) {\n                size = d.getUint32(pos); // subtract 8 for including the size and type\n                pos += 4;\n\n                type = \"\";\n                for (i = 0; i < 4; i += 1) {\n                    c = d.getInt8(pos);\n                    type += String.fromCharCode(c);\n                    pos += 1;\n                }\n\n                if (type !== \"sidx\") {\n                    pos += size - 8;\n                }\n            }\n\n            bytesAvailable = d.byteLength - pos;\n\n            if (type !== \"sidx\") {\n                // Case 1\n                // We didn't download enough bytes to find the sidx.\n                // TODO : Load more bytes.\n                //        Be sure to detect EOF.\n                //        Throw error is no sidx is found in the entire file.\n                //        Protection from loading the entire file?\n                deferred.reject();\n            } else if (bytesAvailable < (size - 8)) {\n                // Case 2\n                // We don't have the entire box.\n                // Increase the number of bytes to read and load again.\n                self.debug.log(\"Found SIDX but we don't have all of it.\");\n\n                info.range.start = 0;\n                info.range.end = info.bytesLoaded + (size - bytesAvailable);\n\n                request.onload = function () {\n                    if (request.status < 200 || request.status > 299)\n                    {\n                      return;\n                    }\n                    needFailureReport = false;\n\n                    info.bytesLoaded = info.range.end;\n                    findSIDX.call(self, request.response, info).then(\n                        function (segments) {\n                            deferred.resolve(segments);\n                        }\n                    );\n                };\n\n                request.onloadend = request.onerror = function () {\n                    if (!needFailureReport)\n                    {\n                      return;\n                    }\n                    needFailureReport = false;\n                    \n                    var data = {};\n                    data.url = info.url;\n                    data.request = request;\n\n                    self.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_SIDX, null, data);\n                    deferred.reject(request);\n                };\n\n                request.open(\"GET\", self.tokenAuthentication.addTokenAsQueryArg(info.url));\n                request.responseType = \"arraybuffer\";\n                request.setRequestHeader(\"Range\", \"bytes=\" + info.range.start + \"-\" + info.range.end);\n                request = self.tokenAuthentication.setTokenInRequestHeader(request);\n                request.send(null);\n            } else {\n                // Case 3\n                // We have the entire box, so parse it and continue.\n                info.range.start = pos - 8;\n                info.range.end = info.range.start + size;\n\n                self.debug.log(\"Found the SIDX box.  Start: \" + info.range.start + \" | End: \" + info.range.end);\n//                sidxBytes = data.slice(info.range.start, info.range.end);\n                sidxBytes = new ArrayBuffer(info.range.end - info.range.start);\n                sidxOut = new Uint8Array(sidxBytes);\n                sidxSlice = new Uint8Array(data, info.range.start, info.range.end - info.range.start);\n                sidxOut.set(sidxSlice);\n\n                parsed = this.parseSIDX.call(this, sidxBytes, info.range.start);\n\n                // We need to check to see if we are loading multiple sidx.\n                // For now just check the first reference and assume they are all the same.\n                // TODO : Can the referenceTypes be mixed?\n                // TODO : Load them all now, or do it as needed?\n\n                ref = parsed.references;\n                if (ref !== null && ref !== undefined && ref.length > 0) {\n                    loadMultiSidx = (ref[0].type === 1);\n                }\n\n                if (loadMultiSidx) {\n                    self.debug.log(\"Initiate multiple SIDX load.\");\n\n                    var j, len, ss, se, r, funcs = [], segs;\n\n                    for (j = 0, len = ref.length; j < len; j += 1) {\n                        ss = ref[j].offset;\n                        se = ref[j].offset + ref[j].size - 1;\n                        r = ss + \"-\" + se;\n\n                        funcs.push(this.loadSegments.call(self, info.url, r));\n                    }\n\n                    Q.all(funcs).then(\n                        function (results) {\n                            segs = [];\n                            for (j = 0, len = results.length; j < len; j += 1) {\n                                segs = segs.concat(results[j]);\n                            }\n                            deferred.resolve(segs);\n                        },\n                        function (httprequest) {\n                            deferred.reject(httprequest);\n                        }\n                    );\n\n                } else {\n                    self.debug.log(\"Parsing segments from SIDX.\");\n                    deferred.resolve(parseSegments.call(self, sidxBytes, info.url, info.range.start));\n                }\n            }\n\n            return deferred.promise;\n        },\n\n        loadSegments = function (media, theRange) {\n            var deferred = Q.defer(),\n                request = new XMLHttpRequest(),\n                parts,\n                needFailureReport = true,\n                self = this,\n                info = {\n                    url: media,\n                    range: {},\n                    searching: false,\n                    bytesLoaded: 0,\n                    bytesToLoad: 1500,\n                    request: request\n                };\n\n            // We might not know exactly where the sidx box is.\n            // Load the first n bytes (say 1500) and look for it.\n            if (theRange === null) {\n                self.debug.log(\"No known range for SIDX request.\");\n                info.searching = true;\n                info.range.start = 0;\n                info.range.end = info.bytesToLoad;\n            } else {\n                parts = theRange.split(\"-\");\n                info.range.start = parseFloat(parts[0]);\n                info.range.end = parseFloat(parts[1]);\n            }\n\n            request.onload = function () {\n                if (request.status < 200 || request.status > 299)\n                {\n                  return;\n                }\n                needFailureReport = false;\n\n\n                // If we didn't know where the SIDX box was, we have to look for it.\n                // Iterate over the data checking out the boxes to find it.\n                if (info.searching) {\n                    info.bytesLoaded = info.range.end;\n                    findSIDX.call(self, request.response, info).then(\n                        function (segments) {\n                            deferred.resolve(segments);\n                        }, function(){\n                            deferred.reject();\n                        }\n                    );\n                } else {\n                    deferred.resolve(parseSegments.call(self, request.response, info.url, info.range.start));\n                }\n            };\n\n            request.onloadend = request.onerror = function () {\n                if (!needFailureReport)\n                {\n                  return;\n                }\n                needFailureReport = false;\n\n                var data = {};\n                data.url = info.url;\n                data.request = request;\n                \n                self.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_SIDX, null, data);\n                deferred.reject(request);\n            };\n\n            request.open(\"GET\", self.tokenAuthentication.addTokenAsQueryArg(info.url));\n            request.responseType = \"arraybuffer\";\n            request.setRequestHeader(\"Range\", \"bytes=\" + info.range.start + \"-\" + info.range.end);\n            request = self.tokenAuthentication.setTokenInRequestHeader(request);\n            request.send(null);\n            self.debug.log(\"Perform SIDX load: \" + info.url);\n\n            return deferred.promise;\n        };\n\n    return {\n        debug: undefined,\n        errHandler: undefined,\n        tokenAuthentication:undefined,\n        loadSegments: loadSegments,\n        loadInitialization: loadInit,\n        parseSegments: parseSegments,\n        parseSIDX: parseSIDX,\n        findSIDX: findSIDX\n    };\n};\n\nDash.dependencies.BaseURLExtensions.prototype = {\n    constructor: Dash.dependencies.BaseURLExtensions\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nDash.di.DashContext = function () {\n    \"use strict\";\n\n    return {\n        system : undefined,\n        setup : function () {\n            Dash.di.DashContext.prototype.setup.call(this);\n\n            this.system.mapClass('parser', Dash.dependencies.DashParser);\n            this.system.mapClass('indexHandler', Dash.dependencies.DashHandler);\n            this.system.mapClass('baseURLExt', Dash.dependencies.BaseURLExtensions);\n            this.system.mapClass('fragmentExt', Dash.dependencies.FragmentExtensions);\n            this.system.mapSingleton('manifestExt', Dash.dependencies.DashManifestExtensions);\n            this.system.mapSingleton('metricsExt', Dash.dependencies.DashMetricsExtensions);\n            this.system.mapSingleton('timelineConverter', Dash.dependencies.TimelineConverter);\n        }\n    };\n};\n\nDash.di.DashContext.prototype = new MediaPlayer.di.Context();\nDash.di.DashContext.prototype.constructor = Dash.di.DashContext;\n","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nDash.dependencies.DashHandler = function() {\n    \"use strict\";\n\n    var index = -1,\n        requestedTime = null,\n        isDynamic,\n        type,\n\n        zeroPadToLength = function(numStr, minStrLength) {\n            while (numStr.length < minStrLength) {\n                numStr = \"0\" + numStr;\n            }\n\n            return numStr;\n        },\n\n        replaceTokenForTemplate = function(url, token, value) {\n            var startPos = 0,\n                endPos = 0,\n                tokenLen = token.length,\n                formatTag = \"%0\",\n                formatTagLen = formatTag.length,\n                formatTagPos,\n                specifier,\n                width,\n                paddedValue;\n\n            // keep looping round until all instances of <token> have been\n            // replaced. once that has happened, startPos below will be -1\n            // and the completed url will be returned.\n            while (true) {\n\n                // check if there is a valid $<token>...$ identifier\n                // if not, return the url as is.\n                startPos = url.indexOf(\"$\" + token);\n                if (startPos < 0) {\n                    return url;\n                }\n\n                // the next '$' must be the end of the identifer\n                // if there isn't one, return the url as is.\n                endPos = url.indexOf(\"$\", startPos + tokenLen);\n                if (endPos < 0) {\n                    return url;\n                }\n\n                // now see if there is an additional format tag suffixed to\n                // the identifier within the enclosing '$' characters\n                formatTagPos = url.indexOf(formatTag, startPos + tokenLen);\n                if (formatTagPos > startPos && formatTagPos < endPos) {\n\n                    specifier = url.charAt(endPos - 1);\n                    width = parseInt(url.substring(formatTagPos + formatTagLen, endPos - 1), 10);\n\n                    // support the minimum specifiers required by IEEE 1003.1\n                    // (d, i , o, u, x, and X) for completeness\n                    switch (specifier) {\n                        // treat all int types as uint,\n                        // hence deliberate fallthrough\n                        case 'd':\n                        case 'i':\n                        case 'u':\n                            paddedValue = zeroPadToLength(value.toString(), width);\n                            break;\n                        case 'x':\n                            paddedValue = zeroPadToLength(value.toString(16), width);\n                            break;\n                        case 'X':\n                            paddedValue = zeroPadToLength(value.toString(16), width).toUpperCase();\n                            break;\n                        case 'o':\n                            paddedValue = zeroPadToLength(value.toString(8), width);\n                            break;\n                        default:\n                            this.debug.log(\"Unsupported/invalid IEEE 1003.1 format identifier string in URL\");\n                            return url;\n                    }\n                } else {\n                    paddedValue = value;\n                }\n\n                url = url.substring(0, startPos) + paddedValue + url.substring(endPos + 1);\n            }\n        },\n\n        unescapeDollarsInTemplate = function(url) {\n            return url.split(\"$$\").join(\"$\");\n        },\n\n        replaceIDForTemplate = function(url, value) {\n            if (value === null || url.indexOf(\"$RepresentationID$\") === -1) {\n                return url;\n            }\n            var v = value.toString();\n            return url.split(\"$RepresentationID$\").join(v);\n        },\n\n        getNumberForSegment = function(segment, segmentIndex) {\n            return segment.representation.startNumber + segmentIndex;\n        },\n\n        getRequestUrl = function(destination, representation) {\n            var baseURL = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].\n            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].BaseURL,\n            url;\n\n            if (destination === baseURL) {\n                url = destination;\n            } else if ((destination.indexOf(\"http://\") !== -1) || (destination.indexOf(\"https://\") !== -1)) {\n                url = destination;\n            } else {\n                url = baseURL + destination;\n            }\n\n            return url;\n        },\n\n        generateInitRequest = function(representation, streamType) {\n            var self = this,\n                period,\n                request = new MediaPlayer.vo.SegmentRequest(),\n                presentationStartTime;\n\n            period = representation.adaptation.period;\n\n            request.streamType = streamType;\n            request.type = \"Initialization Segment\";\n            request.url = getRequestUrl(representation.initialization, representation);\n            request.range = representation.range;\n            presentationStartTime = period.start;\n            request.availabilityStartTime = self.timelineConverter.calcAvailabilityStartTimeFromPresentationTime(presentationStartTime, representation.adaptation.period.mpd, isDynamic);\n            request.availabilityEndTime = self.timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationStartTime + period.duration, period.mpd, isDynamic);\n            request.quality = representation.index;\n\n            return request;\n        },\n\n        getInit = function(representation) {\n            var deferred = Q.defer(),\n                request = null,\n                url = null,\n                self = this;\n\n            if (!representation) {\n                return Q.reject(\"no represenation\");\n            }\n\n            //self.debug.log(\"Getting the initialization request.\");\n\n            if (representation.initialization) {\n                //self.debug.log(\"Got an initialization.\");\n                request = generateInitRequest.call(self, representation, type);\n                deferred.resolve(request);\n            } else {\n                // Go out and find the initialization.\n                url = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].\n                AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].BaseURL;\n                self.baseURLExt.loadInitialization(url).then(\n                    function(theRange) {\n                        //self.debug.log(\"Got an initialization.\");\n                        representation.range = theRange;\n                        representation.initialization = url;\n                        request = generateInitRequest.call(self, representation, type);\n                        deferred.resolve(request);\n                    },\n                    function(httprequest) {\n                        deferred.reject(httprequest);\n                    }\n                );\n            }\n\n            return deferred.promise;\n        },\n\n        isMediaFinished = function(representation) { // TODO\n            var sDuration,\n                period = representation.adaptation.period,\n                isFinished = false,\n                seg,\n                fTime;\n\n            //this.debug.log(\"Checking for stream end...\");\n            if (isDynamic) {\n                //this.debug.log(\"Live never ends! (TODO)\");\n                // TODO : Check the contents of the last box to signal end.\n                isFinished = false;\n            } else {\n                if (index < 0) {\n                    isFinished = false;\n                } else if (index < representation.availableSegmentsNumber + representation.segmentStartIndex) {\n                    seg = getSegmentByIndex(index, representation);\n\n                    if (seg) {\n                        fTime = seg.presentationStartTime - period.start;\n                        sDuration = representation.adaptation.period.duration;\n                        //this.debug.log(representation.segmentInfoType + \": \" + fTime + \" / \" + sDuration);\n                        isFinished = (fTime >= sDuration);\n                    }\n                } else {\n                    isFinished = true;\n                }\n            }\n\n            return isFinished;\n        },\n\n        getIndexBasedSegment = function(representation, index) {\n            var self = this,\n                seg,\n                duration,\n                presentationStartTime,\n                presentationEndTime;\n\n            duration = representation.segmentDuration;\n            presentationStartTime = representation.adaptation.period.start + (index * duration);\n            presentationEndTime = presentationStartTime + duration;\n\n            seg = new Dash.vo.Segment();\n\n            seg.representation = representation;\n            seg.duration = duration;\n            seg.presentationStartTime = presentationStartTime;\n\n            seg.mediaStartTime = self.timelineConverter.calcMediaTimeFromPresentationTime(seg.presentationStartTime, representation);\n\n            seg.availabilityStartTime = self.timelineConverter.calcAvailabilityStartTimeFromPresentationTime(seg.presentationStartTime, representation.adaptation.period.mpd, isDynamic);\n            seg.availabilityEndTime = self.timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationEndTime, representation.adaptation.period.mpd, isDynamic);\n\n            // at this wall clock time, the video element currentTime should be seg.presentationStartTime\n            seg.wallStartTime = self.timelineConverter.calcWallTimeForSegment(seg, isDynamic);\n\n            seg.replacementNumber = getNumberForSegment(seg, index);\n            seg.availabilityIdx = index;\n\n            //this.debug.log(\"[DashHandler][\"+type+\"] createSegment: time = \" + seg.mediaStartTime + \", availabilityIdx = \" + seg.availabilityIdx);\n\n            return seg;\n        },\n\n        getSegmentsFromTimeline = function(representation) {\n            var self = this,\n                template = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].\n            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentTemplate,\n            timeline = template.SegmentTimeline,\n            isAvailableSegmentNumberCalculated = representation.availableSegmentsNumber > 0,\n            maxSegmentsAhead = 10,\n            segments = [],\n            fragments,\n            frag,\n            i,\n            len,\n            j,\n            repeat,\n            repeatEndTime,\n            nextFrag,\n            time = 0,\n            availabilityIdx = -1,\n            calculatedRange,\n            hasEnoughSegments = false,\n            requiredMediaTime,\n            startIdx,\n            endIdx,\n            fTimescale,\n            createSegment = function(s) {\n                return getTimeBasedSegment.call(\n                    self,\n                    representation,\n                    time,\n                    s.d,\n                    fTimescale,\n                    template.media,\n                    s.mediaRange,\n                    availabilityIdx,\n                    s.tManifest);\n            };\n\n            fTimescale = representation.timescale;\n\n            fragments = timeline.S_asArray;\n\n            calculatedRange = decideSegmentListRangeForTimeline.call(self, representation);\n\n            // if calculatedRange exists we should generate segments that belong to this range.\n            // Otherwise generate maxSegmentsAhead segments ahead of the requested time\n            if (calculatedRange) {\n                startIdx = calculatedRange.start;\n                endIdx = calculatedRange.end;\n            } else {\n                requiredMediaTime = self.timelineConverter.calcMediaTimeFromPresentationTime(requestedTime || 0, representation);\n            }\n\n            for (i = 0, len = fragments.length; i < len; i += 1) {\n                frag = fragments[i];\n                repeat = 0;\n                if (frag.hasOwnProperty(\"r\")) {\n                    repeat = frag.r;\n                }\n\n                //For a repeated S element, t belongs only to the first segment\n                if (frag.hasOwnProperty(\"t\")) {\n                    time = frag.t;\n                }\n\n                //This is a special case: \"A negative value of the @r attribute of the S element indicates that the duration indicated in @d attribute repeats until the start of the next S element, the end of the Period or until the\n                // next MPD update.\"\n                if (repeat < 0) {\n                    nextFrag = fragments[i + 1];\n                    repeatEndTime = (nextFrag && nextFrag.hasOwnProperty(\"t\")) ? (nextFrag.t / fTimescale) : representation.adaptation.period.duration;\n                    repeat = Math.ceil((repeatEndTime - time / fTimescale) / (frag.d / fTimescale)) - 1;\n                }\n\n                // if we have enough segments in the list, but we have not calculated the total number of the segments yet we\n                // should continue the loop and calc the number. Once it is calculated, we can break the loop.\n                if (hasEnoughSegments) {\n                    if (isAvailableSegmentNumberCalculated) break;\n                    availabilityIdx += repeat + 1;\n                    continue;\n                }\n\n                for (j = 0; j <= repeat; j += 1) {\n                    availabilityIdx += 1;\n\n                    if (calculatedRange) {\n                        if (availabilityIdx > endIdx) {\n                            hasEnoughSegments = true;\n                            if (isAvailableSegmentNumberCalculated) break;\n                            continue;\n                        }\n\n                        if (availabilityIdx >= startIdx) {\n                            segments.push(createSegment.call(self, frag));\n                        }\n                    } else {\n                        if (segments.length > maxSegmentsAhead) {\n                            hasEnoughSegments = true;\n                            if (isAvailableSegmentNumberCalculated) break;\n                            continue;\n                        }\n\n                        if (time / fTimescale >= (requiredMediaTime - (frag.d / fTimescale))) {\n                            segments.push(createSegment.call(self, frag));\n                        }\n                    }\n\n                    time += frag.d;\n                }\n            }\n\n            if (!isAvailableSegmentNumberCalculated) {\n                var availabilityStartTime,\n                    availabilityEndTime,\n                    f = fragments[0];\n\n                availabilityStartTime = (f.t === undefined) ? 0 : self.timelineConverter.calcPresentationTimeFromMediaTime(f.t / fTimescale, representation);\n                availabilityEndTime = self.timelineConverter.calcPresentationTimeFromMediaTime((time - frag.d) / fTimescale, representation);\n                representation.segmentAvailabilityRange = {\n                    start: availabilityStartTime,\n                    end: availabilityEndTime\n                };\n                representation.availableSegmentsNumber = availabilityIdx + 1;\n                representation.segmentStartIndex = 0;\n            }\n\n            return Q.when(segments);\n        },\n\n        getSegmentsFromTemplate = function(representation) {\n            var segments = [],\n                self = this,\n                deferred = Q.defer(),\n                template = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].\n            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentTemplate,\n            duration = representation.segmentDuration,\n            segmentRange = null,\n            periodStartIdx = Math.floor(representation.adaptation.period.start / duration),\n            i,\n            startIdx,\n            endIdx,\n            seg = null,\n            start,\n            url = null;\n\n            start = representation.startNumber;\n\n            waitForAvailabilityWindow.call(self, representation).then(\n                function(availabilityWindow) {\n                    representation.segmentAvailabilityRange = availabilityWindow;\n                    segmentRange = decideSegmentListRangeForTemplate.call(self, representation);\n\n                    startIdx = segmentRange.start;\n                    endIdx = segmentRange.end;\n\n                    for (i = startIdx; i <= endIdx; i += 1) {\n\n                        seg = getIndexBasedSegment.call(\n                            self,\n                            representation,\n                            i - (isDynamic ? periodStartIdx : 0));\n\n                        seg.replacementTime = (start + i - 1) * representation.segmentDuration;\n                        url = template.media;\n                        url = replaceTokenForTemplate(url, \"Number\", seg.replacementNumber);\n                        url = replaceTokenForTemplate(url, \"Time\", seg.replacementTime);\n                        seg.media = url;\n\n                        segments.push(seg);\n                        seg = null;\n                    }\n\n                    representation.availableSegmentsNumber = periodStartIdx + Math.ceil((availabilityWindow.end - availabilityWindow.start) / duration);\n                    representation.segmentStartIndex = startIdx;\n\n                    deferred.resolve(segments);\n                }\n            );\n\n            return deferred.promise;\n        },\n\n        decideSegmentListRangeForTemplate = function(representation) {\n            var self = this,\n                periodStart = representation.adaptation.period.start,\n                duration = representation.segmentDuration,\n                minBufferTime = representation.adaptation.period.mpd.manifest.minBufferTime,\n                availabilityWindow = representation.segmentAvailabilityRange,\n                originAvailabilityTime = NaN,\n                originSegment = null,\n                currentSegmentList = representation.segments,\n                availabilityLowerLimit = 2 * duration,\n                availabilityUpperLimit = Math.max(2 * minBufferTime, 10 * duration),\n                start,\n                end,\n                range;\n\n            if (!availabilityWindow) {\n                availabilityWindow = self.timelineConverter.calcSegmentAvailabilityRange(representation, isDynamic);\n            }\n\n            if (isDynamic && !representation.adaptation.period.mpd.isClientServerTimeSyncCompleted) {\n                start = Math.floor(availabilityWindow.start / duration);\n                end = Math.floor(availabilityWindow.end / duration);\n                range = {\n                    start: start,\n                    end: end\n                };\n                return range;\n            }\n\n            // if segments exist we should try to find the latest buffered time, which is the presentation time of the\n            // segment for the current index\n            if (currentSegmentList) {\n                originSegment = getSegmentByIndex(index, representation);\n                originAvailabilityTime = originSegment ? (originSegment.presentationStartTime - periodStart) : (index > 0 ? (index * duration) : (requestedTime - periodStart) || (currentSegmentList[0].presentationStartTime - periodStart));\n            } else {\n                // If no segments exist, but index > 0, it means that we switch to the other representation, so\n                // we should proceed from this time.\n                // Otherwise we should start from the beginning for static mpds or from the end (live edge) for dynamic mpds\n                originAvailabilityTime = (index > 0) ? (index * duration) : (isDynamic ? availabilityWindow.end : availabilityWindow.start);\n            }\n\n            // segment list should not be out of the availability window range\n            start = Math.floor(Math.max(originAvailabilityTime - availabilityLowerLimit, availabilityWindow.start) / duration);\n            end = Math.floor(Math.min(start + availabilityUpperLimit / duration, availabilityWindow.end / duration));\n\n            range = {\n                start: start,\n                end: end\n            };\n\n            return range;\n        },\n\n        decideSegmentListRangeForTimeline = function(representation) {\n            var originAvailabilityIdx = NaN,\n                currentSegmentList = representation.segments,\n                availabilityLowerLimit = 2,\n                availabilityUpperLimit = 10,\n                firstIdx = 0,\n                lastIdx = Number.POSITIVE_INFINITY,\n                start,\n                end,\n                range;\n\n            if (isDynamic && !representation.adaptation.period.mpd.isClientServerTimeSyncCompleted) {\n                range = {\n                    start: firstIdx,\n                    end: lastIdx\n                };\n                return range;\n            }\n\n            if (!isDynamic && requestedTime !== null) {\n                return null;\n            }\n\n            // if segments exist use the current index as an origin index for a new range\n            if (currentSegmentList) {\n                // if the index is negative we can't calculate the range right now\n                if (index < 0) {\n                    return null;\n                }\n                originAvailabilityIdx = index;\n            } else {\n                // If no segments exist, but index > 0, it means that we switch to the other representation, so\n                // we should proceed from this index.\n                // Otherwise we should start from the beginning for static mpds or from the end (live edge) for dynamic mpds\n                originAvailabilityIdx = (index > 0) ? index : (isDynamic ? lastIdx : firstIdx);\n            }\n\n            // segment list should not be out of the availability window range\n            start = Math.max(originAvailabilityIdx - availabilityLowerLimit, firstIdx);\n            end = Math.min(originAvailabilityIdx + availabilityUpperLimit, lastIdx);\n\n            range = {\n                start: start,\n                end: end\n            };\n\n            return range;\n        },\n\n        waitForAvailabilityWindow = function(representation) {\n            var self = this,\n                deferred = Q.defer(),\n                range,\n                waitingTime,\n                getRange = function() {\n                    range = self.timelineConverter.calcSegmentAvailabilityRange(representation, isDynamic);\n\n                    if (range.end > 0) {\n                        deferred.resolve(range);\n                    } else {\n                        // range.end represents a time gap between the current wall-clock time and the availability time of the first segment.\n                        // A negative value means that no segments are available yet, we should wait until segments become available\n                        waitingTime = Math.abs(range.end) * 1000;\n                        setTimeout(getRange, waitingTime);\n                    }\n                };\n\n            getRange();\n\n            return deferred.promise;\n        },\n\n        getTimeBasedSegment = function(representation, time, duration, fTimescale, url, range, index, tManifest) {\n            var self = this,\n                scaledTime = time / fTimescale,\n                scaledDuration = Math.min(duration / fTimescale, representation.adaptation.period.mpd.maxSegmentDuration),\n                presentationStartTime,\n                presentationEndTime,\n                seg;\n\n            presentationStartTime = self.timelineConverter.calcPresentationTimeFromMediaTime(scaledTime, representation);\n            // ORANGE: presentationStartTime is the media time of the segment as provided in the SegmentTimeline\n            presentationStartTime = scaledTime; //self.timelineConverter.calcPresentationTimeFromMediaTime(scaledTime, representation);\n            presentationEndTime = presentationStartTime + scaledDuration;\n\n            seg = new Dash.vo.Segment();\n\n            seg.representation = representation;\n            seg.duration = scaledDuration;\n            seg.mediaStartTime = scaledTime;\n\n            seg.presentationStartTime = presentationStartTime;\n\n            // For SegmentTimeline every segment is available at mpdLoadedTime\n            seg.availabilityStartTime = representation.adaptation.period.mpd.manifest.mpdLoadedTime;\n            seg.availabilityEndTime = self.timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationEndTime, representation.adaptation.period.mpd, isDynamic);\n\n            // at this wall clock time, the video element currentTime should be seg.presentationStartTime\n            seg.wallStartTime = self.timelineConverter.calcWallTimeForSegment(seg, isDynamic);\n\n            seg.replacementTime = tManifest ? tManifest : time;\n\n            seg.replacementNumber = getNumberForSegment(seg, index);\n\n            url = replaceTokenForTemplate(url, \"Number\", seg.replacementNumber);\n            url = replaceTokenForTemplate(url, \"Time\", seg.replacementTime);\n            seg.media = url;\n            seg.mediaRange = range;\n            seg.availabilityIdx = index;\n\n            //this.debug.log(\"[DashHandler][\"+type+\"] createSegment: time = \" + seg.mediaStartTime + \", availabilityIdx = \" + seg.availabilityIdx + \", url = \" + seg.media);\n\n            return seg;\n        },\n\n        getSegmentsFromList = function(representation) {\n            var self = this,\n                segments = [],\n                deferred = Q.defer(),\n                list = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].\n            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentList,\n            len = list.SegmentURL_asArray.length,\n            i,\n            seg,\n            s,\n            range,\n            startIdx = 0,\n            endIdx = list.SegmentURL_asArray.length,\n            start;\n\n            start = representation.startNumber;\n\n            waitForAvailabilityWindow.call(self, representation).then(\n                function(availabilityWindow) {\n                    if (!isDynamic) {\n                        range = decideSegmentListRangeForTemplate.call(self, representation);\n                        startIdx = range.start;\n                        endIdx = range.end;\n                    }\n\n                    for (i = startIdx; i < endIdx; i += 1) {\n                        s = list.SegmentURL_asArray[i];\n\n                        seg = getIndexBasedSegment.call(\n                            self,\n                            representation,\n                            i);\n\n                        seg.replacementTime = (start + i - 1) * representation.segmentDuration;\n                        seg.media = s.media;\n                        seg.mediaRange = s.mediaRange;\n                        seg.index = s.index;\n                        seg.indexRange = s.indexRange;\n\n                        // ORANGE: overwrite duration if set at segment level (HLS use case)\n                        if (s.duration) {\n                            seg.duration = s.duration;\n                            seg.presentationStartTime = seg.mediaStartTime = s.time;\n                        }\n\n                        // ORANGE: add sequence number (HLS use case)\n                        if (s.sequenceNumber !== undefined) {\n                            seg.sequenceNumber = s.sequenceNumber;\n                        }\n                        // ORANGE: add decryption info (HLS use case)\n                        if (s.decryptionInfo !== undefined) {\n                            seg.decryptionInfo = s.decryptionInfo;\n                        }\n                        //self.debug.log(\"[DashHandler][\"+type+\"] createSegment: time = \" + seg.mediaStartTime + \", availabilityIdx = \" + seg.availabilityIdx + \", url = \" + seg.media);\n\n                        segments.push(seg);\n                        seg = null;\n                    }\n                    representation.segmentAvailabilityRange = availabilityWindow;\n                    representation.availableSegmentsNumber = len;\n                    representation.segmentStartIndex = startIdx;\n                    deferred.resolve(segments);\n                });\n\n            return deferred.promise;\n        },\n\n        getSegmentsFromSource = function(representation) {\n            var self = this,\n                baseURL = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].\n            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].BaseURL,\n            deferred = Q.defer(),\n            segments = [],\n            count = 0,\n            range = null,\n            s,\n            i,\n            len,\n            seg;\n\n            if (representation.indexRange) {\n                range = representation.indexRange;\n            }\n\n            this.baseURLExt.loadSegments(baseURL, range).then(\n                function(fragments) {\n                    for (i = 0, len = fragments.length; i < len; i += 1) {\n                        s = fragments[i];\n\n                        seg = getTimeBasedSegment.call(\n                            self,\n                            representation,\n                            s.startTime,\n                            s.duration,\n                            s.timescale,\n                            s.media,\n                            s.mediaRange,\n                            count);\n\n                        segments.push(seg);\n                        seg = null;\n                        count += 1;\n                    }\n\n                    representation.segmentAvailabilityRange = {\n                        start: segments[0].presentationStartTime,\n                        end: segments[len - 1].presentationStartTime\n                    };\n                    representation.availableSegmentsNumber = len;\n                    representation.segmentStartIndex = 0;\n                    deferred.resolve(segments);\n                }, function(){\n                    deferred.reject();\n                }\n            );\n\n            return deferred.promise;\n        },\n\n        getSegments = function(representation) {\n            var segmentPromise,\n                deferred = Q.defer(),\n                self = this,\n                lastIdx;\n\n            //self.debug.log(\"[DashHandler][\"+type+\"] getSegments for representation \" + representation.id);\n            // Already figure out the segments.\n            if (!isSegmentListUpdateRequired.call(self, representation)) {\n                return Q.when(representation.segments);\n            } else {\n                if (representation.segmentInfoType === \"SegmentTimeline\") {\n                    segmentPromise = getSegmentsFromTimeline.call(self, representation);\n                } else if (representation.segmentInfoType === \"SegmentTemplate\") {\n                    segmentPromise = getSegmentsFromTemplate.call(self, representation);\n                } else if (representation.segmentInfoType === \"SegmentList\") {\n                    segmentPromise = getSegmentsFromList.call(self, representation);\n                } else {\n                    segmentPromise = getSegmentsFromSource.call(self, representation);\n                }\n\n                Q.when(segmentPromise).then(\n                    function(segments) {\n                        representation.segments = segments;\n                        lastIdx = segments.length - 1;\n                        if (isDynamic && isNaN(representation.adaptation.period.liveEdge)) {\n                            var metrics = self.metricsModel.getMetricsFor(\"stream\"),\n                                liveEdge = segments[lastIdx].presentationStartTime;\n                            // the last segment is supposed to be a live edge\n                            representation.adaptation.period.liveEdge = liveEdge;\n                            self.metricsModel.updateManifestUpdateInfo(self.metricsExt.getCurrentManifestUpdate(metrics), {\n                                presentationStartTime: liveEdge\n                            });\n                        }\n\n                        deferred.resolve(segments);\n                    }, function(){\n                        deferred.reject();\n                    }\n                );\n            }\n\n            return deferred.promise;\n        },\n\n        updateSegmentList = function(representation) {\n            var self = this,\n                deferred = Q.defer();\n\n            representation.segments = null;\n\n            self.debug.log(\"[DashHandler][\" + type + \"] updateSegmentList for representation \", representation.id);\n\n            getSegments.call(self, representation).then(\n                function(segments) {\n                    representation.segments = segments;\n                    deferred.resolve(segments);\n                }\n            );\n\n            return deferred.promise;\n        },\n\n        getIndexForSegments = function(time, representation) {\n            var segments = representation === null ? null : representation.segments,\n                segmentLastIdx = segments === null ? 0 : segments.length - 1,\n                idx = -1,\n                frag,\n                ft,\n                fd,\n                i,\n                self = this;\n\n            self.debug.log(\"[DashHandler][\" + type + \"] getIndexForSegments for time \", time);\n\n            if (segments && segments.length > 0) {\n                for (i = segmentLastIdx; i >= 0; i--) {\n                    frag = segments[i];\n                    ft = frag.presentationStartTime;\n                    fd = frag.duration;\n                    //self.debug.log(\"[DashHandler][\"+type+\"] ft = \" + ft + \", fd = \" + fd + \", idx = \" + frag.availabilityIdx);\n                    if ((time + Dash.dependencies.DashHandler.EPSILON) >= ft &&\n                        (time - Dash.dependencies.DashHandler.EPSILON) <= (ft + fd)) {\n                        idx = frag.availabilityIdx;\n                        self.debug.log(\"[DashHandler][\" + type + \"] getIndexForSegments, idx =  \", idx);\n                        break;\n                    } else if (idx === -1 && (time - Dash.dependencies.DashHandler.EPSILON) > (ft + fd)) {\n                        // time is past the end\n                        self.debug.log(\"[DashHandler][\" + type + \"] getIndexForSegments, (past the end) idx =  \", idx);\n                        idx = isNaN(representation.segmentDuration) ? (frag.availabilityIdx + 1) : Math.floor((time - representation.adaptation.period.start) / representation.segmentDuration);\n                        //ORANGE : we have past the end, don't iterate for nothing\n                        break;\n                    }\n                }\n            }\n\n            if (idx === -1) {\n                if (!isNaN(representation.segmentDuration)) {\n                    self.debug.log(\"[DashHandler][\" + type + \"] getIndexForSegments, (segment duration) idx =  \", idx);\n                    idx = Math.floor((time - representation.adaptation.period.start) / representation.segmentDuration);\n                } else if (segments && segments.length > 0 && time < segments[0].presentationStartTime) {\n                    self.debug.log(\"[DashHandler][\" + type + \"] getIndexForSegments, (before start) idx =  \", idx);\n                    idx = 0;\n                } else {\n                    self.debug.log(\"[DashHandler][\" + type + \"] Couldn't figure out segment for time: \" + time);\n                }\n            }\n\n            /*\n            if (segments && segments.length > 0) {\n                idx = 0;\n                ft = segments[0].startTime / segments[0].timescale;\n                frag = null;\n\n                while (ft <= time && (idx + 1) < segments.length) {\n                    frag = segments[idx];\n                    ft += frag.duration / frag.timescale;\n                    idx += 1;\n                }\n                idx -= 1;\n            }\n            */\n\n            return Q.when(idx);\n        },\n\n        getSegmentByIndex = function(index, representation) {\n            if (!representation || !representation.segments) {\n                return null;\n            }\n\n            var ln = representation.segments.length,\n                seg,\n                i;\n\n            for (i = 0; i < ln; i += 1) {\n                seg = representation.segments[i];\n\n                if (seg.availabilityIdx === index) {\n                    return seg;\n                }\n            }\n\n            return null;\n        },\n\n        // ORANGE: HLS use case, get next segment from sequence number\n        getNextSegmentBySequenceNumber = function(sn, representation) {\n            if (!representation || !representation.segments) {\n                return null;\n            }\n\n            var ln = representation.segments.length,\n                seg,\n                i;\n\n            for (i = 0; i < ln; i += 1) {\n                seg = representation.segments[i];\n\n                if ((seg.sequenceNumber !== undefined) && (seg.sequenceNumber === sn)) {\n                    if (i < (ln - 1)) {\n                        return representation.segments[i + 1];\n                    }\n                    return null;\n                }\n            }\n\n            return null;\n        },\n\n        isSegmentListUpdateRequired = function(representation) {\n            var updateRequired = false,\n                segments = representation.segments,\n                upperIdx,\n                lowerIdx,\n                upperTime,\n                lowerTime;\n\n            if (!segments || segments.length === 0) {\n                updateRequired = true;\n            } else {\n                if (requestedTime !== null) {\n                    lowerTime = segments[0].presentationStartTime;\n                    upperTime = segments[segments.length - 1].presentationStartTime;\n                    updateRequired = (requestedTime < lowerTime) || (requestedTime > upperTime);\n                } else {\n                    lowerIdx = segments[0].availabilityIdx;\n                    upperIdx = segments[segments.length - 1].availabilityIdx;\n                    updateRequired = (index < lowerIdx) || (index > upperIdx);\n                }\n            }\n\n            return updateRequired;\n        },\n\n        getRequestForSegment = function(segment) {\n            if (segment === null || segment === undefined) {\n                return null;\n            }\n\n            var request = new MediaPlayer.vo.SegmentRequest(),\n                representation = segment.representation,\n                bandwidth = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].\n            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].bandwidth,\n            url;\n\n            url = getRequestUrl(segment.media, representation);\n            url = replaceTokenForTemplate(url, \"Number\", segment.replacementNumber);\n            url = replaceTokenForTemplate(url, \"Time\", segment.replacementTime);\n            url = replaceTokenForTemplate(url, \"Bandwidth\", bandwidth);\n            url = replaceIDForTemplate(url, representation.id);\n            url = unescapeDollarsInTemplate(url);\n\n            request.streamType = type;\n            request.type = \"Media Segment\";\n            request.url = url;\n            request.range = segment.mediaRange;\n            request.startTime = segment.presentationStartTime;\n            request.duration = segment.duration;\n            request.timescale = representation.timescale;\n            request.availabilityStartTime = segment.availabilityStartTime;\n            request.availabilityEndTime = segment.availabilityEndTime;\n            request.wallStartTime = segment.wallStartTime;\n            request.quality = representation.index;\n            request.index = segment.availabilityIdx;\n            // ORANGE: add sequence number (HLS use case)\n            if (segment.sequenceNumber !== undefined) {\n                request.sequenceNumber = segment.sequenceNumber;\n            }\n            // ORANGE: add decryption info (HLS use case)\n            if (segment.decryptionInfo !== undefined) {\n                request.decryptionInfo = segment.decryptionInfo;\n            }\n\n            return request;\n        },\n\n        getForTime = function(representation, time) {\n            var deferred,\n                request,\n                segment,\n                self = this;\n\n            if (!representation) {\n                return Q.reject(\"no representation\");\n            }\n\n            requestedTime = time;\n            index = -1;\n\n            self.debug.log(\"[DashHandler][\" + type + \"] Getting the request for time: \" + time);\n\n            deferred = Q.defer();\n\n            getSegments.call(self, representation).then(\n                function( /*segments*/ ) {\n                    var segmentsPromise;\n\n                    //self.debug.log(\"Got segments.\");\n                    //self.debug.log(segments);\n                    //self.debug.log(\"Got a list of segments, so dig deeper.\");\n                    segmentsPromise = getIndexForSegments.call(self, time, representation);\n                    return segmentsPromise;\n                }, function(){deferred.reject();}\n            ).then(\n                function(newIndex) {\n                    self.debug.log(\"[DashHandler][\" + type + \"] Index for time \" + time + \" is \" + newIndex);\n                    index = newIndex;\n\n                    return Q.when(isMediaFinished.call(self, representation));\n                }\n            ).then(\n                function(finished) {\n                    var requestForSegment = null;\n\n                    //self.debug.log(\"Stream finished? \" + finished);\n                    if (finished) {\n                        request = new MediaPlayer.vo.SegmentRequest();\n                        request.action = request.ACTION_COMPLETE;\n                        request.index = index;\n                        self.debug.log(\"[DashHandler][\" + type + \"] Signal complete.\");\n                        self.debug.log(request);\n                        deferred.resolve(request);\n                    } else {\n                        segment = getSegmentByIndex(index, representation);\n                        requestForSegment = getRequestForSegment.call(self, segment);\n                    }\n\n                    return Q.when(requestForSegment);\n                }\n            ).then(\n                function(request) {\n                    //self.debug.log(\"Got a request.\");\n                    //self.debug.log(request);\n                    deferred.resolve(request);\n                }\n            );\n\n            return deferred.promise;\n        },\n\n        getNext = function(representation) {\n            var deferred,\n                request,\n                segment,\n                finished,\n                self = this;\n\n            if (!representation) {\n                return Q.reject(\"no represenation\");\n            }\n\n            //self.debug.log(\"Getting the next request.\");\n\n            if (index === -1) {\n                throw \"You must call getSegmentRequestForTime first.\";\n            }\n\n            requestedTime = null;\n            index += 1;\n\n            deferred = Q.defer();\n\n            self.debug.log(\"[DashHandler][\" + type + \"] Getting the next request => index = \" + index);\n\n            finished = isMediaFinished.call(self, representation);\n            //self.debug.log(\"Stream finished? \" + finished);\n            if (finished) {\n                request = new MediaPlayer.vo.SegmentRequest();\n                request.action = request.ACTION_COMPLETE;\n                request.index = index;\n                self.debug.log(\"[DashHandler][\" + type + \"] Signal complete.\");\n                //self.debug.log(request);\n                deferred.resolve(request);\n            } else {\n                getSegments.call(self, representation).then(\n                    function( /*segments*/ ) {\n                        var segmentsPromise;\n\n                        //self.debug.log(\"Got segments.\");\n                        //self.debug.log(segments);\n                        segment = getSegmentByIndex(index, representation);\n                        segmentsPromise = getRequestForSegment.call(self, segment);\n                        return Q.when(segmentsPromise);\n                    }\n                ).then(\n                    function(request) {\n                        //self.debug.log(\"Got a request.\");\n                        //self.debug.log(request);\n                        deferred.resolve(request);\n                    }\n                );\n            }\n\n            return deferred.promise;\n        },\n\n        // ORANGE: HLS use case, get next request from sequence number\n        getNextFromSN = function(representation, sn) {\n            var deferred,\n                request,\n                segment,\n                finished,\n                self = this;\n\n            if (!representation) {\n                return Q.reject(\"no represenation\");\n            }\n\n            //self.debug.log(\"Getting the next request.\");\n\n            if (index === -1) {\n                throw \"You must call getSegmentRequestForTime first.\";\n            }\n\n            requestedTime = null;\n            index += 1;\n\n            deferred = Q.defer();\n\n            self.debug.log(\"[DashHandler][\" + type + \"] Getting the next request => sn = \" + sn);\n\n            getSegments.call(self, representation).then(\n                function( /*segments*/ ) {\n                    finished = isMediaFinished.call(self, representation);\n                    //self.debug.log(\"Stream finished? \" + finished);\n                    if (finished) {\n                        request = new MediaPlayer.vo.SegmentRequest();\n                        request.action = request.ACTION_COMPLETE;\n                        request.index = index;\n                        self.debug.log(\"[DashHandler][\" + type + \"] Signal complete.\");\n                        //self.debug.log(request);\n                        deferred.resolve(request);\n                    } else {\n                        segment = getNextSegmentBySequenceNumber(sn, representation);\n                        if (segment === null) {\n                            deferred.resolve(null);\n                        } else {\n                            index = segment.availabilityIdx;\n                            var requestForSegment = getRequestForSegment.call(self, segment);\n                            //self.debug.log(\"Got a request.\");\n                            //self.debug.log(request);\n                            deferred.resolve(requestForSegment);\n                        }\n                    }\n                }\n            );\n\n            return deferred.promise;\n        },\n\n        getSegmentCountForDuration = function(representation, requiredDuration, bufferedDuration) {\n            var self = this,\n                remainingDuration = Math.max(requiredDuration - bufferedDuration, 0),\n                deferred = Q.defer(),\n                segmentDuration,\n                segmentCount = 0;\n\n            if (!representation) {\n                return Q.reject(\"no represenation\");\n            }\n\n            self.debug.log(\"[DashHandler][\" + type + \"] getSegmentCountForDuration\");\n\n            getSegments.call(self, representation).then(\n                function(segments) {\n                    segmentDuration = segments[0].duration;\n                    segmentCount = Math.ceil(remainingDuration / segmentDuration);\n                    deferred.resolve(segmentCount);\n                },\n                function() {\n                    deferred.resolve(0);\n                }\n            );\n\n            return deferred.promise;\n        },\n\n        getCurrentTime = function(representation) {\n            var self = this,\n                time,\n                bufferedIndex,\n                deferred = Q.defer();\n\n            if (!representation) {\n                return Q.reject(\"no represenation\");\n            }\n\n            bufferedIndex = index;\n\n            getSegments.call(self, representation).then(\n                function(segments) {\n                    if (bufferedIndex < 0) {\n                        time = self.timelineConverter.calcPresentationStartTime(representation.adaptation.period);\n                    } else {\n                        bufferedIndex = bufferedIndex < segments[0].availabilityIdx ? segments[0].availabilityIdx : Math.min(segments[segments.length - 1].availabilityIdx, bufferedIndex);\n                        time = getSegmentByIndex(bufferedIndex, representation).presentationStartTime;\n                        self.debug.log(\"[DashHandler][\" + type + \"] getSegmentByIndex, index = \" + bufferedIndex + \" => time = \" + time);\n                    }\n\n                    self.debug.log(\"[DashHandler][\" + type + \"] getCurrentTime => \", time);\n                    deferred.resolve(time);\n                },\n                function() {\n                    deferred.reject();\n                }\n            );\n\n            return deferred.promise;\n        },\n\n        getIFrameRequest = function( /*request*/ ) {\n            //TBD\n        },\n\n        getFragmentInfoRequest = function( /*request*/ ) {\n            //TBD\n        };\n\n    return {\n        debug: undefined,\n        baseURLExt: undefined,\n        metricsModel: undefined,\n        metricsExt: undefined,\n        manifestModel: undefined,\n        manifestExt: undefined,\n        timelineConverter: undefined,\n        capabilities: undefined,\n        videoModel: undefined,\n\n        getType: function() {\n            return type;\n        },\n\n        setType: function(value) {\n            type = value;\n        },\n\n        getIsDynamic: function() {\n            return isDynamic;\n        },\n        setIsDynamic: function(value) {\n            isDynamic = value;\n        },\n\n        getInitRequest: getInit,\n        getSegmentRequestForTime: getForTime,\n        getNextSegmentRequest: getNext,\n        // ORANGE: HLS use case, get next request from sequence number\n        getNextSegmentRequestFromSN: getNextFromSN,\n        getCurrentTime: getCurrentTime,\n        getSegmentCountForDuration: getSegmentCountForDuration,\n        updateSegmentList: updateSegmentList,\n        getIFrameRequest: getIFrameRequest,\n        getFragmentInfoRequest: getFragmentInfoRequest\n    };\n};\n\nDash.dependencies.DashHandler.EPSILON = 0.003;\n\nDash.dependencies.DashHandler.prototype = {\n    constructor: Dash.dependencies.DashHandler\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\nDash.dependencies.DashManifestExtensions = function() {\n    \"use strict\";\n    this.timelineConverter = undefined;\n};\n\nDash.dependencies.DashManifestExtensions.prototype = {\n    constructor: Dash.dependencies.DashManifestExtensions,\n\n    getIsType: function(adaptation, type, mimeTypes) {\n        \"use strict\";\n        var i, j,\n            found = false,\n            col,\n            representation;\n\n        if (!adaptation) {\n            return false;\n        }\n\n        if (adaptation.type === undefined) {\n            adaptation.type = null;\n        }\n\n        col = adaptation.ContentComponent_asArray;\n\n        if (col) {\n            // Check contentType attribute at adaptation level\n            for (i = 0; i < adaptation.ContentComponent_asArray.length && !found; i++) {\n                if (adaptation.ContentComponent_asArray[i].contentType === type) {\n                    adaptation.type = type;\n                    found = true;\n                }\n            }\n        }\n\n        // Check mimeType attribute at adaptation level\n        if (!found) {\n            if (adaptation.mimeType) {\n                for (i = 0; i < mimeTypes.length && !found; i++) {\n                    if (adaptation.mimeType.indexOf(mimeTypes[i]) !== -1) {\n                        adaptation.type = type;\n                        found = true;\n                    }\n                }\n            }\n        }\n\n        // Check mimeType attribute at representation level\n        if (!found) {\n            for (i = 0; i < adaptation.Representation_asArray.length && !found; i++) {\n                representation = adaptation.Representation_asArray[i];\n                for (j = 0; j < mimeTypes.length && !found; j++) {\n                    if (representation.mimeType.indexOf(mimeTypes[j]) !== -1) {\n                        adaptation.type = type;\n                        found = true;\n                    }\n                }\n            }\n        }\n\n        return found;\n    },\n\n    getIsVideo: function(adaptation) {\n        return this.getIsType(adaptation, \"video\", [\"video\"]);\n    },\n\n    getIsAudio: function(adaptation) {\n        return this.getIsType(adaptation, \"audio\", [\"audio\"]);\n    },\n\n    getIsText: function(adaptation) {\n        return this.getIsType(adaptation, \"text\", [\"vtt\", \"ttml\", \"application/mp4\"]);\n    },\n\n    // ORANGE: added application/ttml+xml+mp4 for Smoothstreaming subtitles (ttml+xml encapsulated in mp4 binary form)\n    getIsTextTrack: function(type) {\n        return (type === \"text/vtt\" || type === \"application/ttml+xml\" || type === \"application/ttml+xml+mp4\" || type === \"application/mp4\");\n    },\n\n    getIsMain: function( /*adaptation*/ ) {\n        \"use strict\";\n        // TODO : Check \"Role\" node.\n        // TODO : Use this somewhere.\n        return false;\n    },\n\n    processAdaptation: function(adaptation) {\n        \"use strict\";\n        if (adaptation.Representation_asArray !== undefined && adaptation.Representation_asArray !== null) {\n            adaptation.Representation_asArray.sort(function(a, b) {\n                return a.bandwidth - b.bandwidth;\n            });\n        }\n\n        return adaptation;\n    },\n\n    getDataForId: function(id, manifest, periodIndex) {\n        \"use strict\";\n        var adaptations = manifest.Period_asArray[periodIndex].AdaptationSet_asArray,\n            i,\n            len;\n\n        for (i = 0, len = adaptations.length; i < len; i += 1) {\n            if (adaptations[i].hasOwnProperty(\"id\") && adaptations[i].id === id) {\n                return adaptations[i];\n            }\n        }\n\n        return null;\n    },\n\n    getDataForIndex: function(index, manifest, periodIndex) {\n        \"use strict\";\n        var adaptations;\n\n        if (manifest && periodIndex >= 0) {\n            adaptations = manifest.Period_asArray[periodIndex].AdaptationSet_asArray;\n\n            if (adaptations && adaptations.length > 0 && !isNaN(index)) {\n                return adaptations[index];\n            }\n        }\n\n        return [];\n    },\n\n    getIndex: function(adaptation, manifest) {\n        var periods = manifest.Period_asArray,\n            adaptations,\n            i,\n            j;\n\n        for (i = 0; i < periods.length; i += 1) {\n            adaptations = periods[i].AdaptationSet_asArray;\n            for (j = 0; j < adaptations.length; j += 1) {\n                if (adaptations[j] === adaptation) {\n                    return j;\n                }\n            }\n        }\n\n        return -1;\n    },\n\n    getDataIndex: function(data, manifest, periodIndex) {\n        \"use strict\";\n\n        var adaptations,\n            i,\n            len;\n\n        if (manifest && periodIndex >= 0) {\n            adaptations = manifest.Period_asArray[periodIndex].AdaptationSet_asArray;\n\n            // ORANGE : compare data with id or string representation to avoid reference error due to manifest refresh\n            if (data.id) {\n                for (i = 0, len = adaptations.length; i < len; i += 1) {\n                    if (adaptations[i].id && adaptations[i].id === data.id) {\n                        return i;\n                    }\n                }\n            } else {\n                var strData = JSON.stringify(data);\n                var strAdapt;\n                for (i = 0, len = adaptations.length; i < len; i += 1) {\n                    strAdapt = JSON.stringify(adaptations[i]);\n                    if (strAdapt === strData) {\n                        return i;\n                    }\n                }\n            }\n        }\n\n        return -1;\n    },\n\n    getVideoData: function(manifest, periodIndex) {\n        \"use strict\";\n        //return null;\n        //------------------------------------\n        var adaptations,\n            i;\n\n        if (!manifest || periodIndex < 0) {\n            return null;\n        }\n\n        adaptations = manifest.Period_asArray[periodIndex].AdaptationSet_asArray;\n\n        if (adaptations.length === 0) {\n            return null;\n        }\n\n        for (i = 0; i < adaptations.length; i += 1) {\n            if (this.getIsVideo(adaptations[i])) {\n                return adaptations[i];\n            }\n        }\n\n        return null;\n    },\n\n    getTextDatas: function(manifest, periodIndex) {\n        \"use strict\";\n        //return null;\n        //------------------------------------\n        var adaptations,\n            datas = [],\n            i;\n\n        if (!manifest || periodIndex < 0) {\n            return datas;\n        }\n\n        adaptations = manifest.Period_asArray[periodIndex].AdaptationSet_asArray;\n\n        if (adaptations.length === 0) {\n            return datas;\n        }\n\n        for (i = 0; i < adaptations.length; i += 1) {\n            if (this.getIsText(adaptations[i])) {\n                datas.push(adaptations[i]);\n            }\n        }\n\n        return datas;\n    },\n\n    getAudioDatas: function(manifest, periodIndex) {\n        \"use strict\";\n        //------------------------------------\n        var adaptations,\n            datas = [],\n            i;\n\n        // return datas;\n\n        if (!manifest || periodIndex < 0) {\n            return datas;\n        }\n\n        adaptations = manifest.Period_asArray[periodIndex].AdaptationSet_asArray;\n\n        if (adaptations.length === 0) {\n            return datas;\n        }\n\n        for (i = 0; i < adaptations.length; i += 1) {\n            if (this.getIsAudio(adaptations[i])) {\n                datas.push(adaptations[i]);\n            }\n        }\n\n        return datas;\n    },\n\n    getSpecificAudioData: function(manifest, periodIndex, language) {\n        \"use strict\";\n        var i,\n            datas;\n\n\n        if (!manifest || periodIndex < 0) {\n            return null;\n        }\n\n        datas = this.getAudioDatas(manifest, periodIndex);\n        if (datas.length === 0) {\n            return null;\n        }\n\n        for (i = 0; i < datas.length; i += 1) {\n            if (datas[i].lang === language) {\n                return this.processAdaptation(datas[i]);\n            }\n        }\n\n        //if the specific language has not been found, return the first one.\n        return this.processAdaptation(datas[0]);\n    },\n\n    getSpecificTextData: function(manifest, periodIndex, language) {\n        \"use strict\";\n        var i,\n            datas;\n\n        if (!manifest || periodIndex < 0) {\n            return null;\n        }\n\n        datas = this.getTextDatas(manifest, periodIndex);\n        if (datas.length === 0) {\n            return null;\n        }\n\n        for (i = 0; i < datas.length; i += 1) {\n            if (datas[i].lang === language) {\n                return this.processAdaptation(datas[i]);\n            }\n        }\n\n        return this.processAdaptation(datas[0]);\n    },\n\n    getCodec: function(adaptation) {\n        \"use strict\";\n        var i = 0,\n            representation,\n            codec = null;\n\n        while ((codec === null) && (i < adaptation.Representation_asArray.length)) {\n            representation = adaptation.Representation_asArray[i];\n            codec = this.getCodecForRepresentation(representation);\n            i++;\n        }\n\n        return codec;\n    },\n\n    getCodecForRepresentation: function(representation) {\n        \"use strict\";\n        if (representation.codecs === null || representation.codecs === \"\") {\n            return null;\n        }\n        return (representation.mimeType + ';codecs=\"' + representation.codecs + '\"');\n    },\n\n    getMimeType: function(data) {\n        \"use strict\";\n        return data.Representation_asArray[0].mimeType;\n    },\n\n    getKID: function(data) {\n        \"use strict\";\n\n        if (!data || !data.hasOwnProperty(\"cenc:default_KID\")) {\n            return null;\n        }\n        return data[\"cenc:default_KID\"];\n    },\n\n    getContentProtectionData: function(data) {\n        \"use strict\";\n        if (!data || !data.hasOwnProperty(\"ContentProtection_asArray\") || data.ContentProtection_asArray.length === 0) {\n            return null;\n        }\n        return data.ContentProtection_asArray;\n    },\n\n    getIsDynamic: function(manifest) {\n        \"use strict\";\n        var isDynamic = false,\n            LIVE_TYPE = \"dynamic\";\n\n        if (manifest && manifest.hasOwnProperty(\"type\")) {\n            isDynamic = (manifest.type === LIVE_TYPE);\n        }\n\n        return isDynamic;\n    },\n\n    getIsDVR: function(manifest) {\n        \"use strict\";\n        var isDynamic = this.getIsDynamic(manifest),\n            containsDVR,\n            isDVR;\n\n        containsDVR = !isNaN(manifest.timeShiftBufferDepth);\n        isDVR = (isDynamic && containsDVR);\n\n        return isDVR;\n    },\n\n    getIsOnDemand: function(manifest) {\n        \"use strict\";\n        var isOnDemand = false;\n\n        if (manifest.profiles && manifest.profiles.length > 0) {\n            isOnDemand = (manifest.profiles.indexOf(\"urn:mpeg:dash:profile:isoff-on-demand:2011\") !== -1);\n        }\n\n        return isOnDemand;\n    },\n\n    getDuration: function(manifest) {\n        var mpdDuration;\n\n        //@mediaPresentationDuration specifies the duration of the entire Media Presentation.\n        //If the attribute is not present, the duration of the Media Presentation is unknown.\n        if (manifest && manifest.hasOwnProperty(\"mediaPresentationDuration\")) {\n            mpdDuration = manifest.mediaPresentationDuration;\n        } else {\n            mpdDuration = Number.POSITIVE_INFINITY;\n        }\n\n        return mpdDuration;\n    },\n\n    getBandwidth: function(representation) {\n        \"use strict\";\n        return representation.bandwidth;\n    },\n\n    getRefreshDelay: function(manifest) {\n        \"use strict\";\n        var delay = NaN,\n            minDelay = 2;\n\n        if (manifest.hasOwnProperty(\"minimumUpdatePeriod\")) {\n            delay = Math.max(parseFloat(manifest.minimumUpdatePeriod), minDelay);\n        }\n\n        return delay;\n    },\n\n    getRepresentationCount: function(adaptation) {\n        \"use strict\";\n        if (adaptation) {\n            return adaptation.Representation_asArray.length;\n        }\n\n        return null;\n    },\n\n    getRepresentationFor: function(index, data) {\n        \"use strict\";\n        return data.Representation_asArray[index];\n    },\n\n    getRepresentationsForAdaptation: function(manifest, adaptation) {\n        var a,\n            representations = [],\n            representation,\n            initialization,\n            segmentInfo,\n            r;\n\n        if (manifest && adaptation) {\n            a = this.processAdaptation(manifest.Period_asArray[adaptation.period.index].AdaptationSet_asArray[adaptation.index]);\n\n            for (var i = 0; i < a.Representation_asArray.length; i += 1) {\n                r = a.Representation_asArray[i];\n                representation = new Dash.vo.Representation();\n                representation.index = i;\n                representation.adaptation = adaptation;\n\n                if (r.hasOwnProperty(\"id\")) {\n                    representation.id = r.id;\n                }\n\n                if (r.hasOwnProperty(\"SegmentBase\")) {\n                    segmentInfo = r.SegmentBase;\n                    representation.segmentInfoType = \"SegmentBase\";\n                } else if (r.hasOwnProperty(\"SegmentList\")) {\n                    segmentInfo = r.SegmentList;\n                    representation.segmentInfoType = \"SegmentList\";\n                    representation.useCalculatedLiveEdgeTime = true;\n                } else if (r.hasOwnProperty(\"SegmentTemplate\")) {\n                    segmentInfo = r.SegmentTemplate;\n\n                    if (segmentInfo.hasOwnProperty(\"SegmentTimeline\")) {\n                        representation.segmentInfoType = \"SegmentTimeline\";\n                    } else {\n                        representation.segmentInfoType = \"SegmentTemplate\";\n                    }\n\n                    if (segmentInfo.hasOwnProperty(\"initialization\")) {\n                        representation.initialization = segmentInfo.initialization.split(\"$Bandwidth$\")\n                            .join(r.bandwidth).split(\"$RepresentationID$\").join(r.id);\n                    }\n                } else {\n                    segmentInfo = r.BaseURL;\n                    representation.segmentInfoType = \"BaseURL\";\n                }\n\n                if (segmentInfo.hasOwnProperty(\"Initialization\")) {\n                    initialization = segmentInfo.Initialization;\n                    if (initialization.hasOwnProperty(\"sourceURL\")) {\n                        representation.initialization = initialization.sourceURL;\n                    } else if (initialization.hasOwnProperty(\"range\")) {\n                        representation.initialization = r.BaseURL;\n                        representation.range = initialization.range;\n                    }\n                } else if (r.hasOwnProperty(\"mimeType\") && this.getIsTextTrack(r.mimeType) && !representation.initialization) {\n                    representation.initialization = r.BaseURL;\n                    representation.range = 0;\n                }\n\n                if (segmentInfo.hasOwnProperty(\"timescale\")) {\n                    representation.timescale = segmentInfo.timescale;\n                }\n                if (segmentInfo.hasOwnProperty(\"duration\")) {\n                    // TODO according to the spec @maxSegmentDuration specifies the maximum duration of any Segment in any Representation in the Media Presentation\n                    // It is also said that for a SegmentTimeline any @d value shall not exceed the value of MPD@maxSegmentDuration, but nothing is said about\n                    // SegmentTemplate @duration attribute. We need to find out if @maxSegmentDuration should be used instead of calculated duration if the the duration\n                    // exceeds @maxSegmentDuration\n                    //representation.segmentDuration = Math.min(segmentInfo.duration / representation.timescale, adaptation.period.mpd.maxSegmentDuration);\n                    representation.segmentDuration = segmentInfo.duration / representation.timescale;\n                }\n                if (segmentInfo.hasOwnProperty(\"startNumber\")) {\n                    representation.startNumber = segmentInfo.startNumber;\n                }\n                if (segmentInfo.hasOwnProperty(\"indexRange\")) {\n                    representation.indexRange = segmentInfo.indexRange;\n                }\n                if (segmentInfo.hasOwnProperty(\"presentationTimeOffset\")) {\n                    representation.presentationTimeOffset = segmentInfo.presentationTimeOffset / representation.timescale;\n                }\n\n                representation.MSETimeOffset = this.timelineConverter.calcMSETimeOffset(representation);\n                representations.push(representation);\n            }\n        }\n\n        return representations;\n    },\n\n    getAdaptationsForPeriod: function(manifest, period) {\n        var p = manifest === null ? null : manifest.Period_asArray[period.index],\n            adaptations = [],\n            adaptationSet;\n\n        if (p) {\n            for (var i = 0; i < p.AdaptationSet_asArray.length; i += 1) {\n                adaptationSet = new Dash.vo.AdaptationSet();\n                adaptationSet.index = i;\n                adaptationSet.period = period;\n                adaptations.push(adaptationSet);\n            }\n        }\n\n        return adaptations;\n    },\n\n    getRegularPeriods: function(manifest, mpd) {\n        var periods = [],\n            isDynamic = this.getIsDynamic(manifest),\n            i,\n            len,\n            p1 = null,\n            p = null,\n            vo1 = null,\n            vo = null;\n\n        for (i = 0, len = manifest.Period_asArray.length; i < len; i += 1) {\n            p = manifest.Period_asArray[i];\n\n            // If the attribute @start is present in the Period, then the\n            // Period is a regular Period and the PeriodStart is equal\n            // to the value of this attribute.\n            if (p.hasOwnProperty(\"start\")) {\n                vo = new Dash.vo.Period();\n                vo.start = p.start;\n            }\n            // If the @start attribute is absent, but the previous Period\n            // element contains a @duration attribute then then this new\n            // Period is also a regular Period. The start time of the new\n            // Period PeriodStart is the sum of the start time of the previous\n            // Period PeriodStart and the value of the attribute @duration\n            // of the previous Period.\n            else if (p1 !== null && p.hasOwnProperty(\"duration\")) {\n                vo = new Dash.vo.Period();\n                vo.start = vo1.start + vo1.duration;\n                vo.duration = p.duration;\n            }\n            // If (i) @start attribute is absent, and (ii) the Period element\n            // is the first in the MPD, and (iii) the MPD@type is 'static',\n            // then the PeriodStart time shall be set to zero.\n            else if (i === 0 && !isDynamic) {\n                vo = new Dash.vo.Period();\n                vo.start = 0;\n            }\n\n            // The Period extends until the PeriodStart of the next Period.\n            // The difference between the PeriodStart time of a Period and\n            // the PeriodStart time of the following Period.\n            if (vo1 !== null && isNaN(vo1.duration)) {\n                vo1.duration = vo.start - vo1.start;\n            }\n\n            if (vo !== null && p.hasOwnProperty(\"id\")) {\n                vo.id = p.id;\n            }\n\n            if (vo !== null && p.hasOwnProperty(\"duration\")) {\n                vo.duration = p.duration;\n            }\n\n            if (vo !== null) {\n                vo.index = i;\n                vo.mpd = mpd;\n                periods.push(vo);\n            }\n\n            p1 = p;\n            p = null;\n            vo1 = vo;\n            vo = null;\n        }\n\n        if (periods.length === 0) {\n            return periods;\n        }\n\n        mpd.checkTime = this.getCheckTime(manifest, periods[0]);\n\n        // The last Period extends until the end of the Media Presentation.\n        // The difference between the PeriodStart time of the last Period\n        // and the mpd duration\n        if (vo1 !== null && isNaN(vo1.duration)) {\n            vo1.duration = this.getEndTimeForLastPeriod(mpd) - vo1.start;\n        }\n\n        return periods;\n    },\n\n    getMpd: function(manifest) {\n        var mpd = new Dash.vo.Mpd();\n\n        if (manifest) {\n            mpd.manifest = manifest;\n\n            if (manifest.hasOwnProperty(\"availabilityStartTime\")) {\n                mpd.availabilityStartTime = new Date(manifest.availabilityStartTime.getTime());\n            } else {\n                mpd.availabilityStartTime = new Date(manifest.mpdLoadedTime.getTime());\n            }\n\n            if (manifest.hasOwnProperty(\"availabilityEndTime\")) {\n                mpd.availabilityEndTime = new Date(manifest.availabilityEndTime.getTime());\n            }\n\n            if (manifest.hasOwnProperty(\"suggestedPresentationDelay\")) {\n                mpd.suggestedPresentationDelay = manifest.suggestedPresentationDelay;\n            }\n\n            if (manifest.hasOwnProperty(\"timeShiftBufferDepth\")) {\n                mpd.timeShiftBufferDepth = manifest.timeShiftBufferDepth;\n            }\n\n            if (manifest.hasOwnProperty(\"maxSegmentDuration\")) {\n                mpd.maxSegmentDuration = manifest.maxSegmentDuration;\n            }\n\n            return mpd;\n        }\n\n        return null;\n    },\n\n    getFetchTime: function(manifest, period) {\n        // FetchTime is defined as the time at which the server processes the request for the MPD from the client.\n        // TODO The client typically should not use the time at which it actually successfully received the MPD, but should\n        // take into account delay due to MPD delivery and processing. The fetch is considered successful fetching\n        // either if the client obtains an updated MPD or the client verifies that the MPD has not been updated since the previous fetching.\n        var fetchTime = this.timelineConverter.calcPresentationTimeFromWallTime(manifest.mpdLoadedTime, period);\n\n        return fetchTime;\n    },\n\n    getCheckTime: function(manifest, period) {\n        var checkTime = NaN;\n\n        // If the MPD@minimumUpdatePeriod attribute in the client is provided, then the check time is defined as the\n        // sum of the fetch time of this operating MPD and the value of this attribute,\n        // i.e. CheckTime = FetchTime + MPD@minimumUpdatePeriod.\n        if (manifest.hasOwnProperty(\"minimumUpdatePeriod\")) {\n            checkTime = this.getFetchTime(manifest, period) + manifest.minimumUpdatePeriod;\n        }\n\n        return checkTime;\n    },\n\n    getEndTimeForLastPeriod: function(mpd) {\n        var periodEnd;\n\n        // if the MPD@mediaPresentationDuration attribute is present, then PeriodEndTime is defined as the end time of the Media Presentation.\n        // if the MPD@mediaPresentationDuration attribute is not present, then PeriodEndTime is defined as FetchTime + MPD@minimumUpdatePeriod\n\n        if (mpd.manifest.mediaPresentationDuration) {\n            periodEnd = mpd.manifest.mediaPresentationDuration;\n        } else if (!isNaN(mpd.checkTime)) {\n            // in this case the Period End Time should match CheckTime\n            periodEnd = mpd.checkTime;\n        } else {\n            return new Error(\"Must have @mediaPresentationDuration or @minimumUpdatePeriod on MPD or an explicit @duration on the last period.\");\n        }\n\n        return periodEnd;\n    },\n\n    getEventsForPeriod: function(manifest, period) {\n        var periodArray = manifest === null ? null : manifest.Period_asArray,\n            eventStreams = periodArray === null ? null : periodArray[period.index].EventStream_asArray,\n            events = [];\n\n        if (eventStreams) {\n            for (var i = 0; i < eventStreams.length; i += 1) {\n                var eventStream = new Dash.vo.EventStream();\n                eventStream.period = period;\n                eventStream.timescale = 1;\n\n                if (eventStreams[i].hasOwnProperty(\"schemeIdUri\")) {\n                    eventStream.schemeIdUri = eventStreams[i].schemeIdUri;\n                } else {\n                    throw \"Invalid EventStream. SchemeIdUri has to be set\";\n                }\n                if (eventStreams[i].hasOwnProperty(\"timescale\")) {\n                    eventStream.timescale = eventStreams[i].timescale;\n                }\n                if (eventStreams[i].hasOwnProperty(\"value\")) {\n                    eventStream.value = eventStreams[i].value;\n                }\n                for (var j = 0; j < eventStreams[i].Event_asArray.length; j += 1) {\n                    var event = new Dash.vo.Event();\n                    event.presentationTime = 0;\n                    event.eventStream = eventStream;\n\n                    if (eventStreams[i].Event_asArray[j].hasOwnProperty(\"presentationTime\")) {\n                        event.presentationTime = eventStreams[i].Event_asArray[j].presentationTime;\n                    }\n                    if (eventStreams[i].Event_asArray[j].hasOwnProperty(\"duration\")) {\n                        event.duration = eventStreams[i].Event_asArray[j].duration;\n                    }\n                    if (eventStreams[i].Event_asArray[j].hasOwnProperty(\"id\")) {\n                        event.id = eventStreams[i].Event_asArray[j].id;\n                    }\n                    events.push(event);\n                }\n            }\n        }\n\n        return events;\n    },\n\n    getEventStreamForAdaptationSet: function(data) {\n\n        var eventStreams = [],\n            inbandStreams;\n\n        if (data) {\n            inbandStreams = data.InbandEventStream_asArray;\n\n            if (inbandStreams) {\n                for (var i = 0; i < inbandStreams.length; i += 1) {\n                    var eventStream = new Dash.vo.EventStream();\n                    eventStream.timescale = 1;\n\n                    if (inbandStreams[i].hasOwnProperty(\"schemeIdUri\")) {\n                        eventStream.schemeIdUri = inbandStreams[i].schemeIdUri;\n                    } else {\n                        throw \"Invalid EventStream. SchemeIdUri has to be set\";\n                    }\n                    if (inbandStreams[i].hasOwnProperty(\"timescale\")) {\n                        eventStream.timescale = inbandStreams[i].timescale;\n                    }\n                    if (inbandStreams[i].hasOwnProperty(\"value\")) {\n                        eventStream.value = inbandStreams[i].value;\n                    }\n                    eventStreams.push(eventStream);\n                }\n            }\n        }\n\n        return eventStreams;\n    },\n\n    getEventStreamForRepresentation: function(data, representation) {\n\n        var eventStreams = [],\n            inbandStreams;\n\n        if (data && representation) {\n\n            inbandStreams = data.Representation_asArray[representation.index].InbandEventStream_asArray;\n\n            if (inbandStreams) {\n                for (var i = 0; i < inbandStreams.length; i++) {\n                    var eventStream = new Dash.vo.EventStream();\n                    eventStream.timescale = 1;\n                    eventStream.representation = representation;\n\n                    if (inbandStreams[i].hasOwnProperty(\"schemeIdUri\")) {\n                        eventStream.schemeIdUri = inbandStreams[i].schemeIdUri;\n                    } else {\n                        throw \"Invalid EventStream. SchemeIdUri has to be set\";\n                    }\n                    if (inbandStreams[i].hasOwnProperty(\"timescale\")) {\n                        eventStream.timescale = inbandStreams[i].timescale;\n                    }\n                    if (inbandStreams[i].hasOwnProperty(\"value\")) {\n                        eventStream.value = inbandStreams[i].value;\n                    }\n                    eventStreams.push(eventStream);\n                }\n            }\n        }\n\n        return eventStreams;\n\n    },\n\n    getRepresentationBandwidth: function(adaptation, index) {\n        return this.getBandwidth(this.getRepresentationFor(index, adaptation));\n    }\n\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nDash.dependencies.DashMetricsExtensions = function() {\n    \"use strict\";\n    var findRepresentationIndexInPeriodArray = function(periodArray, representationId) {\n            var period,\n                adaptationSet,\n                adaptationSetArray,\n                representation,\n                representationArray,\n                periodArrayIndex,\n                adaptationSetArrayIndex,\n                representationArrayIndex;\n\n            for (periodArrayIndex = 0; periodArrayIndex < periodArray.length; periodArrayIndex = periodArrayIndex + 1) {\n                period = periodArray[periodArrayIndex];\n                adaptationSetArray = period.AdaptationSet_asArray;\n                for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex < adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) {\n                    adaptationSet = adaptationSetArray[adaptationSetArrayIndex];\n                    representationArray = adaptationSet.Representation_asArray;\n                    for (representationArrayIndex = 0; representationArrayIndex < representationArray.length; representationArrayIndex = representationArrayIndex + 1) {\n                        representation = representationArray[representationArrayIndex];\n                        if (representationId === representation.id) {\n                            return representationArrayIndex;\n                        }\n                    }\n                }\n            }\n\n            return -1;\n        },\n\n        findRepresentionInPeriodArray = function(periodArray, representationId) {\n            var period,\n                adaptationSet,\n                adaptationSetArray,\n                representation,\n                representationArray,\n                periodArrayIndex,\n                adaptationSetArrayIndex,\n                representationArrayIndex;\n\n            for (periodArrayIndex = 0; periodArrayIndex < periodArray.length; periodArrayIndex = periodArrayIndex + 1) {\n                period = periodArray[periodArrayIndex];\n                adaptationSetArray = period.AdaptationSet_asArray;\n                for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex < adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) {\n                    adaptationSet = adaptationSetArray[adaptationSetArrayIndex];\n                    representationArray = adaptationSet.Representation_asArray;\n                    for (representationArrayIndex = 0; representationArrayIndex < representationArray.length; representationArrayIndex = representationArrayIndex + 1) {\n                        representation = representationArray[representationArrayIndex];\n                        if (representationId === representation.id) {\n                            return representation;\n                        }\n                    }\n                }\n            }\n\n            return null;\n        },\n\n        adaptationIsType = function(adaptation, bufferType) {\n            var found = false;\n\n            // TODO : HACK ATTACK\n            // Below we call getIsVideo and getIsAudio and then check the adaptation set for a 'type' property.\n            // getIsVideo and getIsAudio are adding this 'type' property and SHOULD NOT BE.\n            // This method expects getIsVideo and getIsAudio to be sync, but they are async (returns a promise).\n            // This is a bad workaround!\n            // The metrics extensions should have every method use promises.\n\n            if (bufferType === \"video\") {\n                //found = this.manifestExt.getIsVideo(adaptation);\n                this.manifestExt.getIsVideo(adaptation);\n                if (adaptation.type === \"video\") {\n                    found = true;\n                }\n            } else if (bufferType === \"audio\") {\n                //found = this.manifestExt.getIsAudio(adaptation); // TODO : Have to be sure it's the *active* audio track.\n                this.manifestExt.getIsAudio(adaptation);\n                if (adaptation.type === \"audio\") {\n                    found = true;\n                }\n            } else {\n                found = false;\n            }\n\n            return found;\n        },\n\n        findMaxBufferIndex = function(periodArray, bufferType) {\n            var period,\n                adaptationSet,\n                adaptationSetArray,\n                representationArray,\n                periodArrayIndex,\n                adaptationSetArrayIndex;\n\n            for (periodArrayIndex = 0; periodArrayIndex < periodArray.length; periodArrayIndex = periodArrayIndex + 1) {\n                period = periodArray[periodArrayIndex];\n                adaptationSetArray = period.AdaptationSet_asArray;\n                for (adaptationSetArrayIndex = 0; adaptationSetArrayIndex < adaptationSetArray.length; adaptationSetArrayIndex = adaptationSetArrayIndex + 1) {\n                    adaptationSet = adaptationSetArray[adaptationSetArrayIndex];\n                    representationArray = adaptationSet.Representation_asArray;\n                    if (adaptationIsType.call(this, adaptationSet, bufferType)) {\n                        return representationArray.length;\n                    }\n                }\n            }\n\n            return -1;\n        },\n\n        getBandwidthForRepresentation = function(representationId) {\n            var self = this,\n                manifest = self.manifestModel.getValue(),\n                representation,\n                periodArray = manifest === null ? null : manifest.Period_asArray;\n\n            if (periodArray) {\n                representation = findRepresentionInPeriodArray.call(self, periodArray, representationId);\n\n                if (representation === null) {\n                    return null;\n                }\n\n                return representation.bandwidth;\n            }\n\n            return null;\n        },\n\n        getIndexForRepresentation = function(representationId) {\n            var self = this,\n                manifest = self.manifestModel.getValue(),\n                representationIndex,\n                periodArray = manifest === null ? null : manifest.Period_asArray;\n\n            if (periodArray) {\n                representationIndex = findRepresentationIndexInPeriodArray.call(self, periodArray, representationId);\n                return representationIndex;\n            }\n\n            return null;\n        },\n\n        getMaxIndexForBufferType = function(bufferType) {\n            var self = this,\n                manifest = self.manifestModel.getValue(),\n                maxIndex,\n                periodArray = manifest === null ? null : manifest.Period_asArray;\n\n            if (periodArray) {\n                maxIndex = findMaxBufferIndex.call(this, periodArray, bufferType);\n                return maxIndex;\n            }\n\n            return null;\n        },\n\n        getCurrentRepresentationSwitch = function(metrics) {\n            if (metrics === null) {\n                return null;\n            }\n\n            var repSwitch = metrics.RepSwitchList,\n                repSwitchLength,\n                repSwitchLastIndex,\n                currentRepSwitch;\n\n            if (repSwitch === null || repSwitch.length <= 0) {\n                return null;\n            }\n\n            repSwitchLength = repSwitch.length;\n            repSwitchLastIndex = repSwitchLength - 1;\n\n            currentRepSwitch = repSwitch[repSwitchLastIndex];\n            return currentRepSwitch;\n        },\n\n        getCurrentBufferLevel = function(metrics) {\n            if (metrics === null) {\n                return null;\n            }\n\n            var bufferLevel = metrics.BufferLevel,\n                bufferLevelLength,\n                bufferLevelLastIndex,\n                currentBufferLevel;\n\n            if (bufferLevel === null || bufferLevel.length <= 0) {\n                return null;\n            }\n\n            bufferLevelLength = bufferLevel.length;\n            bufferLevelLastIndex = bufferLevelLength - 1;\n\n            currentBufferLevel = bufferLevel[bufferLevelLastIndex];\n            return currentBufferLevel;\n        },\n\n        getCurrentHttpRequest = function(metrics) {\n            if (metrics === null) {\n                return null;\n            }\n\n            var httpList = metrics.HttpList,\n                httpListLength,\n                httpListLastIndex,\n                currentHttpList = null;\n\n            if (httpList === null || httpList.length <= 0) {\n                return null;\n            }\n\n            httpListLength = httpList.length;\n            httpListLastIndex = httpListLength - 1;\n\n            // ORANGE: if only 1 item, then was ignored\n            //while (httpListLastIndex > 0) {\n            while (httpListLastIndex >= 0) {\n                if (httpList[httpListLastIndex].responsecode !== null) {\n                    currentHttpList = httpList[httpListLastIndex];\n                    break;\n                }\n                httpListLastIndex -= 1;\n            }\n            return currentHttpList;\n        },\n\n        getHttpRequests = function(metrics) {\n            if (metrics === null) {\n                return [];\n            }\n\n            return !!metrics.HttpList ? metrics.HttpList : [];\n        },\n\n        getCurrentDroppedFrames = function(metrics) {\n            if (metrics === null) {\n                return null;\n            }\n\n            var droppedFrames = metrics.DroppedFrames,\n                droppedFramesLength,\n                droppedFramesLastIndex,\n                currentDroppedFrames;\n\n            if (droppedFrames === null || droppedFrames.length <= 0) {\n                return null;\n            }\n\n            droppedFramesLength = droppedFrames.length;\n            droppedFramesLastIndex = droppedFramesLength - 1;\n            currentDroppedFrames = droppedFrames[droppedFramesLastIndex];\n\n            return currentDroppedFrames;\n        },\n\n        getCurrentPlaybackQuality = function(metrics) {\n\n            if (metrics === null) {\n                return null;\n            }\n\n            var playbackQuality = metrics.PlaybackQuality;\n\n            if (playbackQuality === null || playbackQuality.length <= 0) {\n                return null;\n            }\n\n            return playbackQuality[playbackQuality.length-1];\n        },\n\n        getCurrentDVRInfo = function(metrics) {\n\n            if (metrics === null) {\n                return null;\n            }\n\n            var dvrInfo = metrics.DVRInfo,\n                dvrInfoLastIndex,\n                curentDVRInfo = null;\n\n            if (dvrInfo === null || dvrInfo.length <= 0) {\n                return null;\n            }\n\n            dvrInfoLastIndex = dvrInfo.length - 1;\n            curentDVRInfo = dvrInfo[dvrInfoLastIndex];\n\n            return curentDVRInfo;\n        },\n\n        getCurrentManifestUpdate = function(metrics) {\n            if (metrics === null) {\n                return null;\n            }\n\n            var manifestUpdate = metrics.ManifestUpdate,\n                ln,\n                lastIdx,\n                currentManifestUpdate;\n\n            if (manifestUpdate === null || manifestUpdate.length <= 0) {\n                return null;\n            }\n\n            ln = manifestUpdate.length;\n            lastIdx = ln - 1;\n\n            currentManifestUpdate = manifestUpdate[lastIdx];\n\n            return currentManifestUpdate;\n        };\n\n    return {\n        manifestModel: undefined,\n        manifestExt: undefined,\n        getBandwidthForRepresentation: getBandwidthForRepresentation,\n        getIndexForRepresentation: getIndexForRepresentation,\n        getMaxIndexForBufferType: getMaxIndexForBufferType,\n        getCurrentRepresentationSwitch: getCurrentRepresentationSwitch,\n        getCurrentBufferLevel: getCurrentBufferLevel,\n        getCurrentHttpRequest: getCurrentHttpRequest,\n        getHttpRequests: getHttpRequests,\n        getCurrentDroppedFrames: getCurrentDroppedFrames,\n        getCurrentPlaybackQuality: getCurrentPlaybackQuality,\n        getCurrentDVRInfo: getCurrentDVRInfo,\n        getCurrentManifestUpdate: getCurrentManifestUpdate\n    };\n};\n\nDash.dependencies.DashMetricsExtensions.prototype = {\n    constructor: Dash.dependencies.DashMetricsExtensions\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nDash.dependencies.DashParser = function () {\n    \"use strict\";\n\n    var SECONDS_IN_YEAR = 365 * 24 * 60 * 60,\n        SECONDS_IN_MONTH = 30 * 24 * 60 * 60, // not precise!\n        SECONDS_IN_DAY = 24 * 60 * 60,\n        SECONDS_IN_HOUR = 60 * 60,\n        SECONDS_IN_MIN = 60,\n        MINUTES_IN_HOUR = 60,\n        MILLISECONDS_IN_SECONDS = 1000,\n        durationRegex = /^P(([\\d.]*)Y)?(([\\d.]*)M)?(([\\d.]*)D)?T?(([\\d.]*)H)?(([\\d.]*)M)?(([\\d.]*)S)?/,\n        datetimeRegex = /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2})(?::([0-9]*)(\\.[0-9]*)?)?(?:([+-])([0-9]{2})([0-9]{2}))?/,\n        numericRegex = /^[-+]?[0-9]+[.]?[0-9]*([eE][-+]?[0-9]+)?$/,\n        matchers = [\n            {\n                type: \"duration\",\n                test: function (str) {\n                    return durationRegex.test(str);\n                },\n                converter: function (str) {\n                    //str = \"P10Y10M10DT10H10M10.1S\";\n                    var match = durationRegex.exec(str);\n                    return (parseFloat(match[2] || 0) * SECONDS_IN_YEAR +\n                            parseFloat(match[4] || 0) * SECONDS_IN_MONTH +\n                            parseFloat(match[6] || 0) * SECONDS_IN_DAY +\n                            parseFloat(match[8] || 0) * SECONDS_IN_HOUR +\n                            parseFloat(match[10] || 0) * SECONDS_IN_MIN +\n                            parseFloat(match[12] || 0));\n                }\n            },\n            {\n                type: \"datetime\",\n                test: function (str) {\n                    return datetimeRegex.test(str);\n                },\n                converter: function (str) {\n                    var match = datetimeRegex.exec(str),\n                        utcDate;\n                    // If the string does not contain a timezone offset different browsers can interpret it either\n                    // as UTC or as a local time so we have to parse the string manually to normalize the given date value for\n                    // all browsers\n                    utcDate = Date.UTC(\n                        parseInt(match[1], 10),\n                        parseInt(match[2], 10)-1, // months start from zero\n                        parseInt(match[3], 10),\n                        parseInt(match[4], 10),\n                        parseInt(match[5], 10),\n                        (match[6] && parseInt(match[6], 10) || 0),\n                        (match[7] && parseFloat(match[7]) * MILLISECONDS_IN_SECONDS) || 0);\n                    // If the date has timezone offset take it into account as well\n                    if (match[9] && match[10]) {\n                        var timezoneOffset = parseInt(match[9], 10) * MINUTES_IN_HOUR + parseInt(match[10], 10);\n                        utcDate += (match[8] === '+' ? -1 : +1) * timezoneOffset * SECONDS_IN_MIN * MILLISECONDS_IN_SECONDS;\n                    }\n\n                    return new Date(utcDate);\n                }\n            },\n            {\n                type: \"numeric\",\n                test: function (str) {\n                    return numericRegex.test(str);\n                },\n                converter: function (str) {\n                    return parseFloat(str);\n                }\n            }\n        ],\n\n        getCommonValuesMap = function () {\n            var adaptationSet,\n                representation,\n                subRepresentation,\n                common;\n\n            common = [\n                {\n                    name: 'profiles',\n                    merge: false\n                },\n                {\n                    name: 'width',\n                    merge: false\n                },\n                {\n                    name: 'height',\n                    merge: false\n                },\n                {\n                    name: 'sar',\n                    merge: false\n                },\n                {\n                    name: 'frameRate',\n                    merge: false\n                },\n                {\n                    name: 'audioSamplingRate',\n                    merge: false\n                },\n                {\n                    name: 'mimeType',\n                    merge: false\n                },\n                {\n                    name: 'segmentProfiles',\n                    merge: false\n                },\n                {\n                    name: 'codecs',\n                    merge: false\n                },\n                {\n                    name: 'maximumSAPPeriod',\n                    merge: false\n                },\n                {\n                    name: 'startsWithSap',\n                    merge: false\n                },\n                {\n                    name: 'maxPlayoutRate',\n                    merge: false\n                },\n                {\n                    name: 'codingDependency',\n                    merge: false\n                },\n                {\n                    name: 'scanType',\n                    merge: false\n                },\n                {\n                    name: 'FramePacking',\n                    merge: true\n                },\n                {\n                    name: 'AudioChannelConfiguration',\n                    merge: true\n                },\n                {\n                    name: 'ContentProtection',\n                    merge: true\n                }\n            ];\n\n            adaptationSet = {};\n            adaptationSet.name = \"AdaptationSet\";\n            adaptationSet.isRoot = false;\n            adaptationSet.isArray = true;\n            adaptationSet.parent = null;\n            adaptationSet.children = [];\n            adaptationSet.properties = common;\n\n            representation = {};\n            representation.name = \"Representation\";\n            representation.isRoot = false;\n            representation.isArray = true;\n            representation.parent = adaptationSet;\n            representation.children = [];\n            representation.properties = common;\n            adaptationSet.children.push(representation);\n\n            subRepresentation = {};\n            subRepresentation.name = \"SubRepresentation\";\n            subRepresentation.isRoot = false;\n            subRepresentation.isArray = true;\n            subRepresentation.parent = representation;\n            subRepresentation.children = [];\n            subRepresentation.properties = common;\n            representation.children.push(subRepresentation);\n\n            return adaptationSet;\n        },\n\n        getSegmentValuesMap = function () {\n            var period,\n                adaptationSet,\n                representation,\n                common;\n\n            common = [\n                {\n                    name: 'SegmentBase',\n                    merge: true\n                },\n                {\n                    name: 'SegmentTemplate',\n                    merge: true\n                },\n                {\n                    name: 'SegmentList',\n                    merge: true\n                }\n            ];\n\n            period = {};\n            period.name = \"Period\";\n            period.isRoot = false;\n            period.isArray = true;\n            period.parent = null;\n            period.children = [];\n            period.properties = common;\n\n            adaptationSet = {};\n            adaptationSet.name = \"AdaptationSet\";\n            adaptationSet.isRoot = false;\n            adaptationSet.isArray = true;\n            adaptationSet.parent = period;\n            adaptationSet.children = [];\n            adaptationSet.properties = common;\n            period.children.push(adaptationSet);\n\n            representation = {};\n            representation.name = \"Representation\";\n            representation.isRoot = false;\n            representation.isArray = true;\n            representation.parent = adaptationSet;\n            representation.children = [];\n            representation.properties = common;\n            adaptationSet.children.push(representation);\n\n            return period;\n        },\n\n        getBaseUrlValuesMap = function () {\n            var mpd,\n                period,\n                adaptationSet,\n                representation,\n                common;\n\n            common = [\n                {\n                    name: 'BaseURL',\n                    merge: true,\n                    mergeFunction: function (parentValue, childValue) {\n                        var mergedValue;\n\n                        // child is absolute, don't merge\n                        if (childValue.indexOf(\"http://\") === 0) {\n                            mergedValue = childValue;\n                        } else {\n                            mergedValue = parentValue + childValue;\n                        }\n\n                        return mergedValue;\n                    }\n                }\n            ];\n\n            mpd = {};\n            mpd.name = \"mpd\";\n            mpd.isRoot = true;\n            mpd.isArray = true;\n            mpd.parent = null;\n            mpd.children = [];\n            mpd.properties = common;\n\n            period = {};\n            period.name = \"Period\";\n            period.isRoot = false;\n            period.isArray = true;\n            period.parent = null;\n            period.children = [];\n            period.properties = common;\n            mpd.children.push(period);\n\n            adaptationSet = {};\n            adaptationSet.name = \"AdaptationSet\";\n            adaptationSet.isRoot = false;\n            adaptationSet.isArray = true;\n            adaptationSet.parent = period;\n            adaptationSet.children = [];\n            adaptationSet.properties = common;\n            period.children.push(adaptationSet);\n\n            representation = {};\n            representation.name = \"Representation\";\n            representation.isRoot = false;\n            representation.isArray = true;\n            representation.parent = adaptationSet;\n            representation.children = [];\n            representation.properties = common;\n            adaptationSet.children.push(representation);\n\n            return mpd;\n        },\n\n        getDashMap = function () {\n            var result = [];\n\n            result.push(getCommonValuesMap());\n            result.push(getSegmentValuesMap());\n            result.push(getBaseUrlValuesMap());\n\n            return result;\n        },\n\n        internalParse = function (data, baseUrl) {\n            //this.debug.log(\"Doing parse.\");\n\n            var manifest,\n                converter = new X2JS(matchers, '', true),\n                iron = new ObjectIron(getDashMap()),\n                start = new Date(),\n                json = null,\n                ironed = null;\n\n            try {\n                //this.debug.log(\"Converting from XML.\");\n                manifest = converter.xml_str2json(data);\n                json = new Date();\n\n                if (!manifest.hasOwnProperty(\"BaseURL\")) {\n                    //this.debug.log(\"Setting baseURL: \" + baseUrl);\n                    manifest.BaseURL = baseUrl;\n                } else {\n                    // Setting manifest's BaseURL to the first BaseURL\n                    manifest.BaseURL = manifest.BaseURL_asArray[0];\n\n                    if (manifest.BaseURL.toString().indexOf(\"http\") !== 0) {\n                        manifest.BaseURL = baseUrl + manifest.BaseURL;\n                    }\n                }\n\n                //this.debug.log(\"Flatten manifest properties.\");\n                iron.run(manifest);\n                ironed = new Date();\n\n                this.debug.log(\"Parsing complete: ( xml2json: \" + (json.getTime() - start.getTime()) + \"ms, objectiron: \" + (ironed.getTime() - json.getTime()) + \"ms, total: \" + ((ironed.getTime() - start.getTime()) / 1000) + \"s)\");\n \n            } catch (e) {\n                return Q.reject(null);\n            }\n\n            return Q.when(manifest);\n        };\n\n    return {\n        debug: undefined,\n        parse: internalParse\n    };\n};\n\nDash.dependencies.DashParser.prototype = {\n    constructor: Dash.dependencies.DashParser\n};\n","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nDash.dependencies.FragmentExtensions = function () {\n    \"use strict\";\n\n    var parseTFDT = function (ab) {\n            var d = new DataView(ab),\n                pos = 0,\n                base_media_decode_time,\n                version,\n                size,\n                type,\n                i,\n                c;\n\n            while (type !== \"tfdt\" && pos < d.byteLength) {\n                size = d.getUint32(pos); // subtract 8 for including the size and type\n                pos += 4;\n\n                type = \"\";\n                for (i = 0; i < 4; i += 1) {\n                    c = d.getInt8(pos);\n                    type += String.fromCharCode(c);\n                    pos += 1;\n                }\n\n                if (type !== \"moof\" && type !== \"traf\" && type !== \"tfdt\") {\n                    pos += size - 8;\n                }\n            }\n\n            if (pos === d.byteLength) {\n                throw \"Error finding live offset.\";\n            }\n\n            version = d.getUint8(pos);\n\n            this.debug.log(\"position: \" + pos);\n\n            if (version === 0) {\n                pos += 4;\n                base_media_decode_time = d.getUint32(pos, false);\n            } else {\n                pos += size - 16;\n                base_media_decode_time = utils.Math.to64BitNumber(d.getUint32(pos + 4, false), d.getUint32(pos, false));\n            }\n\n            return {\n                'version' : version,\n                'base_media_decode_time' : base_media_decode_time\n            };\n        },\n\n        parseSIDX = function (ab) {\n            var d = new DataView(ab),\n                pos = 0,\n                version,\n                timescale,\n                earliest_presentation_time,\n                i,\n                type,\n                size,\n                charCode;\n\n            while (type !== \"sidx\" && pos < d.byteLength) {\n                size = d.getUint32(pos); // subtract 8 for including the size and type\n                pos += 4;\n\n                type = \"\";\n                for (i = 0; i < 4; i += 1) {\n                    charCode = d.getInt8(pos);\n                    type += String.fromCharCode(charCode);\n                    pos += 1;\n                }\n\n                if (type !== \"moof\" && type !== \"traf\" && type !== \"sidx\") {\n                    pos += size - 8;\n                } else if (type === \"sidx\") {\n                    // reset the position to the beginning of the box...\n                    // if we do not reset the position, the evaluation\n                    // of sidxEnd to ab.byteLength will fail.\n                    pos -= 8;\n                }\n            }\n\n            version = d.getUint8(pos + 8);\n            pos += 12;\n\n            // skipped reference_ID(32)\n            timescale = d.getUint32(pos + 4, false);\n            pos += 8;\n\n            if (version === 0) {\n                earliest_presentation_time = d.getUint32(pos, false);\n            } else {\n                earliest_presentation_time = utils.Math.to64BitNumber(d.getUint32(pos + 4, false), d.getUint32(pos, false));\n            }\n\n            return Q.when({\n                'earliestPresentationTime' : earliest_presentation_time,\n                'timescale' : timescale\n            });\n        },\n\n        loadFragment = function (media) {\n            var deferred = Q.defer(),\n                request = new XMLHttpRequest(),\n                url,\n                loaded = false,\n                errorStr,\n                parsed;\n\n            url = media;\n\n            request.onloadend = function () {\n                if (!loaded) {\n                    errorStr = \"Error loading fragment: \" + url;\n                    deferred.reject(errorStr);\n                }\n            };\n\n            request.onload = function () {\n                loaded = true;\n                parsed = parseTFDT(request.response);\n                deferred.resolve(parsed);\n            };\n\n            request.onerror = function () {\n                errorStr = \"Error loading fragment: \" + url;\n                deferred.reject(errorStr);\n            };\n\n            request.open(\"GET\", url);\n            request.responseType = \"arraybuffer\";\n            request.send(null);\n\n            return deferred.promise;\n        };\n\n    return {\n        debug : undefined,\n        loadFragment : loadFragment,\n        parseTFDT : parseTFDT,\n        parseSIDX : parseSIDX\n    };\n};\n\nDash.dependencies.FragmentExtensions.prototype = {\n    constructor: Dash.dependencies.FragmentExtensions\n};\n","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nDash.dependencies.TimelineConverter = function() {\n    \"use strict\";\n\n    var clientServerTimeShift = 0,\n\n        calcAvailabilityTimeFromPresentationTime = function(presentationTime, mpd, isDynamic, calculateEnd) {\n            var availabilityTime = NaN;\n\n            if (calculateEnd) {\n                //@timeShiftBufferDepth specifies the duration of the time shifting buffer that is guaranteed\n                // to be available for a Media Presentation with type 'dynamic'.\n                // When not present, the value is infinite.\n                if (isDynamic && (mpd.timeShiftBufferDepth !== Number.POSITIVE_INFINITY)) {\n                    availabilityTime = new Date(mpd.availabilityStartTime.getTime() + ((presentationTime + mpd.timeShiftBufferDepth) * 1000));\n                } else {\n                    availabilityTime = mpd.availabilityEndTime;\n                }\n            } else {\n                if (isDynamic) {\n                    availabilityTime = new Date(mpd.availabilityStartTime.getTime() + (presentationTime * 1000));\n                } else {\n                    // in static mpd, all segments are available at the same time\n                    availabilityTime = mpd.availabilityStartTime;\n                }\n            }\n\n            return availabilityTime;\n        },\n\n        calcAvailabilityStartTimeFromPresentationTime = function(presentationTime, mpd, isDynamic) {\n            return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic);\n        },\n\n        calcAvailabilityEndTimeFromPresentationTime = function(presentationTime, mpd, isDynamic) {\n            return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic, true);\n        },\n\n        calcPresentationStartTime = function(period) {\n            var presentationStartTime,\n                isDynamic = period.mpd.manifest.type === \"dynamic\",\n                //ORANGE: fix bug on not updating URIFragmentDataVO\n                startTimeOffset = parseInt(this.uriQueryFragModel.getURIFragmentData().s, 10);\n\n            if (isDynamic) {\n\n                if (!isNaN(startTimeOffset) && startTimeOffset > 1262304000) {\n\n                    presentationStartTime = startTimeOffset - (period.mpd.availabilityStartTime.getTime() / 1000);\n\n                    if (presentationStartTime > period.liveEdge ||\n                        presentationStartTime < (period.liveEdge - period.mpd.timeShiftBufferDepth)) {\n\n                        presentationStartTime = null;\n                    }\n                }\n                presentationStartTime = presentationStartTime || period.liveEdge;\n\n            } else {\n                if (!isNaN(startTimeOffset) && startTimeOffset < period.duration && startTimeOffset >= 0) {\n                    presentationStartTime = startTimeOffset;\n                } else {\n                    presentationStartTime = period.start;\n                }\n            }\n\n            return presentationStartTime;\n        },\n\n        calcPresentationTimeFromWallTime = function(wallTime, period) {\n            return ((wallTime.getTime() - period.mpd.availabilityStartTime.getTime()) / 1000);\n        },\n\n        calcPresentationTimeFromMediaTime = function(mediaTime, representation) {\n            var presentationOffset = representation.presentationTimeOffset;\n\n            return mediaTime - presentationOffset;\n        },\n\n        calcMediaTimeFromPresentationTime = function(presentationTime, representation) {\n            var presentationOffset = representation.presentationTimeOffset;\n\n            return (presentationOffset + presentationTime);\n        },\n\n        calcWallTimeForSegment = function(segment, isDynamic) {\n            var suggestedPresentationDelay,\n                displayStartTime,\n                wallTime;\n\n            if (isDynamic) {\n                suggestedPresentationDelay = segment.representation.adaptation.period.mpd.suggestedPresentationDelay;\n                displayStartTime = segment.presentationStartTime + suggestedPresentationDelay;\n                wallTime = new Date(segment.availabilityStartTime.getTime() + (displayStartTime * 1000));\n            }\n\n            return wallTime;\n        },\n\n        calcActualPresentationTime = function(representation, currentTime, isDynamic) {\n            var self = this,\n                //periodStart = representation.adaptation.period.start,\n                availabilityWindow = self.calcSegmentAvailabilityRange(representation, isDynamic),\n                actualTime;\n\n            // ORANGE: confusion to resolve between availabilityWindow.start and periodStart.\n            // (in MSS case, periodStart is set to availabilityWindow.start)\n            //if ((currentTime >= (availabilityWindow.start + periodStart)) && (currentTime <= (availabilityWindow.end + periodStart))) {\n            if ((currentTime >= (availabilityWindow.start)) && (currentTime <= (availabilityWindow.end))) {\n                return currentTime;\n            }\n\n            actualTime = Math.max(availabilityWindow.end - representation.adaptation.period.mpd.manifest.minBufferTime * 2, availabilityWindow.start);\n\n            return actualTime;\n        },\n\n        calcSegmentAvailabilityRange = function(representation, isDynamic) {\n            var duration = representation.segmentDuration,\n                start = 0,\n                end = representation.adaptation.period.duration,\n                range = {\n                    start: start,\n                    end: end\n                },\n                checkTime,\n                now;\n\n            if (!isDynamic) {\n                return range;\n            }\n\n            if ((!representation.adaptation.period.mpd.isClientServerTimeSyncCompleted || isNaN(duration)) && representation.segmentAvailabilityRange) {\n                return representation.segmentAvailabilityRange;\n            }\n\n            checkTime = representation.adaptation.period.mpd.checkTime;\n            now = calcPresentationTimeFromWallTime(new Date((new Date().getTime()) + clientServerTimeShift), representation.adaptation.period);\n            //the Media Segment list is further restricted by the CheckTime together with the MPD attribute\n            // MPD@timeShiftBufferDepth such that only Media Segments for which the sum of the start time of the\n            // Media Segment and the Period start time falls in the interval [NOW- MPD@timeShiftBufferDepth - @duration, min(CheckTime, NOW)] are included.\n            start = Math.max((now - representation.adaptation.period.mpd.timeShiftBufferDepth), 0);\n            checkTime += (clientServerTimeShift / 1000);\n            end = isNaN(checkTime) ? now : Math.min(checkTime, now);\n            range = {\n                start: start,\n                end: end\n            };\n\n            return range;\n        },\n\n        /*liveEdgeFound = function(expectedLiveEdge, actualLiveEdge, period) {\n            if (period.mpd.isClientServerTimeSyncCompleted) return;\n\n            // the difference between expected and actual live edge time is supposed to be a difference between client\n            // and server time as well\n            period.mpd.clientServerTimeShift = actualLiveEdge - expectedLiveEdge;\n            period.mpd.isClientServerTimeSyncCompleted = true;\n            clientServerTimeShift = period.mpd.clientServerTimeShift * 1000;\n        },*/\n\n        calcMSETimeOffset = function(representation) {\n            var presentationOffset = representation.presentationTimeOffset;\n\n            return (-presentationOffset);\n        };\n\n    return {\n        system: undefined,\n        debug: undefined,\n        uriQueryFragModel: undefined,\n\n        setup: function() {\n            //this.system.mapHandler(\"liveEdgeFound\", undefined, liveEdgeFound.bind(this));\n        },\n\n        calcAvailabilityStartTimeFromPresentationTime: calcAvailabilityStartTimeFromPresentationTime,\n        calcAvailabilityEndTimeFromPresentationTime: calcAvailabilityEndTimeFromPresentationTime,\n        calcPresentationTimeFromWallTime: calcPresentationTimeFromWallTime,\n        calcPresentationTimeFromMediaTime: calcPresentationTimeFromMediaTime,\n        calcPresentationStartTime: calcPresentationStartTime,\n        calcActualPresentationTime: calcActualPresentationTime,\n        calcMediaTimeFromPresentationTime: calcMediaTimeFromPresentationTime,\n        calcSegmentAvailabilityRange: calcSegmentAvailabilityRange,\n        calcWallTimeForSegment: calcWallTimeForSegment,\n        calcMSETimeOffset: calcMSETimeOffset\n    };\n};\n\nDash.dependencies.TimelineConverter.prototype = {\n    constructor: Dash.dependencies.TimelineConverter\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nDash.vo.AdaptationSet = function () {\n    \"use strict\";\n    this.period = null;\n    this.index = -1;\n};\n\nDash.vo.AdaptationSet.prototype = {\n    constructor: Dash.vo.AdaptationSet\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Fraunhofer Fokus\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nDash.vo.Event = function () {\n    \"use strict\";\n    this.duration = NaN;\n    this.presentationTime = NaN;\n    this.id = NaN;\n    this.messageData = \"\";\n    this.eventStream = null;\n    this.presentationTimeDelta = NaN; // Specific EMSG Box paramater\n\n};\n\nDash.vo.Event.prototype = {\n    constructor: Dash.vo.Event\n};\n","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Fraunhofer Fokus\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nDash.vo.EventStream = function () {\n    \"use strict\";\n    this.adaptionSet = null;\n    this.representation = null;\n    this.period = null;\n    this.timescale = 1;\n    this.value = \"\";\n    this.schemeIdUri = \"\";\n};\n\nDash.vo.EventStream.prototype = {\n    constructor: Dash.vo.EventStream\n};\n","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nDash.vo.Mpd = function () {\n    \"use strict\";\n    this.manifest = null;\n    this.suggestedPresentationDelay = 0;\n    this.availabilityStartTime = null;\n    this.availabilityEndTime = Number.POSITIVE_INFINITY;\n    this.timeShiftBufferDepth = Number.POSITIVE_INFINITY;\n    this.maxSegmentDuration = Number.POSITIVE_INFINITY;\n    this.checkTime = NaN;\n    this.clientServerTimeShift = 0;\n    this.isClientServerTimeSyncCompleted = false;\n};\n\nDash.vo.Mpd.prototype = {\n    constructor: Dash.vo.Mpd\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nDash.vo.Period = function () {\n    \"use strict\";\n    this.id = null;\n    this.index = -1;\n    this.duration = NaN;\n    this.start = NaN;\n    this.mpd = null;\n    this.liveEdge = NaN;\n};\n\nDash.vo.Period.prototype = {\n    constructor: Dash.vo.Period\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nDash.vo.Representation = function () {\n    \"use strict\";\n    this.id = null;\n    this.index = -1;\n    this.adaptation = null;\n    this.segmentInfoType = null;\n    this.initialization = null;\n    this.segmentDuration = NaN;\n    this.timescale = 1;\n    this.startNumber = 1;\n    this.indexRange = null;\n    this.range = null;\n    this.presentationTimeOffset = 0;\n    // Set the source buffer timeOffset to this\n    this.MSETimeOffset = NaN;\n    this.segmentAvailabilityRange = null;\n    this.availableSegmentsNumber = 0;\n};\n\nDash.vo.Representation.prototype = {\n    constructor: Dash.vo.Representation\n};","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nDash.vo.Segment = function () {\n    \"use strict\";\n    this.indexRange = null;\n    this.index = null;\n    this.mediaRange = null;\n    this.media = null;\n    this.duration = NaN;\n    // this is the time that should be inserted into the media url\n    this.replacementTime = null;\n    // this is the number that should be inserted into the media url\n    this.replacementNumber = NaN;\n    // This is supposed to match the time encoded in the media Segment\n    this.mediaStartTime = NaN;\n    // When the source buffer timeOffset is set to MSETimeOffset this is the \n    // time that will match the seekTarget and video.currentTime\n    this.presentationStartTime = NaN;\n    // Do not schedule this segment until \n    this.availabilityStartTime = NaN;\n    // Ignore and  discard this segment after\n    this.availabilityEndTime = NaN;\n    // The index of the segment inside the availability window\n    this.availabilityIdx = NaN;\n    // For dynamic mpd's, this is the wall clock time that the video   \n    // element currentTime should be presentationStartTime\n    this.wallStartTime = NaN;\n    this.representation = null;\n};\n\nDash.vo.Segment.prototype = {\n    constructor: Dash.vo.Segment\n};","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2014, Orange\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n * \n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n/*jshint -W020 */\nHls = (function () {\n    \"use strict\";\n\n    return {\n        dependencies: {}\n    };\n}());","/*\n * The copyright in this software is being made available under the BSD License, included below. This software may be subject to other third party and contributor rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Digital Primates\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Digital Primates nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nHls.dependencies.HlsStream = function() {\n    \"use strict\";\n\n    var REQUEST_PARAMS = {\n        stream: {\n            responseType: 'arraybuffer',\n            contentType: 'application/octet-stream'\n        },\n        text: {\n            responseType: 'text',\n            contentType: 'application/x-www-form-urlencoded'\n        },\n    };\n\n    var subtitlesEnabled = false,\n        autoPlay = true,\n        initialized = false,\n        errored = false,\n\n        protectionData,\n        licenseRequest = null,\n\n        // Events listeners\n        endedListener,\n        loadedmetadataListener,\n        loadeddataListener,\n        playListener,\n        pauseListener,\n        errorListener,\n        seekingListener,\n        seekedListener,\n        timeupdateListener,\n        waitingListener,\n        durationchangeListener,\n        progressListener,\n        ratechangeListener,\n        canplayListener,\n        playingListener,\n        loadstartListener,\n\n        needKeyListener,\n        keyMessageListener,\n        keyAddedListener,\n        keyErrorListener,\n\n        // Audio/text languages\n        defaultAudioLang = 'und',\n        defaultSubtitleLang = 'und',\n\n        // Initial start time\n        initialStartTime = -1,\n\n        play = function() {\n            if (!initialized) {\n                return;\n            }\n\n            this.debug.info(\"[Stream] Play.\");\n            this.videoModel.play();\n        },\n\n        pause = function() {\n            this.debug.info(\"[Stream] Pause.\");\n            this.videoModel.pause();\n        },\n\n        seek = function(time/*, autoplay*/) {\n            if (!initialized) {\n                //this.debug.info(\"[Stream] (seek) not initialized\");\n                return;\n            }\n\n            this.debug.info(\"[Stream] Seek: \" + time);\n\n            this.videoModel.setCurrentTime(time);\n        },\n\n        onLoadedMetadata = function() {\n            this.debug.info(\"[Stream] <video> loadedmetadata event\");\n            this.metricsModel.addMetaData();\n            this.metricsModel.addState(\"video\", \"buffering\", this.getVideoModel().getCurrentTime());\n        },\n\n        onLoadedData = function() {\n            this.debug.info(\"[Stream] <video> loadeddata event\");\n            this.setAudioLang(defaultAudioLang);\n            this.enableSubtitles(subtitlesEnabled);\n        },\n\n        onCanPlay = function() {\n            this.debug.info(\"[Stream] <video> canplay event\");\n            if (autoPlay) {\n                this.videoModel.play();\n            }\n        },\n\n        onPlaying = function() {\n            this.debug.info(\"[Stream] <video> playing event\");\n            this.metricsModel.addState(\"video\", \"playing\", this.getVideoModel().getCurrentTime());\n        },\n\n        onLoadStart = function() {\n            this.debug.info(\"[Stream] <video> loadstart event\");\n        },\n\n        onPlay = function() {\n            this.debug.info(\"[Stream] <video> play event\");\n\n            this.metricsModel.addPlayList(\"video\", new Date().getTime(), this.videoModel.getCurrentTime(), \"play\");\n        },\n\n        onEnded = function() {\n            this.debug.info(\"[Stream] <video> ended event\");\n            //add stopped state metric with reason = 1 : end of stream\n            this.metricsModel.addState(\"video\", \"stopped\", this.videoModel.getCurrentTime(), 1);\n        },\n\n        onPause = function() {\n            this.debug.info(\"[Stream] <video> pause event\");\n            this.metricsModel.addState(\"video\", \"paused\", this.videoModel.getCurrentTime());\n            this.metricsModel.addPlayList(\"video\", new Date().getTime(), this.videoModel.getCurrentTime(), \"pause\");\n        },\n\n        onError = function(event) {\n            var error = event.target.error,\n                code,\n                message = \"[Stream] <video> error: \";\n\n            if (error.code === -1) {\n                // not an error!\n                return;\n            }\n\n            switch (error.code) {\n                case 1:\n                    code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_ABORTED;\n                    message += \"[HLS] The fetching process for the media resource was aborted by the user\";\n                    break;\n                case 2:\n                    code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_NETWORK;\n                    message += \"[HLS] A network error has caused the user agent to stop fetching the media resource\";\n                    break;\n                case 3:\n                    code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_DECODE;\n                    message += \"[HLS] An error has occurred in the decoding of the media resource\";\n                    break;\n                case 4:\n                    code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_SRC_NOT_SUPPORTED;\n                    message += \"[HLS] The media could not be loaded, either because the server or network failed or because the format is not supported\";\n                    break;\n                case 5:\n                    code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_ENCRYPTED;\n                    message += \"[HLS] The encrypted media stream could not be played\";\n                    break;\n            }\n\n            errored = true;\n\n            this.errHandler.sendError(code, message);\n        },\n\n        onSeeking = function() {\n            this.debug.info(\"[Stream] <video> seeking event: \" + this.videoModel.getCurrentTime());\n            this.metricsModel.addState(\"video\", \"seeking\", this.videoModel.getCurrentTime());\n            this.metricsModel.addPlayList('video', new Date().getTime(), this.getVideoModel().getCurrentTime(), MediaPlayer.vo.metrics.PlayList.SEEK_START_REASON);\n        },\n\n        onSeeked = function() {\n            // this.debug.info(\"[Stream] <video> seeked event\");\n        },\n\n        onProgress = function() {\n            // this.debug.info(\"[Stream] <video> progress event\");\n        },\n\n        onTimeupdate = function() {\n            this.debug.info(\"[Stream] <video> timeupdate event: \" + this.videoModel.getCurrentTime());\n        },\n\n        onWaiting = function() {\n            this.debug.info(\"[Stream] <video> waiting event\");\n            if (!this.getVideoModel().isSeeking()) {\n                this.metricsModel.addState(\"video\", \"buffering\", this.getVideoModel().getCurrentTime());\n            }\n        },\n\n        onDurationchange = function() {\n            this.debug.info(\"[Stream] <video> durationchange event: \" + this.videoModel.getDuration());\n        },\n\n        onRatechange = function() {\n            this.debug.info(\"[Stream] <video> ratechange event: \" + this.videoModel.getPlaybackRate());\n        },\n\n        getKsProtectionData = function(ks) {\n            if (!protectionData) {\n                return null;\n            }\n            return protectionData[ks];\n        },\n\n        stringToArray = function (string) {\n            var buffer = new ArrayBuffer(string.length * 2); // 2 bytes for each char\n            var array = new Uint16Array(buffer);\n            for (var i = 0; i < string.length; i++) {\n                array[i] = string.charCodeAt(i);\n            }\n            return array;\n        },\n\n        extractContentId = function (initData) {\n            var contentId = String.fromCharCode.apply(null, new Uint16Array(initData.buffer));\n\n            var parts = contentId.split(\"//\");\n            if (parts.length != 2) {\n              throw \"Invalid content key format\";\n            }\n\n            return parts[1];\n        },\n\n        getCertificate = function () {\n            var protData = getKsProtectionData('com.apple.fps.1_0');\n            if (!protData || !protData.serverCertificate) {\n                return [];\n            }\n            return BASE64.decodeArray(protData.serverCertificate);\n        },\n\n        concatInitDataIdAndCertificate = function (initData, id, cert) {\n            if (typeof id == \"string\")\n                id = stringToArray(id);\n\n            // layout is [initData][4 byte: idLength][idLength byte: id][4 byte:certLength][certLength byte: cert]\n            var offset = 0;\n            var buffer = new ArrayBuffer(initData.byteLength + 4 + id.byteLength + 4 + cert.byteLength);\n            var dataView = new DataView(buffer);\n\n            var initDataArray = new Uint8Array(buffer, offset, initData.byteLength);\n            initDataArray.set(initData);\n            offset += initDataArray.byteLength;\n\n            dataView.setUint32(offset, id.byteLength, true);\n            offset += 4;\n\n            var idArray = new Uint16Array(buffer, offset, id.length);\n            idArray.set(id);\n            offset += idArray.byteLength;\n\n            dataView.setUint32(offset, cert.byteLength, true);\n            offset += 4;\n\n            var certArray = new Uint8Array(buffer, offset, cert.byteLength);\n            certArray.set(cert);\n\n            return new Uint8Array(buffer, 0, buffer.byteLength);\n        },\n\n        processLicenseMessage = function (session, type, message) {\n\n            if (type === 'text') {\n                message = String.fromCharCode.apply(null, message);\n                message = 'spc=' + BASE64.encodeASCII(message) + '&assetId=' + encodeURIComponent(session.contentId);\n            }\n\n            return message;\n        },\n\n        sendLicenseRequest = function (session, type, url, body) {\n            var self = this,\n                needFailureReport = true,\n\n            licenseRequest = new XMLHttpRequest();\n            licenseRequest.responseType = REQUEST_PARAMS[type].responseType;\n            licenseRequest.session = session;\n\n            licenseRequest.onload = function() {\n\n                if (this.status < 200 || this.status > 299) {\n                    return;\n                }\n\n                if (this.status === 200 && this.readyState === 4) {\n                    self.debug.log(\"[DRM] Received license response\");\n                    needFailureReport = false;\n                    processLicenseResponse(this, type);\n                    // this.session.update(new Uint8Array(licenseRequest.response));\n                }\n            };\n\n            licenseRequest.onerror = licenseRequest.onloadend = function() {\n                if (!needFailureReport) {\n                    licenseRequest = null;\n                    return;\n                }\n                needFailureReport = false;\n\n                // Raise error only if request has not been aborted by reset\n                if (!this.aborted) {\n                    self.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_LICENSER_ERROR,\"License request failed\", {url: url, status: this.status, error: this.response});\n                }\n                licenseRequest = null;\n            };\n\n            licenseRequest.open('POST', url, true);\n            licenseRequest.setRequestHeader('Content-Type', REQUEST_PARAMS[type].contentType);\n            licenseRequest.send(body);\n        },\n\n        processLicenseResponse = function (request, type) {\n            var key;\n\n            if (type === 'text') {\n                // Response can be of the form: '\\n<ckc>base64encoded</ckc>\\n', so trim the excess:\n                key = request.responseText.trim();\n                if (key.substr(0, 5) === '<ckc>' && key.substr(-6) === '</ckc>')\n                    key = key.slice(5,-6);\n                key = BASE64.decodeArray(key);\n            } else {\n                key = new Uint8Array(request.response);\n            }\n\n            request.session.update(key);\n        },\n\n        getKeyError = function(event) {\n            var code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR,\n                msg = \"MediakeyError\";\n\n            if (event.errorCode) {\n                switch (event.errorCode.code) {\n                    case 1:\n                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_UNKNOWN;\n                        msg = \"An unspecified error occurred. This value is used for errors that don't match any of the other codes.\";\n                        break;\n                    case 2:\n                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_CLIENT;\n                        msg = \"The Key System could not be installed or updated.\";\n                        break;\n                    case 3:\n                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_SERVICE;\n                        msg = \"The message passed into update indicated an error from the license service.\";\n                        break;\n                    case 4:\n                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_OUTPUT;\n                        msg = \"There is no available output device with the required characteristics for the content protection system.\";\n                        break;\n                    case 5:\n                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_HARDWARECHANGE;\n                        msg += \"A hardware configuration change caused a content protection error.\";\n                        break;\n                    case 6:\n                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_DOMAIN;\n                        msg = \"An error occurred in a multi-device domain licensing configuration. The most common error is a failure to join the domain.\";\n                        break;\n                    default:\n                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_UNKNOWN;\n                        msg = \"An unspecified error occurred. This value is used for errors that don't match any of the other codes.\";\n                        break;\n                }\n            } else {\n                code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_UNKNOWN;\n                msg = \"An unspecified error occurred. This value is used for errors that don't match any of the other codes.\";\n            }\n            if (event.systemCode) {\n                msg += \"  (System Code = \" + event.systemCode + \")\";\n            }\n            return new MediaPlayer.vo.protection.KeyError(code, msg);\n        },\n\n        onNeedKey = function(e) {\n            this.debug.info(\"[Stream] <video> needkey event\", e);\n\n            var video = this.videoModel.getElement(),\n                contentId = extractContentId(e.initData),\n                certificate = getCertificate();\n\n            var initData = concatInitDataIdAndCertificate(e.initData, contentId, certificate);\n\n            var mediaKeys = new WebKitMediaKeys('com.apple.fps.1_0');\n            video.webkitSetMediaKeys(mediaKeys);\n            var session = video.webkitKeys.createSession('video/mp4', initData);\n\n            if (!session)\n                throw \"Could not create key session\";\n\n            if (session.error) {\n                this.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_NO_SESSION,\n                    \"Failed to create key session\", {code: session.error.code, systemCode: session.error.systemCode});\n            }\n\n            session.contentId = contentId;\n\n            session.addEventListener(\"webkitkeymessage\", keyMessageListener, false);\n            session.addEventListener(\"webkitkeyadded\", keyAddedListener, false);\n            session.addEventListener(\"webkitkeyerror\", keyErrorListener, false);\n        },\n\n        onKeyMessage = function(e) {\n\n            this.debug.info(\"[Stream] keymessage event\", e);\n\n            var session = e.target,\n                message = e.message,\n                type;\n\n            var protData = getKsProtectionData('com.apple.fps.1_0');\n            if (!protData || !protData.laURL) {\n                this.errHandler.sendError(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_URL_LICENSER_UNKNOWN, \"No license server URL specified\");\n                return;\n            }\n\n            type = (protData && protData.requestType && protData.requestType === 'text') ? 'text' : 'stream';\n\n            message = processLicenseMessage(session, type, message);\n            sendLicenseRequest.call(this, session, type, protData.laURL, message);\n        },\n\n        onKeyAdded = function(e) {\n            this.debug.info(\"[Stream] keyadded event\", e);\n        },\n\n        onKeyError = function(e) {\n            this.debug.info(\"[Stream] keyerror event\", e);\n            var error = getKeyError(e);\n            this.errHandler.sendError(error.code, error.msg);\n        };\n\n    return {\n        system: undefined,\n        videoModel: undefined,\n        capabilities: undefined,\n        debug: undefined,\n        metricsExt: undefined,\n        errHandler: undefined,\n        metricsModel: undefined,\n        eventBus: undefined,\n        notify: undefined,\n\n        setup: function() {\n\n            playListener = onPlay.bind(this);\n            pauseListener = onPause.bind(this);\n            errorListener = onError.bind(this);\n            seekingListener = onSeeking.bind(this);\n            seekedListener = onSeeked.bind(this);\n            progressListener = onProgress.bind(this);\n            ratechangeListener = onRatechange.bind(this);\n            timeupdateListener = onTimeupdate.bind(this);\n            waitingListener = onWaiting.bind(this);\n            durationchangeListener = onDurationchange.bind(this);\n            loadedmetadataListener = onLoadedMetadata.bind(this);\n            loadeddataListener = onLoadedData.bind(this);\n            canplayListener = onCanPlay.bind(this);\n            playingListener = onPlaying.bind(this);\n            loadstartListener = onLoadStart.bind(this);\n\n            needKeyListener = onNeedKey.bind(this);\n            keyMessageListener = onKeyMessage.bind(this);\n            keyAddedListener = onKeyAdded.bind(this);\n            keyErrorListener = onKeyError.bind(this);\n\n            endedListener = onEnded.bind(this);\n        },\n\n        load: function(url) {\n            this.videoModel.setSource(url);\n        },\n\n        setVideoModel: function(value) {\n            this.videoModel = value;\n            this.videoModel.listen(\"play\", playListener);\n            this.videoModel.listen(\"pause\", pauseListener);\n            this.videoModel.listen(\"error\", errorListener);\n            this.videoModel.listen(\"seeking\", seekingListener);\n            this.videoModel.listen(\"seeked\", seekedListener);\n            this.videoModel.listen(\"timeupdate\", timeupdateListener);\n            this.videoModel.listen(\"waiting\", waitingListener);\n            this.videoModel.listen(\"durationchange\", durationchangeListener);\n            this.videoModel.listen(\"progress\", progressListener);\n            this.videoModel.listen(\"ratechange\", ratechangeListener);\n            this.videoModel.listen(\"loadedmetadata\", loadedmetadataListener);\n            this.videoModel.listen(\"loadeddata\", loadeddataListener);\n            this.videoModel.listen(\"ended\", endedListener);\n            this.videoModel.listen(\"canplay\", canplayListener);\n            this.videoModel.listen(\"playing\", playingListener);\n            this.videoModel.listen(\"loadstart\", loadstartListener);\n\n            this.videoModel.listen(\"webkitneedkey\", needKeyListener);\n        },\n\n        reset: function() {\n            this.debug.info(\"[Stream] Reset\");\n\n            pause.call(this);\n\n            // Abort license request\n            if (licenseRequest) {\n                licenseRequest.aborted = true;\n                licenseRequest.abort();\n            }\n\n            this.videoModel.unlisten(\"play\", playListener);\n            this.videoModel.unlisten(\"pause\", pauseListener);\n            this.videoModel.unlisten(\"error\", errorListener);\n            this.videoModel.unlisten(\"seeking\", seekingListener);\n            this.videoModel.unlisten(\"seeked\", seekedListener);\n            this.videoModel.unlisten(\"timeupdate\", timeupdateListener);\n            this.videoModel.unlisten(\"waiting\", waitingListener);\n            this.videoModel.unlisten(\"durationchange\", durationchangeListener);\n            this.videoModel.unlisten(\"progress\", progressListener);\n            this.videoModel.unlisten(\"ratechange\", ratechangeListener);\n            this.videoModel.unlisten(\"loadedmetadata\", loadedmetadataListener);\n            this.videoModel.unlisten(\"loadeddata\", loadeddataListener);\n            this.videoModel.unlisten(\"ended\", endedListener);\n            this.videoModel.unlisten(\"canplay\", canplayListener);\n            this.videoModel.unlisten(\"playing\", playingListener);\n            this.videoModel.unlisten(\"loadstart\", loadstartListener);\n\n            this.videoModel.unlisten(\"webkitneedkey\", needKeyListener);\n\n            this.debug.info(\"[Stream] Reset source\");\n            this.videoModel.setSource(null);\n            this.videoModel = null;\n\n            return Q.when(true);\n        },\n\n\n        setProtectionData: function(protData) {\n            protectionData = protData;\n        },\n\n        setInitialStartTime: function(startTime) {\n            var time = parseFloat(startTime);\n            if (!isNaN(time)) {\n                initialStartTime = time;\n            }\n        },\n\n        getAudioTracks: function() {\n            var audioTracks = [],\n                tracks = this.getVideoModel().getElement().audioTracks;\n            if (tracks.length === 0) {\n                return [];\n            }\n\n            for (var i = 0; i < tracks.length; i++) {\n                audioTracks.push({\n                    type: 'audio',\n                    id: tracks[i].id,\n                    lang: tracks[i].language\n                });\n            }\n            // this.debug.log('[Stream] audio track: ' + JSON.stringify(audioTracks));\n            return audioTracks;\n        },\n\n        setAudioLang: function(lang) {\n            this.debug.log('[Stream] Set audio lang: ' + lang);\n            var tracks = this.getVideoModel().getElement().audioTracks;\n            if (tracks.length === 0) {\n                return;\n            }\n            for (var i = 0; i < tracks.length; i++) {\n                if (lang === tracks[i].language) {\n                    tracks[i].enabled = true;\n                }\n            }\n        },\n\n        setAudioTrack: function(audioTrack) {\n            this.debug.log('[Stream] Set audio track: ' + audioTrack.lang);\n            var tracks = this.getVideoModel().getElement().audioTracks;\n            if (tracks.length === 0) {\n                return;\n            }\n            for (var i = 0; i < tracks.length; i++) {\n                if (audioTrack.id === tracks[i].id &&\n                    audioTrack.lang === tracks[i].language) {\n                    tracks[i].enabled = true;\n                }\n            }\n        },\n\n        getSelectedAudioTrack: function() {\n            var tracks = this.getVideoModel().getElement().audioTracks;\n            for (var i = 0; i < tracks.length; i++) {\n                if (tracks[i].enabled) {\n                    return {\n                        type: 'audio',\n                        id: tracks[i].id,\n                        lang: tracks[i].language\n                    };\n                }\n            }\n            return null;\n        },\n\n        getSubtitleTracks: function() {\n            var textTracks = [],\n                tracks = this.getVideoModel().getElement().textTracks;\n            if (tracks.length === 0) {\n                return [];\n            }\n\n            for (var i = 0; i < tracks.length; i++) {\n                textTracks.push({\n                    type: 'text',\n                    id: tracks[i].label,\n                    lang: tracks[i].language\n                });\n            }\n            // this.debug.log('[Stream] text track: ' + JSON.stringify(textTracks));\n            return textTracks;\n        },\n\n        enableSubtitles: function(enabled) {\n            subtitlesEnabled = enabled;\n            var tracks = this.getVideoModel().getElement().textTracks;\n            if (tracks.length === 0) {\n                return;\n            }\n\n            if (enabled) {\n                this.debug.log('[Stream] Set subtitle lang: ' + defaultSubtitleLang);\n            }\n\n            var found = false;\n            for (var i = 0; i < tracks.length; i++) {\n                if (enabled && defaultSubtitleLang === tracks[i].language) {\n                    tracks[i].mode = 'showing';\n                    found = true;\n                } else {\n                    tracks[i].mode = 'hidden';\n                }\n            }\n\n            if (enabled && !found) {\n                tracks[0].mode = \"showing\";\n            }\n        },\n\n        setSubtitleTrack: function(subtitleTrack) {\n            this.debug.log('[Stream] Set subtitle track: ' + subtitleTrack.lang);\n            var tracks = this.getVideoModel().getElement().textTracks;\n            if (tracks.length === 0) {\n                return;\n            }\n            for (var i = 0; i < tracks.length; i++) {\n                if (subtitleTrack.id === tracks[i].label &&\n                    subtitleTrack.lang === tracks[i].language) {\n                    tracks[i].mode = 'showing';\n                }\n            }\n        },\n\n        getSelectedSubtitleTrack: function() {\n            var tracks = this.getVideoModel().getElement().textTracks;\n            for (var i = 0; i < tracks.length; i++) {\n                if (tracks[i].mode === 'showing') {\n                    return {\n                        type: 'text',\n                        id: tracks[i].label,\n                        lang: tracks[i].language\n                    };\n                }\n            }\n            return null;\n        },\n\n        initProtection: function(/*protectionCtrl*/) {},\n\n        getVideoModel: function() {\n            return this.videoModel;\n        },\n\n        setAutoPlay: function(value) {\n            autoPlay = value;\n        },\n\n        setDefaultAudioLang: function(language) {\n            defaultAudioLang = language;\n        },\n\n        setDefaultSubtitleLang: function(language) {\n            defaultSubtitleLang = language;\n        },\n\n        getAutoPlay: function() {\n            return autoPlay;\n        },\n\n        getDuration: function() {\n            return this.videoModel.getDuration();\n        },\n\n        // Used by StreamController for periods transitions => NA\n        getStartTime: function() {return 0;},\n\n        getPeriodIndex: function() {return 0;},\n\n        getId: function() {return '';},\n\n        // Used by StreamController to compose streams => NA\n        getPeriodInfo: function() {return null;},\n\n        // Not used/called\n        getMinbufferTime: function() {return 0;},\n\n        // Not called since no DVR window range (see MediaPlayer::seek)\n        getLiveDelay: function() {return -1;},\n\n        // Not supported\n        startEventController: function() {},\n        resetEventController: function() {},\n\n        // Not supported\n        setTrickModeSpeed: function(/*speed*/) {},\n        getTrickModeSpeed: function() {return -1;},\n\n        // Used by StreamController to compose streams => NA\n        updateData: function() {},\n\n        play: play,\n        seek: seek,\n        pause: pause\n    };\n};\n\nHls.dependencies.HlsStream.prototype = {\n    constructor: Hls.dependencies.HlsStream\n};","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.utils.copyMethods = function(clazz) {\n    var rslt = new clazz();\n    rslt.parent = {};\n    for (var key in rslt) {\n        rslt.parent[key] = rslt[key];\n    }\n\n    rslt.setup = function() {\n        for (var att in this.parent) {\n            if (this.parent[att] === undefined) {\n                this.parent[att] = this[att];\n            }\n        }\n    };\n\n    return rslt;\n};\n"," /*\n  * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n  * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n  *\n  * Copyright (c) 2014, Orange\n  * All rights reserved.\n  *\n  * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n  *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n  *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n  *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n  *\n  *\n  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n  */\n MediaPlayer.utils.DOMParser = function() {\n     \"use strict\";\n\n     var _parser = null,\n         _xmlDoc = null;\n\n     return {\n         getAllSpecificNodes: function(mainNode, nodeName) {\n             var i = 0,\n                 id,\n                 querySelectorResult,\n                 returnTab = [];\n\n             if (mainNode) {\n                 querySelectorResult = mainNode.querySelectorAll(nodeName);\n                 if (querySelectorResult) {\n                     for (i = 0; i < querySelectorResult.length; i++) {\n                         id = this.getAttributeValue(querySelectorResult[i], 'xml:id');\n                         if (id) {\n                             returnTab[id] = querySelectorResult[i].attributes;\n                             if (querySelectorResult[i].childNodes.length > 0) {\n                                 returnTab[id].childNodes = querySelectorResult[i].childNodes;\n                             }\n                         }\n                     }\n                 }\n             }\n\n             return returnTab;\n         },\n\n         getAttributeName: function(node, attrValue) {\n             var returnValue = [],\n                 domAttribute = null,\n                 i = 0,\n                 attribList = null;\n\n             if (node && node.attributes) {\n                 attribList = node.attributes;\n                 if (attribList) {\n                     for (i = 0; i < attribList.length; i++) {\n                         domAttribute = attribList[i];\n                         if (domAttribute.value === attrValue) {\n                             returnValue.push(domAttribute.name);\n                         }\n                     }\n                 }\n             }\n\n             return returnValue;\n         },\n\n         getTextNodesIn: function(nodeParent) {\n             var textNodes = [],\n                 i = 0,\n                 nodes = null,\n                 node = null,\n                 nodeType = null;\n\n             if (nodeParent) {\n                 nodes = nodeParent.childNodes;\n                 for (i = 0; i < nodes.length; i++) {\n                     node = nodes[i];\n                     nodeType = node.nodeType;\n                     /*ELEMENT_NODE == 1 ( element node )\n                     ATTRIBUTE_NODE == 2 ( node attribute )\n                     TEXT_NODE == 3 ( text node )\n                     CDATA_SECTION_NODE == 4 ( CDATA section node )\n                     ENTITY_REFERENCE_NODE == 5 ( node reference to an entity )\n                     ENTITY_NODE == 6 ( Feature node )\n                     PROCESSING_INSTRUCTION_NODE == 7 ( processing instruction node )\n                     COMMENT_NODE == 8 ( comment node )\n                     DOCUMENT_NODE == 9 ( document node )\n                     DOCUMENT_TYPE_NODE == 10 ( Document Type node )\n                     DOCUMENT_FRAGMENT_NODE == 11 ( node document fragment )\n                     NOTATION_NODE == 12 ( node notation )*/\n                     if (nodeType == 3) {\n                         textNodes.push(node);\n                     } else if (nodeType == 1 || nodeType == 9 || nodeType == 11) {\n                         textNodes = textNodes.concat(this.getTextNodesIn(node));\n                     }\n                 }\n             }\n             return textNodes;\n         },\n\n         getAttributeValue: function(node, attrName, namespace) {\n             var returnValue = null;\n\n             if (node && typeof node.getAttribute == 'function') {\n                 returnValue = node.getAttribute(attrName);\n                 if (returnValue === null && namespace) {\n                     returnValue = node.getAttributeNS(namespace, attrName);\n                 }\n             }\n\n             return returnValue;\n         },\n\n         getChildNode: function(nodeParent, childName) {\n             var i = 0,\n                 element;\n\n             if (nodeParent && nodeParent.childNodes) {\n                 for (i = 0; i < nodeParent.childNodes.length; i++) {\n                     element = nodeParent.childNodes[i];\n                     if (element.nodeName === childName) {\n                         return element;\n                     }\n                     element = undefined;\n                 }\n             }\n\n             return element;\n         },\n\n         getChildNodes: function(nodeParent, childName) {\n             var i = 0,\n                 element = [];\n\n             if (nodeParent && nodeParent.childNodes) {\n                 for (i = 0; i < nodeParent.childNodes.length; i++) {\n                     if (nodeParent.childNodes[i].nodeName === childName) {\n                         element.push(nodeParent.childNodes[i]);\n                     }\n                 }\n             }\n\n             return element;\n         },\n\n         createXmlTree: function(xmlDocStr) {\n             if (window.DOMParser) {\n                 try {\n                     if (!_parser) {\n                         _parser = new window.DOMParser();\n                     }\n\n                     _xmlDoc = _parser.parseFromString(xmlDocStr, \"text/xml\");\n                     if (_xmlDoc.getElementsByTagName('parsererror').length > 0) {\n                         throw new Error('Error parsing XML');\n                     }\n                 } catch (e) {\n                     _xmlDoc = null;\n                 }\n             }\n             return _xmlDoc;\n         }\n     };\n };","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMediaPlayer.utils.ObjectIron = function (map) {\n\n    var lookup;\n\n    // create a list of top level items to search for\n    lookup = [];\n    for (var i = 0, len = map.length; i < len; i += 1) {\n        if (map[i].isRoot) {\n            lookup.push(\"root\");\n        } else {\n            lookup.push(map[i].name);\n        }\n    }\n\n    var mergeValues = function (parentItem, childItem) {\n            var name;\n            if (parentItem === null || childItem === null) {\n                return;\n            }\n\n            for (name in parentItem) {\n                if (parentItem.hasOwnProperty(name)) {\n                    if (!childItem.hasOwnProperty(name)) {\n                        childItem[name] = parentItem[name];\n                    }\n                }\n            }\n        },\n\n        mapProperties = function (properties, parent, child) {\n            var i,\n                len,\n                property,\n                parentValue,\n                childValue;\n\n            if (properties === null || properties.length === 0) {\n                return;\n            }\n\n            for (i = 0, len = properties.length; i < len; i += 1) {\n                property = properties[i];\n\n                if (parent.hasOwnProperty(property.name)) {\n                    if (child.hasOwnProperty(property.name)) {\n                        // check to see if we should merge\n                        if (property.merge) {\n                           parentValue = parent[property.name];\n                           childValue = child[property.name];\n\n                            // complex objects; merge properties\n                            if (typeof parentValue === 'object' && typeof childValue === 'object') {\n                                mergeValues(parentValue, childValue);\n                            }\n                            // simple objects; merge them together\n                            else {\n                                if (property.mergeFunction !== null) {\n                                    child[property.name] = property.mergeFunction(parentValue, childValue);\n                                } else {\n                                    child[property.name] = parentValue + childValue;\n                                }\n                            }\n                        }\n                    } else {\n                        // just add the property\n                        child[property.name] = parent[property.name];\n                    }\n                }\n            }\n        },\n\n        mapItem = function (obj, node) {\n            var item = obj,\n                i,\n                len,\n                v,\n                len2,\n                array,\n                childItem,\n                childNode;\n\n            if (obj.transformFunc) {\n                node = obj.transformFunc(node);\n            }\n\n            if (item.children === null || item.children.length === 0) {\n                return node;\n            }\n\n            for (i = 0, len = item.children.length; i < len; i += 1) {\n                childItem = item.children[i];\n                var itemMapped = null;\n                if (node.hasOwnProperty(childItem.name)) {\n                    if (childItem.isArray) {\n                        array = node[childItem.name + \"_asArray\"];\n                        for (v = 0, len2 = array.length; v < len2; v += 1) {\n                            childNode = array[v];\n                            mapProperties(item.properties, node, childNode);\n                            //copy result in source object\n                            itemMapped = mapItem(childItem, childNode);\n                            node[childItem.name + \"_asArray\"][v] = itemMapped;\n                            node[childItem.name][v] =  itemMapped;\n                        }\n                    } else {\n                        childNode = node[childItem.name];\n                        mapProperties(item.properties, node, childNode);\n                        //copy result in source object\n                        itemMapped = mapItem(childItem, childNode);\n                        node[childItem.name] = itemMapped;\n                        node[childItem.name + \"_asArray\"] =  [itemMapped];\n                    }\n                }\n            }\n            return node;\n        },\n\n        performMapping = function (source) {\n            var i,\n                len,\n                pi,\n                pp,\n                item,\n                node,\n                array;\n\n            if (source === null) {\n                return source;\n            }\n\n            if (typeof source !== 'object') {\n                return source;\n            }\n\n            // first look to see if anything cares about the root node\n            for (i = 0, len = lookup.length; i < len; i += 1) {\n                if (lookup[i] === \"root\") {\n                    item = map[i];\n                    node = source;\n                    source = mapItem(item, node);\n                    // node == source;\n                }\n            }\n\n            // iterate over the objects and look for any of the items we care about\n            for (pp in source) {\n                if (source.hasOwnProperty(pp)) {\n                    pi = lookup.indexOf(pp);\n                    if (pi !== -1) {\n                        item = map[pi];\n\n                        if (item.isArray) {\n                            array = source[pp + \"_asArray\"];\n                            for (i = 0, len = array.length; i < len; i += 1) {\n                                node = array[i];\n                                source[pp][i] = mapItem(item, node);\n                                source[pp + \"_asArray\"][i] = mapItem(item, node);\n                            }\n                        } else {\n                            node = source[pp];\n                            source[pp] = mapItem(item, node);\n                            source[pp + \"_asArray\"] = [mapItem(item, node)];\n                        }\n                    }\n                    // now check this to see if he has any of the properties we care about\n                    source[pp] = performMapping(source[pp]);\n                }\n            }\n\n            return source;\n        };\n\n    return {\n        run: performMapping\n    };\n};\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nMediaPlayer.dependencies.protection.CommonEncryption = {\n\n    /**\n     * Find and return the ContentProtection element in the given array\n     * that indicates support for MPEG Common Encryption\n     *\n     * @param cpArray array of content protection elements\n     * @returns the Common Encryption content protection element or\n     * null if one was not found\n     */\n    findCencContentProtection: function(cpArray) {\n        var retVal = null,\n            i = 0,\n            cp;\n        for (i = 0; i < cpArray.length; ++i) {\n            cp = cpArray[i];\n            if (cp.schemeIdUri.toLowerCase() === \"urn:mpeg:dash:mp4protection:2011\" &&\n                cp.value.toLowerCase() === \"cenc\")\n                retVal = cp;\n        }\n        return retVal;\n    },\n\n    /**\n     * Returns just the data portion of a single PSSH\n     *\n     * @param pssh {ArrayBuffer} the PSSH\n     * @return {ArrayBuffer} data portion of the PSSH\n     */\n    getPSSHData: function(pssh) {\n        var offset = 8, // Box size and type fields\n            view = new DataView(pssh),\n            // Read version\n            version = view.getUint8(offset);\n\n        offset += 20; // Version (1), flags (3), system ID (16)\n\n        if (version > 0) {\n            offset += 4 + (16 * view.getUint32(offset)); // Key ID count (4) and All key IDs (16*count)\n        }\n\n        offset += 4; // Data size\n        return pssh.slice(offset);\n    },\n\n    /**\n     * Returns the PSSH associated with the given key system from the concatenated\n     * list of PSSH boxes in the given initData\n     *\n     * @param {MediaPlayer.dependencies.protection.KeySystem} keySystem the desired\n     * key system\n     * @param {ArrayBuffer} initData 'cenc' initialization data.  Concatenated list of PSSH.\n     * @returns {ArrayBuffer} The PSSH box data corresponding to the given key system\n     * or null if a valid association could not be found.\n     */\n    getPSSHForKeySystem: function(keySystem, initData) {\n        var psshList = MediaPlayer.dependencies.protection.CommonEncryption.parsePSSHList(initData);\n        if (psshList.hasOwnProperty(keySystem.uuid.toLowerCase())) {\n            return psshList[keySystem.uuid.toLowerCase()];\n        }\n        return null;\n    },\n\n    /**\n     * Parse a standard common encryption PSSH which contains a sinmple\n     * base64-encoding of the init data\n     *\n     * @param cpData the ContentProtection element\n     * @returns {ArrayBuffer} the init data or null if not found\n     */\n    parseInitDataFromContentProtection: function(cpData) {\n        if (cpData && (\"pssh\" in cpData)) {\n            return BASE64.decodeArray(cpData.pssh.__text).buffer;\n        }\n        return null;\n    },\n\n    readBytes: function(buf, pos, nbBytes) {\n        var value = 0,\n            i = 0;\n\n        for (i = 0; i < nbBytes; i++) {\n            value = value << 8;\n            value = value + buf[pos];\n            pos++;\n        }\n        return value;\n    },\n\n    /**\n     * Parses list of PSSH boxes into keysystem-specific PSSH data\n     *\n     * @param data {ArrayBuffer} the concatenated list of PSSH boxes as provided by\n     * CDM as initialization data when CommonEncryption content is detected\n     * @returns {object} an object that has a property named according to each of\n     * the detected key system UUIDs (e.g. 00000000-0000-0000-0000-0000000000)\n     * and a ArrayBuffer (the entire PSSH box) as the property value\n     */\n    parsePSSHList: function(data) {\n\n        if (data === null)\n            return [];\n\n        var dv = new DataView(data);\n        var done = false;\n        var pssh = {};\n\n        // TODO: Need to check every data read for end of buffer\n        var byteCursor = 0;\n        while (!done) {\n\n            var size,\n                nextBox,\n                version,\n                systemID,\n                psshDataSize;\n            var boxStart = byteCursor;\n\n            if (byteCursor >= dv.buffer.byteLength)\n                break;\n\n            /* Box size */\n            size = dv.getUint32(byteCursor);\n            nextBox = byteCursor + size;\n            byteCursor += 4;\n\n            /* Verify PSSH */\n            if (dv.getUint32(byteCursor) !== 0x70737368) {\n                byteCursor = nextBox;\n                continue;\n            }\n            byteCursor += 4;\n\n            /* Version must be 0 or 1 */\n            version = dv.getUint8(byteCursor);\n            if (version !== 0 && version !== 1) {\n                byteCursor = nextBox;\n                continue;\n            }\n            byteCursor++;\n\n            byteCursor += 3; /* skip flags */\n\n            // 16-byte UUID/SystemID\n            systemID = '';\n            var i, val;\n            for (i = 0; i < 4; i++) {\n                val = dv.getUint8(byteCursor + i).toString(16);\n                systemID += (val.length === 1) ? '0' + val : val;\n            }\n            byteCursor += 4;\n            systemID += '-';\n            for (i = 0; i < 2; i++) {\n                val = dv.getUint8(byteCursor + i).toString(16);\n                systemID += (val.length === 1) ? '0' + val : val;\n            }\n            byteCursor += 2;\n            systemID += '-';\n            for (i = 0; i < 2; i++) {\n                val = dv.getUint8(byteCursor + i).toString(16);\n                systemID += (val.length === 1) ? '0' + val : val;\n            }\n            byteCursor += 2;\n            systemID += '-';\n            for (i = 0; i < 2; i++) {\n                val = dv.getUint8(byteCursor + i).toString(16);\n                systemID += (val.length === 1) ? '0' + val : val;\n            }\n            byteCursor += 2;\n            systemID += '-';\n            for (i = 0; i < 6; i++) {\n                val = dv.getUint8(byteCursor + i).toString(16);\n                systemID += (val.length === 1) ? '0' + val : val;\n            }\n            byteCursor += 6;\n\n            systemID = systemID.toLowerCase();\n\n            /* PSSH Data Size */\n            psshDataSize = dv.getUint32(byteCursor);\n            byteCursor += 4;\n\n            /* PSSH Data */\n            pssh[systemID] = dv.buffer.slice(boxStart, nextBox);\n            byteCursor = nextBox;\n        }\n\n        return pssh;\n    },\n\n\n    /**\n     * Returns list of {MediaPlayer.vo.protection.KeySystemConfiguration}\n     * (see: https://w3c.github.io/encrypted-media/#idl-def-MediaKeySystemConfiguration)\n     *\n     * @param {object} videoCodec contains relevant info about video codec\n     * @param {object} audioCodec contains relevant info about audio codec\n     * @param {String} sessionType the session type like \"temporary\" or \"persistent-license\"\n     * @returns {Array} list of {MediaPlayer.vo.protection.KeySystemConfiguration}\n     */\n    getKeySystemConfigurations: function(videoCodec, audioCodec, sessionType) {\n        var audioCapabilities = [],\n            videoCapabilities = [];\n        if (videoCodec) {\n            videoCapabilities.push(new MediaPlayer.vo.protection.MediaCapability(videoCodec));\n        }\n        if (audioCodec) {\n            audioCapabilities.push(new MediaPlayer.vo.protection.MediaCapability(audioCodec));\n        }\n        return [new MediaPlayer.vo.protection.KeySystemConfiguration(\n            audioCapabilities, videoCapabilities, \"optional\", (sessionType === \"temporary\") ? \"optional\" : \"required\", [sessionType])];\n    }\n};","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Provides access to media protection information and functionality.  Each\n * ProtectionController manages a single {@link MediaPlayer.models.ProtectionModel}\n * which encapsulates a set of protection information (EME APIs, selected key system,\n * key sessions).  The APIs of ProtectionController mostly align with the latest EME\n * APIs.  Key system selection is mostly automated when combined with app-overrideable\n * functionality provided in {@link MediaPlayer.dependencies.ProtectionExtensions}.\n *\n * @class MediaPlayer.dependencies.ProtectionController\n * @todo ProtectionController does almost all of its tasks automatically after init() is\n * called.  Applications might want more control over this process and want to go through\n * each step manually (key system selection, session creation, session maintenance).\n */\n\n// Define ArrayBuffer.isView method in case it is not defined (like in IE11 for example)\nif (!ArrayBuffer.isView) {\n    ArrayBuffer.isView = function(data) {\n        return data instanceof ArrayBuffer;\n    };\n}\n\nif (!ArrayBuffer.prototype.slice) {\n    ArrayBuffer.prototype.slice = function(begin, end) {\n        var len = this.byteLength,\n            length,\n            target,\n            targetArray;\n        begin = (begin | 0) || 0;\n        end = end === (void 0) ? len : (end | 0);\n\n        // Handle negative values.\n        if (begin < 0) {\n            begin = Math.max(begin + len, 0);\n        }\n        if (end < 0) {\n            end = Math.max(end + len, 0);\n        }\n\n        if (len === 0 || begin >= len || begin >= end) {\n            return new ArrayBuffer(0);\n        }\n\n        length = Math.min(len - begin, end - begin);\n        target = new ArrayBuffer(length);\n        targetArray = new Uint8Array(target);\n        targetArray.set(new Uint8Array(this, begin, length));\n        return target;\n    };\n}\n\nMediaPlayer.dependencies.ProtectionController = function() {\n    \"use strict\";\n\n    var keySystems = null,\n        pendingNeedKeyData = [],\n        //audioInfo,\n        //videoInfo,\n        audioCodec,\n        videoCodec,\n        protDataSet,\n        xhrLicense = null,\n        initialized = false,\n\n        getProtData = function(keySystem) {\n            var protData = null,\n                keySystemString = keySystem.systemString;\n            if (protDataSet) {\n                protData = (keySystemString in protDataSet) ? protDataSet[keySystemString] : null;\n            }\n            return protData;\n        },\n\n        selectKeySystem = function(supportedKS, fromManifest) {\n\n            var self = this,\n                sessionType,\n                // Build our request object for requestKeySystemAccess\n                requestedKeySystems = [],\n                keySystemsInfo = [],\n                ksIdx,\n                ksAccess,\n                i = 0,\n                ksSelected,\n                keySystemAccess;\n\n            if (this.keySystem) {\n                // We have a key system\n                for (ksIdx = 0; ksIdx < supportedKS.length; ksIdx++) {\n                    if (this.keySystem === supportedKS[ksIdx].ks) {\n                        sessionType = supportedKS[ksIdx].ks.sessionType;\n                        requestedKeySystems.push({\n                            ks: supportedKS[ksIdx].ks,\n                            configs: supportedKS[ksIdx].ks.getKeySystemConfigurations(videoCodec, audioCodec, sessionType)\n                        });\n                        // Key system info in case of error\n                        keySystemsInfo.push({\n                            schemeIdURI: supportedKS[ksIdx].ks.schemeIdURI,\n                            systemString: supportedKS[ksIdx].ks.systemString\n                        });\n\n                        // Ensure that we would be granted key system access using the key\n                        // system and codec information\n                        ksAccess = {};\n                        ksAccess[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE] = function(event) {\n                            self.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE, ksAccess);\n                            if (event.error) {\n                                //if (!fromManifest) {\n                                self.debug.log(\"[DRM] KeySystem Access Denied! -- \" + event.error);\n                                self.eventBus.dispatchEvent({\n                                    type: MediaPlayer.dependencies.ProtectionController.events.KEY_SYSTEM_SELECTED,\n                                    error: \"[DRM] KeySystem Access Denied! -- \" + event.error\n                                });\n                                //}\n                            } else {\n                                self.debug.log(\"[DRM] KeySystem Access Granted\");\n                                self.eventBus.dispatchEvent({\n                                    type: MediaPlayer.dependencies.ProtectionController.events.KEY_SYSTEM_SELECTED,\n                                    data: event.data\n                                });\n                                self.createKeySession(supportedKS[ksIdx].initData, supportedKS[ksIdx].cdmData);\n                            }\n                        };\n                        this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE, ksAccess, undefined, true);\n                        this.protectionModel.requestKeySystemAccess(requestedKeySystems);\n                        break;\n                    }\n                }\n            } else if (this.keySystem === undefined) {\n                // First time through, so we need to select a key system\n                this.keySystem = null;\n                pendingNeedKeyData.push(supportedKS);\n\n                // Add all key systems to our request list since we have yet to select a key system\n                for (i = 0; i < supportedKS.length; i++) {\n                    sessionType = supportedKS[i].ks.sessionType;\n                    requestedKeySystems.push({\n                        ks: supportedKS[i].ks,\n                        configs: supportedKS[i].ks.getKeySystemConfigurations(videoCodec, audioCodec, sessionType)\n                    });\n                    // Key system info in case of error\n                    keySystemsInfo.push({\n                        schemeIdURI: supportedKS[i].ks.schemeIdURI,\n                        systemString: supportedKS[i].ks.systemString\n                    });\n                }\n\n                ksSelected = {};\n\n                ksSelected[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE] = function(event) {\n                    if (!self.protectionModel) {\n                        return;\n                    }\n                    self.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE, ksSelected);\n                    if (event.error) {\n                        self.debug.log(\"[DRM] KeySystem Access Denied! -- \" + event.error);\n                        self.keySystem = undefined;\n                        self.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED, ksSelected);\n                        if (!fromManifest) {\n                            self.eventBus.dispatchEvent({\n                                type: MediaPlayer.dependencies.ProtectionController.events.KEY_SYSTEM_SELECTED,\n                                error: \"[DRM] KeySystem Access Denied! -- \" + event.error\n                            });\n                        }\n                        self.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,\n                            new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYSYSERR_ACCESS_DENIED, \"No KeySystem/CDM available\", {keySystems: keySystemsInfo}));\n                    } else {\n                        keySystemAccess = event.data;\n                        self.debug.log(\"[DRM] KeySystem Access (\" + keySystemAccess.keySystem.systemString + \") Granted!  Selecting key system...\");\n                        self.protectionModel.selectKeySystem(keySystemAccess);\n                    }\n                };\n                ksSelected[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED] = function(event) {\n                    if (!self.protectionModel) {\n                        return;\n                    }\n                    self.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED, ksSelected);\n                    if (!event.error) {\n                        self.debug.log(\"[DRM] KeySystem selected => create key session\");\n                        self.keySystem = self.protectionModel.keySystem;\n                        self.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_KEY_SYSTEM_SELECTED, keySystemAccess);\n                        self.eventBus.dispatchEvent({\n                            type: MediaPlayer.dependencies.ProtectionController.events.KEY_SYSTEM_SELECTED,\n                            data: keySystemAccess\n                        });\n                        for (i = 0; i < pendingNeedKeyData.length; i++) {\n                            for (ksIdx = 0; ksIdx < pendingNeedKeyData[i].length; ksIdx++) {\n                                if (self.keySystem === pendingNeedKeyData[i][ksIdx].ks) {\n                                    self.createKeySession(pendingNeedKeyData[i][ksIdx].initData, pendingNeedKeyData[i][ksIdx].cdmData);\n                                    break;\n                                }\n                            }\n                        }\n                    } else {\n                        self.keySystem = undefined;\n                        if (!fromManifest) {\n                            self.eventBus.dispatchEvent({\n                                type: MediaPlayer.dependencies.ProtectionController.events.KEY_SYSTEM_SELECTED,\n                                error: \"[DRM] Error selecting key system! -- \" + event.error\n                            });\n                        }\n                        self.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,\n                            new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYSYSERR_ACCESS_DENIED, \"No KeySystem/CDM available\", {keySystems: keySystemsInfo}));\n\n                    }\n                };\n                this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED, ksSelected, undefined, true);\n                this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE, ksSelected, undefined, true);\n\n                this.protectionModel.requestKeySystemAccess(requestedKeySystems);\n            } else {\n                // We are in the process of selecting a key system, so just save the data\n                pendingNeedKeyData.push(supportedKS);\n            }\n        },\n\n        /*sendLicenseRequestCompleteEvent = function(data) {\n            this.eventBus.dispatchEvent({\n                type: MediaPlayer.dependencies.ProtectionController.events.LICENSE_REQUEST_COMPLETE,\n                data: data\n            });\n        },*/\n\n        onKeyMessage = function(e) {\n            var self = this,\n                licenseMessage = null,\n                keyMessage,\n                messageType;\n\n            keyMessage = e.data;\n            messageType = (keyMessage.messageType) ? keyMessage.messageType : \"license-request\";\n            this.debug.log(\"[DRM] Key message: type = \" + messageType);\n\n            // Dispatch event to applications indicating we received a key message\n            this.eventBus.dispatchEvent({\n                type: MediaPlayer.dependencies.ProtectionController.events.KEY_MESSAGE,\n                data: keyMessage\n            });\n\n            var message = keyMessage.message,\n                sessionToken = keyMessage.sessionToken,\n                protData = getProtData(this.keySystem),\n                keySystemString = this.keySystem.systemString,\n                licenseServerData = this.protectionExt.getLicenseServer(this.keySystem, protData, messageType),\n                needFailureReport = true/*,\n                eventData = {\n                    sessionToken: sessionToken,\n                    messageType: messageType\n                }*/;\n\n            // Ensure message from CDM is not empty\n            if (!message || message.byteLength === 0) {\n                this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,\n                    new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_NO_CHALLENGE, \"Empty key message from CDM\"));\n                return;\n            }\n\n            // Message not destined for license server\n            if (!licenseServerData) {\n                this.debug.log(\"[DRM] License server request not required for this message (type = \" + e.data.messageType + \").  Session ID = \" + sessionToken.getSessionID());\n                return;\n            }\n\n            // Perform any special handling for ClearKey\n            if (this.protectionExt.isClearKey(this.keySystem)) {\n                var clearkeys = this.protectionExt.processClearKeyLicenseRequest(protData, message);\n                if (clearkeys) {\n                    this.debug.log(\"[DRM] ClearKey license request handled by application!\");\n                    this.protectionModel.updateKeySession(sessionToken, clearkeys);\n                    return;\n                }\n            }\n\n            // All remaining key system scenarios require a request to a remote license server\n            xhrLicense = new XMLHttpRequest();\n\n            // Determine license server URL\n            var url = null;\n            if (protData) {\n                if (protData.serverURL) {\n                    var serverURL = protData.serverURL;\n                    if (typeof serverURL === \"string\" && serverURL !== \"\") {\n                        url = serverURL;\n                    } else if (typeof serverURL === \"object\" && serverURL.hasOwnProperty(messageType)) {\n                        url = serverURL[messageType];\n                    }\n                } else if (protData.laURL && protData.laURL !== \"\") { // TODO: Deprecated!\n                    url = protData.laURL;\n                }\n            }\n\n            if (url === null) {\n                url = this.keySystem.getLicenseServerURLFromInitData(MediaPlayer.dependencies.protection.CommonEncryption.getPSSHData(sessionToken.initData));\n                if (!url) {\n                    url = e.data.defaultURL;\n                }\n            }\n            // Possibly update or override the URL based on the message\n            url = licenseServerData.getServerURLFromMessage(url, message, messageType);\n\n            this.debug.log(\"[DRM] Licenser server url: \" + url);\n\n            // Ensure valid license server URL\n            if (!url) {\n                this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,\n                    new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_URL_LICENSER_UNKNOWN, \"No license server URL specified\"));\n                return;\n            }\n\n            xhrLicense.open(licenseServerData.getHTTPMethod(messageType), url, true);\n            xhrLicense.responseType = licenseServerData.getResponseType(keySystemString, messageType);\n            xhrLicense.onload = function() {\n\n                if (this.status < 200 || this.status > 299) {\n                    return;\n                }\n\n                if (this.status === 200 && this.readyState === 4) {\n                    self.debug.log(\"[DRM] Received license response\");\n                    needFailureReport = false;\n                    licenseMessage = licenseServerData.getLicenseMessage(this.response, keySystemString, messageType);\n                    if (licenseMessage !== null) {\n                        needFailureReport = false;\n                        self.protectionModel.updateKeySession(sessionToken, licenseMessage);\n                    } else {\n                        needFailureReport = true;\n                    }\n                }\n            };\n\n            xhrLicense.onerror = xhrLicense.onloadend = function() {\n                if (!needFailureReport) {\n                    xhrLicense = null;\n                    return;\n                }\n                needFailureReport = false;\n\n                // send error only if request has  not been aborted by reset\n                if (!this.aborted) {\n                    self.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,\n                        new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_LICENSER_ERROR, \"License request failed\", {\n                            url: url,\n                            status: this.status,\n                            error: (this.response && this.response !== null) ? licenseServerData.getErrorResponse(this.response) : \"\"\n                        }));\n                }\n                xhrLicense = null;\n            };\n\n            // Set optional XMLHttpRequest headers from protection data and message\n            var updateHeaders = function(headers) {\n                var key;\n                if (headers) {\n                    for (key in headers) {\n                        if ('authorization' === key.toLowerCase()) {\n                            xhrLicense.withCredentials = true;\n                        }\n                        xhrLicense.setRequestHeader(key, headers[key]);\n                    }\n                }\n            };\n            if (protData) {\n                updateHeaders(protData.httpRequestHeaders);\n            }\n            updateHeaders(this.keySystem.getRequestHeadersFromMessage(message));\n\n            // Set withCredentials property from protData\n            if (protData && protData.withCredentials) {\n                xhrLicense.withCredentials = true;\n            }\n\n            this.debug.log(\"[DRM] Send license request\");\n            var licenseRequest = this.keySystem.getLicenseRequestFromMessage(message);\n            if (licenseRequest === null) {\n                this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,\n                    new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_NO_CHALLENGE, \"No license challenge from CDM key message\"));\n            }\n            xhrLicense.send(licenseRequest);\n        },\n\n        onNeedKey = function(event) {\n\n            var self = this,\n                abInitData,\n                supportedKS;\n\n            self.debug.log(\"[DRM] onNeedKey, initDataType = \" + event.data.initDataType);\n\n            // Ignore non-cenc initData\n            if (event.data.initDataType !== \"cenc\") {\n                self.debug.log(\"[DRM] Only 'cenc' initData is supported!  Ignoring initData of type: \" + event.data.initDataType);\n                return;\n            }\n\n            // Some browsers return initData as Uint8Array (IE), some as ArrayBuffer (Chrome).\n            // Convert to ArrayBuffer\n            abInitData = event.data.initData;\n            if (ArrayBuffer.isView(abInitData)) {\n                abInitData = abInitData.buffer;\n            }\n\n            // If key system has already been selected and initData already seen, then do nothing\n            if (this.keySystem) {\n                var initDataForKS = MediaPlayer.dependencies.protection.CommonEncryption.getPSSHForKeySystem(this.keySystem, abInitData);\n                var currentInitData = this.protectionModel.getAllInitData();\n                for (var i = 0; i < currentInitData.length; i++) {\n                    if (this.protectionExt.initDataEquals(initDataForKS, currentInitData[i])) {\n                        this.debug.log(\"[DRM] Ignoring initData because we have already seen it!\");\n                        return;\n                    }\n                }\n            }\n\n            supportedKS = this.protectionExt.getSupportedKeySystems(abInitData);\n            if (supportedKS.length === 0) {\n                self.debug.log(\"[DRM] Received needkey event with initData, but we don't support any of the key systems!\");\n                return;\n            }\n\n            selectKeySystem.call(this, supportedKS, false);\n        },\n\n        onServerCertificateUpdated = function(event) {\n            if (!event.error) {\n                this.debug.log(\"[DRM] License server certificate successfully updated\");\n            } else {\n                this.debug.error(\"[DRM] Failed to set license server certificate\");\n                this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,\n                    new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_SERVER_CERTIFICATE, \"Failed to set server certificate\", event.error));\n            }\n        },\n\n        onKeySessionCreated = function(event) {\n            if (!event.error) {\n                this.debug.log(\"[DRM] Session created.  SessionID = \" + event.data.getSessionID());\n            } else {\n                this.debug.error(\"[DRM] Failed to create key session\");\n                this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,\n                    new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYMESSERR_NO_SESSION, \"Failed to create key session\", event.error));\n            }\n        },\n\n        onKeyAdded = function( /*event*/ ) {\n            this.debug.log(\"[DRM] Key added\");\n        },\n\n        onKeyError = function(event) {\n            this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,\n                new MediaPlayer.vo.Error(event.data.code, event.data.message, event.data.data));\n        },\n\n        onKeySessionClosed = function(event) {\n            if (!event.error) {\n                this.debug.log(\"[DRM] Session closed. SessionID = \" + event.data);\n            } else {\n                this.debug.warn(\"[DRM] Failed to close session\");\n            }\n        },\n\n        onKeySessionRemoved = function(event) {\n            if (!event.error) {\n                this.debug.log(\"[DRM] Session removed. SessionID = \" + event.data);\n            } else {\n                this.debug.warn(\"[DRM] Failed to remove session\");\n            }\n        },\n\n        onKeyStatusesChanged = function(event) {\n            if (!event.error) {\n                this.debug.log(\"[DRM] Key statuses changed. statuses = \" + event.data);\n            } else {\n                this.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,\n                    new MediaPlayer.vo.Error(event.error.code, event.error.message, event.error.data));\n            }\n        };\n\n    return {\n        system: undefined,\n        debug: undefined,\n        notify: undefined,\n        subscribe: undefined,\n        unsubscribe: undefined,\n        protectionExt: undefined,\n        keySystem: undefined,\n\n        setup: function() {\n            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_MESSAGE] = onKeyMessage.bind(this);\n            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_NEED_KEY] = onNeedKey.bind(this);\n            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_SERVER_CERTIFICATE_UPDATED] = onServerCertificateUpdated.bind(this);\n            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ADDED] = onKeyAdded.bind(this);\n            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ERROR] = onKeyError.bind(this);\n            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED] = onKeySessionCreated.bind(this);\n            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CLOSED] = onKeySessionClosed.bind(this);\n            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_REMOVED] = onKeySessionRemoved.bind(this);\n            this[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_STATUSES_CHANGED] = onKeyStatusesChanged.bind(this);\n\n            keySystems = this.protectionExt.getKeySystems();\n            this.protectionModel = this.system.getObject(\"protectionModel\");\n            this.protectionModel.init();\n\n            this.eventBus = this.system.getObject(\"eventBus\");\n\n            // Subscribe to events\n            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_SERVER_CERTIFICATE_UPDATED, this);\n            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ADDED, this);\n            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ERROR, this);\n            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED, this);\n            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CLOSED, this);\n            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_REMOVED, this);\n            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_MESSAGE, this);\n            this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_STATUSES_CHANGED, this);\n        },\n\n        /**\n         * Initialize this protection system with a given manifest and optional audio\n         * and video stream information.\n         *\n         * @param {Object} manifest the json version of the manifest XML document for the\n         * desired content.  Applications can download their manifest using\n         * {@link MediaPlayer#retrieveManifest}\n         * @param {MediaPlayer.vo.StreamInfo} [aInfo] audio stream information\n         * @param {MediaPlayer.vo.StreamInfo} [vInfo] video stream information\n         * @memberof MediaPlayer.dependencies.ProtectionController\n         * @instance\n         * @todo This API will change when we have better support for allowing applications\n         * to select different adaptation sets for playback.  Right now it is clunky for\n         * applications to create {@link MediaPlayer.vo.StreamInfo} with the right information,\n         */\n        init: function(contentProtection, aCodec, vCodec) {\n            var supportedKS;\n            // TODO: We really need to do much more here... We need to be smarter about knowing\n            // which adaptation sets for which we have initialized, including the default key ID\n            // value from the ContentProtection elements so we know whether or not we still need to\n            // select key systems and acquire keys.\n            if (!initialized) {\n\n                this.debug.log(\"[DRM] Initialize ProtectionController (\" + vCodec + \", \" + aCodec + \")\");\n\n                audioCodec = aCodec;\n                videoCodec = vCodec;\n\n                // ContentProtection elements are specified at the AdaptationSet level, so the CP for audio\n                // and video will be the same.  Just use one valid MediaInfo object\n                supportedKS = this.protectionExt.getSupportedKeySystemsFromContentProtection(contentProtection);\n                if (supportedKS && supportedKS.length > 0) {\n                    selectKeySystem.call(this, supportedKS, true);\n                }\n\n                initialized = true;\n            }\n        },\n\n        /**\n         * ProtectionController Event Listener\n         *\n         * @callback MediaPlayer.dependencies.ProtectionController~eventListener\n         * @param {Object} event The event.  See the documentation for ProtectionController\n         * APIs to see what events are fired by each API call\n         */\n\n        /**\n         * Add a listener for ProtectionController events\n         *\n         * @param type the event ID\n         * @param {MediaPlayer.dependencies.ProtectionController~eventListener} listener\n         * the event listener to add\n         * @see MediaPlayer.dependencies.ProtectionController.events\n         * @memberof MediaPlayer.dependencies.ProtectionController\n         * @instance\n         */\n        addEventListener: function(type, listener) {\n            this.eventBus.addEventListener(type, listener);\n        },\n\n        /**\n         * Remove a listener for ProtectionController events\n         *\n         * @param type the event ID associated with the listener to rmove\n         * @param {MediaPlayer.dependencies.ProtectionController~eventListener} listener\n         * the event listener to remove\n         * @memberof MediaPlayer.dependencies.ProtectionController\n         * @instance\n         */\n        removeEventListener: function(type, listener) {\n            this.eventBus.removeEventListener(type, listener);\n        },\n\n        /**\n         * Destroys all protection data associated with this protection set.  This includes\n         * deleting all key sessions.  In the case of persistent key sessions, the sessions\n         * will simply be unloaded and not deleted.  Additionally, if this protection set is\n         * associated with a HTMLMediaElement, it will be detached from that element.\n         *\n         * @memberof MediaPlayer.dependencies.ProtectionController\n         * @instance\n         */\n        teardown: function() {\n            var self = this;\n\n            // abort request if xhrLicense is different from null\n            if (xhrLicense) {\n                xhrLicense.aborted = true;\n                xhrLicense.abort();\n            }\n            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_MESSAGE, this);\n            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_SERVER_CERTIFICATE_UPDATED, this);\n            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ADDED, this);\n            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ERROR, this);\n            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED, this);\n            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CLOSED, this);\n            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_REMOVED, this);\n            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_MESSAGE, this);\n            this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_STATUSES_CHANGED, this);\n\n            this.keySystem = undefined;\n\n            this.setMediaElement(null).then(function() {\n                self.protectionModel.teardown();\n                self.protectionModel = undefined;\n            });\n        },\n\n        /**\n         * Create a new key session associated with the given initialization data from\n         * the MPD or from the PSSH box in the media\n         *\n         * @param {ArrayBuffer} initData the initialization data\n         * @param {Uint8Array} cdmData the custom data to provide to licenser\n         * @memberof MediaPlayer.dependencies.ProtectionController\n         * @instance\n         * @fires MediaPlayer.dependencies.ProtectionController#KeySessionCreated\n         * @todo In older versions of the EME spec, there was a one-to-one relationship between\n         * initialization data and key sessions.  That is no longer true in the latest APIs.  This\n         * API will need to modified (and a new \"generateRequest(keySession, initData)\" API created)\n         * to come up to speed with the latest EME standard\n         */\n        createKeySession: function(initData, cdmData) {\n\n            var initDataForKS = MediaPlayer.dependencies.protection.CommonEncryption.getPSSHForKeySystem(this.keySystem, initData),\n                i = 0,\n                currentInitData;\n            if (initDataForKS) {\n\n                this.debug.log('[DRM] create key session for initData:', String.fromCharCode.apply(null, new Uint8Array(initDataForKS)));\n\n                // Check for duplicate initData\n                currentInitData = this.protectionModel.getAllInitData();\n                for (i = 0; i < currentInitData.length; i++) {\n                    if (this.protectionExt.initDataEquals(initDataForKS, currentInitData[i])) {\n                        this.debug.log(\"[DRM] Ignoring initData because we have already seen it!\");\n                        return;\n                    }\n                }\n                try {\n                    this.protectionModel.createKeySession(initDataForKS, this.keySystem.sessionType, cdmData);\n                } catch (ex) {\n                    this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED, null, {\n                        reason: \"Create key session raised en exception\",\n                        error: new MediaPlayer.vo.Error(ex.code, ex.name, ex.message)\n                    });\n                }\n            } else {\n                this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED, null, {\n                    reason: \"needkey/encrypted event contains no initData corresponding to that key system \" + this.keySystem.systemString,\n                    error: null\n                });\n            }\n        },\n\n        /**\n         * Loads a key session with the given session ID from persistent storage.  This\n         * essentially creates a new key session\n         *\n         * @param {string} sessionID\n         * @memberof MediaPlayer.dependencies.ProtectionController\n         * @instance\n         * @fires MediaPlayer.dependencies.ProtectionController#KeySessionCreated\n         */\n        loadKeySession: function(sessionID) {\n            this.protectionModel.loadKeySession(sessionID);\n        },\n\n        /**\n         * Removes the given key session from persistent storage and closes the session\n         * as if {@link MediaPlayer.dependencies.ProtectionController#closeKeySession}\n         * was called\n         *\n         * @param {MediaPlayer.vo.protection.SessionToken} sessionToken the session\n         * token\n         * @memberof MediaPlayer.dependencies.ProtectionController\n         * @instance\n         * @fires MediaPlayer.dependencies.ProtectionController#KeySessionRemoved\n         * @fires MediaPlayer.dependencies.ProtectionController#KeySessionClosed\n         */\n        removeKeySession: function(sessionToken) {\n            this.protectionModel.removeKeySession(sessionToken);\n        },\n\n        /**\n         * Closes the key session and releases all associated decryption keys.  These\n         * keys will no longer be available for decrypting media\n         *\n         * @param {MediaPlayer.vo.protection.SessionToken} sessionToken the session\n         * token\n         * @memberof MediaPlayer.dependencies.ProtectionController\n         * @instance\n         * @fires MediaPlayer.dependencies.ProtectionController#KeySessionClosed\n         */\n        closeKeySession: function(sessionToken) {\n            this.protectionModel.closeKeySession(sessionToken);\n        },\n\n        /**\n         * Sets a server certificate for use by the CDM when signing key messages\n         * intended for a particular license server.  This will fire\n         * an error event if a key system has not yet been selected.\n         *\n         * @param {ArrayBuffer} serverCertificate a CDM-specific license server\n         * certificate\n         * @memberof MediaPlayer.dependencies.ProtectionController\n         * @instance\n         * @fires MediaPlayer.dependencies.ProtectionController#ServerCertificateUpdated\n         */\n        setServerCertificate: function(serverCertificate) {\n            this.protectionModel.setServerCertificate(serverCertificate);\n        },\n\n        /**\n         * Associate this protection system with the given HTMLMediaElement.  This\n         * causes the system to register for needkey/encrypted events from the given\n         * element and provides a destination for setting of MediaKeys\n         *\n         * @param {HTMLMediaElement} element the media element to which the protection\n         * system should be associated\n         * @memberof MediaPlayer.dependencies.ProtectionController\n         * @instance\n         */\n        setMediaElement: function(element) {\n            if (element) {\n                this.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_NEED_KEY, this);\n            } else if (element === null) {\n                this.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_NEED_KEY, this);\n            }\n            return this.protectionModel.setMediaElement(element);\n        },\n\n        /**\n         * Sets the session type to use when creating key sessions.  Either \"temporary\" or\n         * \"persistent-license\".  Default is \"temporary\".\n         *\n         * @param {String} sessionType the session type\n         * @memberof MediaPlayer.dependencies.ProtectionController\n         * @instance\n         */\n        setSessionType: function(sessionType) {\n            if (this.keysystem) {\n                this.keySystem.sessionType = sessionType;\n            }\n        },\n\n        /**\n         * Attach KeySystem-specific data to use for license acquisition with EME\n         *\n         * @param {Object} data an object containing property names corresponding to\n         * key system name strings (e.g. \"org.w3.clearkey\") and associated values\n         * being instances of {@link MediaPlayer.vo.protection.ProtectionData}\n         * @memberof MediaPlayer.dependencies.ProtectionController\n         * @instance\n         */\n        setProtectionData: function(data) {\n            protDataSet = data;\n            this.protectionExt.init(data);\n        }\n    };\n};\n\n/**\n * Key system selection event\n *\n * @event MediaPlayer.dependencies.ProtectionController#KeySystemSelected\n * @type {Object}\n * @property {MediaPlayer.vo.protection.KeySystemAccess} data key system\n * access object that describes the selected key system and associated\n * audio/video codecs and CDM capabilities.  May be null if an error occurred\n * @property {string} error if not null, an error occurred and this object\n * will contain an informative error string describing the failure\n */\n\n/**\n * Key session creation event\n *\n * @event MediaPlayer.dependencies.ProtectionController#KeySessionCreated\n * @type {Object}\n * @property {MediaPlayer.vo.protection.SessionToken} data the session token\n * that can be used to access certain properties of the session.  Also\n * required for other ProtectionController APIs that act on key sessions.\n * @property {string} error if not null, an error occurred and this object\n * will contain an informative error string describing the failure\n */\n\n/**\n * Key session removed event\n *\n * @event MediaPlayer.dependencies.ProtectionController#KeySessionRemoved\n * @type {Object}\n * @property {string} data the session ID of the session that was removed\n * from persistent storage\n * @property {string} error if not null, an error occurred and this object\n * will contain an informative error string describing the failure\n */\n\n/**\n * Key session closed event\n *\n * @event MediaPlayer.dependencies.ProtectionController#KeySessionClosed\n * @type {Object}\n * @property {string} data the session ID of the session that was closed\n * @property {string} error if not null, an error occurred and this object\n * will contain an informative error string describing the failure\n */\n\n/**\n * Server certificate updated event\n *\n * @event MediaPlayer.dependencies.ProtectionController#ServerCertificateUpdated\n * @type {Object}\n * @property {Object} data unused for this event.  The server certificate update\n * was is successful if the \"error\" property of this event is null or undefined\n * @property {string} error if not null, an error occurred and this object\n * will contain an informative error string describing the failure\n */\n\n/**\n * License request completed event\n *\n * @event MediaPlayer.dependencies.ProtectionController#LicenseRequestComplete\n * @type {Object}\n * @property {Object} data The event data.  This data will be provided regardless\n * of the success/failure status of the event\n * @property {MediaPlayer.vo.protection.SessionToken} data.sessionToken session token\n * associated with this license response.  Will never be null, even in error cases.\n * @property {String} data.messageType the message type associated with this request.\n * Supported message types can be found\n * {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}.\n * @property {string} error if not null, an error occurred and this object\n * will contain an informative error string describing the failure\n */\n\n/**\n * Events names for events sent by ProtectionController.  Use these event\n * names when subscribing or unsubscribing from ProtectionController events\n *\n * @enum {String}\n * @see MediaPlayer.dependencies.ProtectionController#addEventListener\n */\nMediaPlayer.dependencies.ProtectionController.events = {\n    /**\n     * Event ID for events delivered when a key system selection procedure\n     * has completed\n     *\n     * @constant\n     */\n    KEY_SYSTEM_SELECTED: \"keySystemSelected\",\n    /**\n     * Event ID for events delivered when the protection set receives\n     * a key message from the CDM\n     *\n     * @constant\n     */\n    SERVER_CERTIFICATE_UPDATED: \"serverCertificateUpdated\",\n    /**\n     * Event ID for events delivered when a new key has been added\n     *\n     * @constant\n     * @deprecated The latest versions of the EME specification no longer\n     * use this event. {@MediaPlayer.dependencies.ProtectionController.events.KEY_STATUSES_CHANGED}\n     * is preferred.\n     */\n    KEY_ADDED: \"keyAdded\",\n    /**\n     * Event ID for events delivered when a new key sessions creation\n     * process has completed\n     *\n     * @constant\n     */\n    KEY_SESSION_CREATED: \"keySessionCreated\",\n    /**\n     * Event ID for events delivered when a key session removal\n     * process has completed\n     *\n     * @constant\n     */\n    KEY_SESSION_REMOVED: \"keySessionRemoved\",\n    /**\n     * Event ID for events delivered when a key session close\n     * process has completed\n     *\n     * @constant\n     */\n    KEY_SESSION_CLOSED: \"keySessionClosed\",\n    /**\n     * Event ID for events delivered when the status of one or more\n     * decryption keys has changed\n     *\n     * @constant\n     */\n    KEY_STATUSES_CHANGED: \"keyStatusesChanged\",\n    /**\n     * Event ID for events delivered when the protection system receives\n     * a key message from the CDM\n     *\n     * @constant\n     */\n    KEY_MESSAGE: \"keyMessage\",\n    /**\n     * Event ID for events delivered when a license request procedure\n     * has completed\n     *\n     * @constant\n     */\n    LICENSE_REQUEST_COMPLETE: \"licenseRequestComplete\"\n};\n\nMediaPlayer.dependencies.ProtectionController.eventList = {\n    ENAME_PROTECTION_ERROR: \"protectionError\",\n    ENAME_KEY_SYSTEM_SELECTED: \"keySystemSelected\"\n};\n\nMediaPlayer.dependencies.ProtectionController.prototype = {\n    constructor: MediaPlayer.dependencies.ProtectionController\n};\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Media protection functionality that can be modified/overridden by applications\n *\n * @class MediaPlayer.dependencies.ProtectionExtensions\n */\nMediaPlayer.dependencies.ProtectionExtensions = function () {\n    \"use strict\";\n\n    this.system = undefined;\n    this.debug = undefined;\n    this.keySystems = [];\n\n    this.clearkeyKeySystem = undefined;\n};\n\nMediaPlayer.dependencies.ProtectionExtensions.prototype = {\n    constructor: MediaPlayer.dependencies.ProtectionExtensions,\n\n    /**\n     * Setup the key systems available in the player\n     */\n    setup: function() {\n        var keySystem;\n\n        // PlayReady\n        keySystem = this.system.getObject(\"ksPlayReady\");\n        this.keySystems.push(keySystem);\n\n        // Widevine\n        keySystem = this.system.getObject(\"ksWidevine\");\n        this.keySystems.push(keySystem);\n\n        // ClearKey\n        keySystem = this.system.getObject(\"ksClearKey\");\n        this.keySystems.push(keySystem);\n        this.clearkeyKeySystem = keySystem;\n    },\n\n    /**\n     * Initialize the available key systems\n     *\n     * @param protectionDataSet object that contains 0 or more ProtectionData\n     * objects.  Each one is identified by an attribute name equal to\n     * to the unique key system string for the DRM to which it is intended\n     */\n    init: function(protectionDataSet) {\n        var getProtectionData = function(keySystemString) {\n            var protData = null;\n            if (protectionDataSet) {\n                protData = (keySystemString in protectionDataSet) ? protectionDataSet[keySystemString] : null;\n            }\n            return protData;\n        };\n\n        for (var i = 0; i < this.keySystems.length; i++) {\n            var keySystem = this.keySystems[i];\n            keySystem.init(getProtectionData(keySystem.systemString));\n        }\n    },\n\n    /**\n     * Returns a prioritized list of key systems supported\n     * by this player (not necessarily those supported by the\n     * user agent)\n     *\n     * @returns {MediaPlayer.dependencies.protection.KeySystem[]} a prioritized\n     * list of key systems\n     */\n    getKeySystems: function() {\n        return this.keySystems;\n    },\n\n    /**\n     * Returns the key system associated with the given key system string\n     * name (i.e. 'org.w3.clearkey')\n     *\n     * @param {string} systemString the system string\n     * @returns {MediaPlayer.dependencies.protection.KeySystem} the key system\n     * or null if no supported key system is associated with the given key\n     * system string\n     */\n    getKeySystemBySystemString: function(systemString) {\n        for (var i = 0; i < this.keySystems.length; i++) {\n            if (this.keySystems[i].systemString === systemString) {\n                return this.keySystems[i];\n            }\n        }\n        return null;\n    },\n\n    /**\n     * Determines whether the given key system is ClearKey.  This is\n     * necessary because the EME spec defines ClearKey and its method\n     * for providing keys to the key session; and this method has changed\n     * between the various API versions.  Our EME-specific ProtectionModels\n     * must know if the system is ClearKey so that it can format the keys\n     * according to the particular spec version.\n     *\n     * @param keySystem the key\n     * @returns {boolean} true if this is the ClearKey key system, false\n     * otherwise\n     */\n    isClearKey: function(keySystem) {\n        return (keySystem === this.clearkeyKeySystem);\n    },\n\n    /**\n     * Check equality of initData array buffers.\n     *\n     * @param initData1 {ArrayBuffer} first initData\n     * @param initData2 {ArrayBuffer} second initData\n     * @returns {boolean} true if the initData arrays are equal in size and\n     * contents, false otherwise\n     */\n    initDataEquals: function(initData1, initData2) {\n        if (initData1.byteLength === initData2.byteLength) {\n            var data1 = new Uint8Array(initData1),\n                data2 = new Uint8Array(initData2);\n            for (var j = 0; j < data1.length; j++) {\n                if (data1[j] !== data2[j]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    },\n\n    /**\n     * Returns a set of supported key systems and CENC intialization data\n     * from the given array of ContentProtection elements.  Only\n     * key systems that are supported by this player will be returned.\n     * Key systems are returned in priority order (highest first).\n     *\n     * @param {Object[]} cps array of content protection elements parsed\n     * from the manifest\n     * @returns {Object[]} array of objects indicating which supported key\n     * systems were found.  Empty array is returned if no\n     * supported key systems were found\n     * @returns {MediaPlayer.dependencies.protection.KeySystem} Object.ks the key\n     * system identified by the ContentProtection element\n     * @returns {ArrayBuffer} Object.initData the initialization data parsed\n     * from the ContentProtection element\n     */\n    getSupportedKeySystemsFromContentProtection: function(cps) {\n        var cp, ks, ksIdx, cpIdx, supportedKS = [];\n\n        if (cps) {\n            for(ksIdx = 0; ksIdx < this.keySystems.length; ++ksIdx) {\n                ks = this.keySystems[ksIdx];\n                for(cpIdx = 0; cpIdx < cps.length; ++cpIdx) {\n                    cp = cps[cpIdx];\n                    if (cp.schemeIdUri.toLowerCase() === ks.schemeIdURI) {\n\n                        //this.debug.log(\"[DRM] Supported key systems: \" + ks.systemString + \" (\" + ks.schemeIdURI + \")\");\n\n                        // Look for DRM-specific ContentProtection\n                        var initData = ks.getInitData(cp);\n                        if (!!initData) {\n                            supportedKS.push({\n                                ks: this.keySystems[ksIdx],\n                                initData: initData,\n                                cdmData: ks.getCDMData()\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        return supportedKS;\n    },\n\n    /**\n     * Returns key systems supported by this player for the given PSSH\n     * initializationData. Only key systems supported by this player\n     * will be returned.  Key systems are returned in priority order\n     * (highest priority first)\n     *\n     * @param {ArrayBuffer} initData Concatenated PSSH data for all DRMs\n     * supported by the content\n     * @returns {Object[]} array of objects indicating which supported key\n     * systems were found.  Empty array is returned if no\n     * supported key systems were found\n     * @returns {MediaPlayer.dependencies.protection.KeySystem} Object.ks the key\n     * system\n     * @returns {ArrayBuffer} Object.initData the initialization data\n     * associated with the key system\n     */\n    getSupportedKeySystems: function(initData) {\n        var ksIdx, supportedKS = [],\n                pssh = MediaPlayer.dependencies.protection.CommonEncryption.parsePSSHList(initData);\n\n        this.debug.log(\"[DRM] Get supported key systems from init data\");\n\n        for (ksIdx = 0; ksIdx < this.keySystems.length; ++ksIdx) {\n            if (this.keySystems[ksIdx].uuid in pssh) {\n                //this.debug.log(\"[DRM] Add supported key system: \" + this.keySystems[ksIdx].systemString);\n                supportedKS.push({\n                    ks: this.keySystems[ksIdx],\n                    initData: pssh[this.keySystems[ksIdx].uuid],\n                    cdmData: this.keySystems[ksIdx].getCDMData()\n                });\n            }\n        }\n        return supportedKS;\n    },\n\n    /**\n     * Returns the license server implementation data that should be used for this request.\n     *\n     * @param {MediaPlayer.dependencies.protection.KeySystem} keySystem the key system\n     * associated with this license request\n     * @param {MediaPlayer.vo.protection.ProtectionData} protData protection data to use for the\n     * request\n     * @param {String} [messageType=\"license-request\"] the message type associated with this\n     * request.  Supported message types can be found\n     * {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}.\n     * @return {MediaPlayer.dependencies.protection.servers.LicenseServer} the license server\n     * implementation that should be used for this request or null if the player should not\n     * pass messages of the given type to a license server\n     *\n     */\n    getLicenseServer: function(keySystem, protData, messageType) {\n\n        // Our default server implementations do not do anything with \"license-release\" or\n        // \"individualization-request\" messages, so we just send a success event\n        if (messageType === \"license-release\" || messageType == \"individualization-request\") {\n            return null;\n        }\n\n        var licenseServerData = null;\n        if (protData && protData.hasOwnProperty(\"drmtoday\")) {\n            licenseServerData = this.system.getObject(\"serverDRMToday\");\n        } else if (keySystem.systemString === \"com.widevine.alpha\") {\n            licenseServerData = this.system.getObject(\"serverWidevine\");\n        } else if (keySystem.systemString === \"com.microsoft.playready\") {\n            licenseServerData = this.system.getObject(\"serverPlayReady\");\n        } else if (keySystem.systemString === \"org.w3.clearkey\") {\n            licenseServerData = this.system.getObject(\"serverClearKey\");\n        }\n\n        return licenseServerData;\n    },\n\n    /**\n     * Allows application-specific retrieval of ClearKey keys.\n     *\n     * @param {MediaPlayer.vo.protection.ProtectionData} protData protection data to use for the\n     * request\n     * @param {ArrayBuffer} message the key message from the CDM\n     * @return {MediaPlayer.vo.protection.ClearKeyKeySet} the clear keys associated with\n     * the request or null if no keys can be returned by this function\n     */\n    processClearKeyLicenseRequest: function(protData, message) {\n        try {\n            return MediaPlayer.dependencies.protection.KeySystem_ClearKey.getClearKeysFromProtectionData(protData, message);\n        } catch (error) {\n            this.log(\"Failed to retrieve clearkeys from ProtectionData\");\n            return null;\n        }\n    },\n\n    /**\n     * Select a key system by using the priority-ordered key systems supported\n     * by the player and the key systems supported by the content\n     *\n     * @param {Object[]} supportedKS supported key systems\n     * @param {MediaPlayer.dependencies.ProtectionController} protectionController\n     * @param {MediaPlayer.vo.MediaInfo} videoInfo video media information\n     * @param {MediaPlayer.vo.MediaInfo} audioInfo audio media information\n     */\n    //autoSelectKeySystem: function(supportedKS, protectionController, videoInfo, audioInfo) {\n    autoSelectKeySystem: function(supportedKS, protectionController, videoCodec, audioCodec) {\n\n        this.debug.log(\"[DRM] Auto select key system: \");\n        this.debug.log(\"[DRM] ---- video codec = \" + videoCodec);\n        this.debug.log(\"[DRM] ---- audio codec = \" + audioCodec);\n\n        // Does the initData contain a key system supported by the player?\n        if (supportedKS.length === 0) {\n            throw new Error(\"DRM system for this content not supported by the player!\");\n        }\n\n        var audioCapabilities = [], videoCapabilities = [];\n        if (videoCodec) {\n            videoCapabilities.push(new MediaPlayer.vo.protection.MediaCapability(videoCodec));\n        }\n        if (audioCodec) {\n            audioCapabilities.push(new MediaPlayer.vo.protection.MediaCapability(audioCodec));\n        }\n        var ksConfig = new MediaPlayer.vo.protection.KeySystemConfiguration(audioCapabilities, videoCapabilities);\n        var requestedKeySystems = [];\n        for (var i = 0; i < supportedKS.length; i++) {\n            requestedKeySystems.push({ ks: supportedKS[i].ks, configs: [ksConfig] });\n        }\n\n        // Since ProtectionExtensions is a singleton, we need to create an IIFE to wrap the\n        // event callback and save the values of protectionModel and protectionController.\n        var self = this;\n        (function(protCtrl) {\n\n            // Callback object for KEY_SYSTEM_ACCESS_COMPLETE event\n            var cbObj = {};\n\n            // Subscribe for event and then perform request\n            cbObj[MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE] = function(event) {\n                protCtrl.protectionModel.unsubscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE, this);\n                if (!event.error) {\n                    var keySystemAccess = event.data;\n                    self.debug.log(\"[DRM] KeySystem Access Granted (\" + keySystemAccess.keySystem.systemString + \")!\");\n                    protCtrl.selectKeySystem(keySystemAccess);\n                } else {\n                    self.debug.log(event.error);\n                    protCtrl.notify(MediaPlayer.dependencies.ProtectionController.eventList.ENAME_PROTECTION_ERROR,\n                        new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYSYSERR_ACCESS_DENIED, \"[DRM] KeySystem Access Denied! -- \" + event.error, null));\n                }\n            };\n\n            protCtrl.protectionModel.subscribe(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE, cbObj);\n            protCtrl.requestKeySystemAccess(requestedKeySystems);\n\n        })(protectionController);\n    }\n};\n\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Initial implementation of EME\n *\n * Implemented by Google Chrome prior to v36\n *\n * @implements MediaPlayer.models.ProtectionModel\n * @class\n */\nMediaPlayer.models.ProtectionModel_01b = function () {\n\n    var videoElement = null,\n\n        // API names object selected for this user agent\n        api = null,\n\n        // With this version of the EME APIs, sessionIDs are not assigned to\n        // sessions until the first key message is received.  We are assuming\n        // that in the case of multiple sessions, key messages will be received\n        // in the order that generateKeyRequest() is called.\n\n        // Holding spot for newly-created sessions until we determine whether or\n        // not the CDM supports sessionIDs\n        pendingSessions = [],\n\n        // List of sessions that have been initialized.  Only the first position will\n        // be used in the case that the CDM does not support sessionIDs\n        sessions = [],\n\n        // Not all CDMs support the notion of sessionIDs.  Without sessionIDs\n        // there is no way for us to differentiate between sessions, therefore\n        // we must only allow a single session.  Once we receive the first key\n        // message we can set this flag to determine if more sessions are allowed\n        moreSessionsAllowed,\n\n        // This is our main event handler for all desired HTMLMediaElement events\n        // related to EME.  These events are translated into our API-independent\n        // versions of the same events\n        createEventHandler = function() {\n            var self = this;\n            return {\n                handleEvent: function(event) {\n                    var sessionToken = null;\n                    switch (event.type) {\n\n                        case api.needkey:\n                            var initData = ArrayBuffer.isView(event.initData) ? event.initData.buffer : event.initData;\n                            self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_NEED_KEY,\n                                new MediaPlayer.vo.protection.NeedKey(initData, \"cenc\"));\n                            break;\n\n                        case api.keyerror:\n                            sessionToken = findSessionByID(sessions, event.sessionId);\n                            if (!sessionToken) {\n                                sessionToken = findSessionByID(pendingSessions, event.sessionId);\n                            }\n\n                            if (sessionToken) {\n                                var code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR,\n                                    msg = \"MediakeyError\";\n                                switch (event.errorCode.code) {\n                                    case 1:\n                                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_UNKNOWN;\n                                        msg += \"An unspecified error occurred. This value is used for errors that don't match any of the other codes.\";\n                                        break;\n                                    case 2:\n                                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_CLIENT;\n                                        msg += \"The Key System could not be installed or updated.\";\n                                        break;\n                                    case 3:\n                                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_SERVICE;\n                                        msg += \"The message passed into update indicated an error from the license service.\";\n                                        break;\n                                    case 4:\n                                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_OUTPUT;\n                                        msg += \"There is no available output device with the required characteristics for the content protection system.\";\n                                        break;\n                                    case 5:\n                                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_HARDWARECHANGE;\n                                        msg += \"A hardware configuration change caused a content protection error.\";\n                                        break;\n                                    case 6:\n                                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_DOMAIN;\n                                        msg += \"An error occurred in a multi-device domain licensing configuration. The most common error is a failure to join the domain.\";\n                                        break;\n                                }\n                                if (event.systemCode) {\n                                    msg += \"  (System Code = \" + event.systemCode + \")\";\n                                }\n                                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ERROR, new MediaPlayer.vo.protection.KeyError(code, msg));\n                            } else {\n                                self.log(\"No session token found for key error\");\n                            }\n                            break;\n\n                        case api.keyadded:\n                            sessionToken = findSessionByID(sessions, event.sessionId);\n                            if (!sessionToken) {\n                                sessionToken = findSessionByID(pendingSessions, event.sessionId);\n                            }\n\n                            if (sessionToken) {\n                                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ADDED, sessionToken);\n                            } else {\n                                self.log(\"No session token found for key added\");\n                            }\n                            break;\n\n                        case api.keymessage:\n\n                            // If this CDM does not support session IDs, we will be limited\n                            // to a single session\n                            moreSessionsAllowed = (event.sessionId !== null) && (event.sessionId !== undefined);\n\n                            // SessionIDs supported\n                            if (moreSessionsAllowed) {\n\n                                // Attempt to find an uninitialized token with this sessionID\n                                sessionToken = findSessionByID(sessions, event.sessionId);\n                                if (!sessionToken && pendingSessions.length > 0) {\n\n                                    // This is the first message for our latest session, so set the\n                                    // sessionID and add it to our list\n                                    sessionToken = pendingSessions.shift();\n                                    sessions.push(sessionToken);\n                                    sessionToken.sessionID = event.sessionId;\n                                }\n                            } else if (pendingSessions.length > 0) { // SessionIDs not supported\n\n                                sessionToken = pendingSessions.shift();\n                                sessions.push(sessionToken);\n\n                                if (pendingSessions.length !== 0) {\n                                    self.errHandler.mediaKeyMessageError(\"Multiple key sessions were creates with a user-agent that does not support sessionIDs!! Unpredictable behavior ahead!\");\n                                }\n                            }\n\n                            if (sessionToken) {\n                                var message = ArrayBuffer.isView(event.message) ? event.message.buffer : event.message;\n\n                                // For ClearKey, the spec mandates that you pass this message to the\n                                // addKey method, so we always save it to the token since there is no\n                                // way to tell which key system is in use\n                                sessionToken.keyMessage = message;\n\n                                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_MESSAGE,\n                                    new MediaPlayer.vo.protection.KeyMessage(sessionToken, message, event.defaultURL));\n                            } else {\n                                self.log(\"No session token found for key message\");\n                            }\n                            break;\n                    }\n                }\n            };\n        },\n        eventHandler = null,\n\n        /**\n         * Helper function to retrieve the stored session token based on a given\n         * sessionID value\n         *\n         * @param sessionArray {Array} the array of sessions to search\n         * @param sessionID the sessionID to search for\n         * @returns {*} the session token with the given sessionID\n         */\n        findSessionByID = function(sessionArray, sessionID) {\n\n            if (!sessionID || !sessionArray) {\n                return null;\n            } else {\n                var len = sessionArray.length;\n                for (var i = 0; i < len; i++) {\n                    if (sessionArray[i].sessionID === sessionID) {\n                        return sessionArray[i];\n                    }\n                }\n                return null;\n            }\n        },\n\n        removeEventListeners = function() {\n            videoElement.removeEventListener(api.keyerror, eventHandler);\n            videoElement.removeEventListener(api.needkey, eventHandler);\n            videoElement.removeEventListener(api.keymessage, eventHandler);\n            videoElement.removeEventListener(api.keyadded, eventHandler);\n        };\n\n    return {\n        system: undefined,\n        log: undefined,\n        errHandler: undefined,\n        notify: undefined,\n        subscribe: undefined,\n        unsubscribe: undefined,\n        protectionExt: undefined,\n        keySystem: null,\n\n        setup: function() {\n            eventHandler = createEventHandler.call(this);\n        },\n\n        /**\n         * Initialize this protection model\n         */\n        init: function() {\n            var tmpVideoElement = document.createElement(\"video\");\n            api = MediaPlayer.models.ProtectionModel_01b.detect(tmpVideoElement);\n        },\n\n        teardown: function() {\n            if (videoElement) {\n                removeEventListeners();\n            }\n            for (var i = 0; i < sessions.length; i++) {\n                this.closeKeySession(sessions[i]);\n            }\n            this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_TEARDOWN_COMPLETE);\n        },\n\n        getAllInitData: function() {\n            var i, retVal = [];\n            for (i = 0; i < pendingSessions.length; i++) {\n                retVal.push(pendingSessions[i].initData);\n            }\n            for (i = 0; i < sessions.length; i++) {\n                retVal.push(sessions[i].initData);\n            }\n            return retVal;\n        },\n\n        requestKeySystemAccess: function(ksConfigurations) {\n            var ve = videoElement;\n            if (!ve) { // Must have a video element to do this capability tests\n                ve = document.createElement(\"video\");\n            }\n\n            // Try key systems in order, first one with supported key system configuration\n            // is used\n            var found = false;\n            for (var ksIdx = 0; ksIdx < ksConfigurations.length; ksIdx++) {\n                var systemString = ksConfigurations[ksIdx].ks.systemString;\n                var configs = ksConfigurations[ksIdx].configs;\n                var supportedAudio = null;\n                var supportedVideo = null;\n\n                // Try key system configs in order, first one with supported audio/video\n                // is used\n                for (var configIdx = 0; configIdx < configs.length; configIdx++) {\n                    //var audios = configs[configIdx].audioCapabilities;\n                    var videos = configs[configIdx].videoCapabilities;\n\n                    // Look for supported audio container/codecs\n                    /*\n                    if (audios && audios.length !== 0) {\n                        supportedAudio = []; // Indicates that we have a requested audio config\n                        for (var audioIdx = 0; audioIdx < audios.length; audioIdx++) {\n                            if (ve.canPlayType(audios[audioIdx].contentType, systemString) !== \"\") {\n                                supportedAudio.push(audios[audioIdx]);\n                            }\n                        }\n                    }\n                    */\n\n                    // Look for supported video container/codecs\n                    if (videos && videos.length !== 0) {\n                        supportedVideo = []; // Indicates that we have a requested video config\n                        for (var videoIdx = 0; videoIdx < videos.length; videoIdx++) {\n                            if (ve.canPlayType(videos[videoIdx].contentType, systemString) !== \"\") {\n                                supportedVideo.push(videos[videoIdx]);\n                            }\n                        }\n                    }\n\n                    // No supported audio or video in this configuration OR we have\n                    // requested audio or video configuration that is not supported\n                    if ((!supportedAudio && !supportedVideo) ||\n                            (supportedAudio && supportedAudio.length === 0) ||\n                            (supportedVideo && supportedVideo.length === 0)) {\n                        continue;\n                    }\n\n                    // This configuration is supported\n                    found = true;\n                    var ksConfig = new MediaPlayer.vo.protection.KeySystemConfiguration(supportedAudio, supportedVideo);\n                    var ks = this.protectionExt.getKeySystemBySystemString(systemString);\n                    var ksAccess = new MediaPlayer.vo.protection.KeySystemAccess(ks, ksConfig);\n                    this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE,\n                            ksAccess);\n                    break;\n                }\n            }\n            if (!found) {\n                this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE,\n                        null, \"Key system access denied! -- No valid audio/video content configurations detected!\");\n            }\n        },\n\n        selectKeySystem: function(keySystemAccess) {\n            this.keySystem = keySystemAccess.keySystem;\n            this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED);\n        },\n\n        setMediaElement: function(mediaElement) {\n            if (videoElement === mediaElement) {\n                return;\n            }\n\n            // Replacing the previous element\n            if (videoElement) {\n                removeEventListeners();\n            }\n\n            videoElement = mediaElement;\n\n            // Only if we are not detaching from the existing element\n            if (videoElement) {\n                videoElement.addEventListener(api.keyerror, eventHandler);\n                videoElement.addEventListener(api.needkey, eventHandler);\n                videoElement.addEventListener(api.keymessage, eventHandler);\n                videoElement.addEventListener(api.keyadded, eventHandler);\n                this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_VIDEO_ELEMENT_SELECTED);\n            }\n\n            return Q.when();\n        },\n\n        createKeySession: function(initData /*, keySystemType */) {\n\n            if (!this.keySystem) {\n                throw new Error(\"Can not create sessions until you have selected a key system\");\n            }\n\n            // Determine if creating a new session is allowed\n            if (moreSessionsAllowed || sessions.length === 0) {\n\n                var newSession = { // Implements MediaPlayer.vo.protection.SessionToken\n                    sessionID: null,\n                    initData: initData,\n\n                    getSessionID: function() {\n                        return this.sessionID;\n                    },\n\n                    getExpirationTime: function() {\n                        return NaN;\n                    },\n\n                    getSessionType: function() {\n                        return \"temporary\";\n                    }\n                };\n                pendingSessions.push(newSession);\n\n                // Send our request to the CDM\n                videoElement[api.generateKeyRequest](this.keySystem.systemString, new Uint8Array(initData));\n\n                return newSession;\n\n            } else {\n                throw new Error(\"Multiple sessions not allowed!\");\n            }\n\n        },\n\n        updateKeySession: function(sessionToken, message) {\n            var sessionID = sessionToken.sessionID;\n            if (!this.protectionExt.isClearKey(this.keySystem)) {\n                // Send our request to the CDM\n                videoElement[api.addKey](this.keySystem.systemString,\n                        new Uint8Array(message), sessionToken.initData, sessionID);\n            } else {\n                // For clearkey, message is a MediaPlayer.vo.protection.ClearKeyKeySet\n                for (var i = 0; i < message.keyPairs.length; i++) {\n                    videoElement[api.addKey](this.keySystem.systemString,\n                            message.keyPairs[i].key, message.keyPairs[i].keyID, sessionID);\n                }\n            }\n        },\n\n        closeKeySession: function(sessionToken) {\n            // Send our request to the CDM\n            videoElement[api.cancelKeyRequest](this.keySystem.systemString, sessionToken.sessionID);\n        },\n\n        setServerCertificate: function(/*serverCertificate*/) { /* Not supported */ },\n\n        loadKeySession: function(/*sessionID*/) { /* Not supported */ },\n\n        removeKeySession: function(/*sessionToken*/) { /* Not supported */ },\n\n        checkIfEncrypted: function() { /* Not supported */ }\n    };\n};\n\nMediaPlayer.models.ProtectionModel_01b.prototype = {\n    constructor: MediaPlayer.models.ProtectionModel_01b\n};\n\n// Defines the supported 0.1b API variations\nMediaPlayer.models.ProtectionModel_01b.APIs = [\n    // Un-prefixed as per spec\n    {\n        // Video Element\n        generateKeyRequest: \"generateKeyRequest\",\n        addKey: \"addKey\",\n        cancelKeyRequest: \"cancelKeyRequest\",\n\n        // Events\n        needkey: \"needkey\",\n        keyerror: \"keyerror\",\n        keyadded: \"keyadded\",\n        keymessage: \"keymessage\"\n    },\n    // Webkit-prefixed (early Chrome versions and Chrome with EME disabled in chrome://flags)\n    {\n        // Video Element\n        generateKeyRequest: \"webkitGenerateKeyRequest\",\n        addKey: \"webkitAddKey\",\n        cancelKeyRequest: \"webkitCancelKeyRequest\",\n\n        // Events\n        needkey: \"webkitneedkey\",\n        keyerror: \"webkitkeyerror\",\n        keyadded: \"webkitkeyadded\",\n        keymessage: \"webkitkeymessage\"\n    }\n];\n\n/**\n * Detects presence of EME v0.1b APIs\n *\n * @param videoElement {HTMLMediaElement} the media element that will be\n * used for detecting APIs\n * @returns an API object that is used when initializing the ProtectionModel\n * instance, or null if this EME version is not supported\n */\nMediaPlayer.models.ProtectionModel_01b.detect = function(videoElement) {\n    var apis = MediaPlayer.models.ProtectionModel_01b.APIs;\n    for (var i = 0; i < apis.length; i++) {\n        var api = apis[i];\n        if (typeof videoElement[api.generateKeyRequest] !== 'function') {\n            continue;\n        }\n        if (typeof videoElement[api.addKey] !== 'function') {\n            continue;\n        }\n        if (typeof videoElement[api.cancelKeyRequest] !== 'function') {\n            continue;\n        }\n        return api;\n    }\n\n    return null;\n};\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Implementation of the EME APIs as of the 3 Feb 2014 state of the specification.\n *\n * Implemented by Internet Explorer 11 (Windows 8.1)\n *\n * @implements MediaPlayer.models.ProtectionModel\n * @class\n */\nMediaPlayer.models.ProtectionModel_3Feb2014 = function () {\n\n    var videoElement = null,\n        mediaKeys = null,\n        keySystemAccess = null,\n        boundDoSetKeys = null,\n\n        // API names object selected for this user agent\n        api = null,\n\n        // Session list\n        sessions = [],\n\n        // This is our main event handler for all desired HTMLMediaElement events\n        // related to EME.  These events are translated into our API-independent\n        // versions of the same events\n        createEventHandler = function() {\n            var self = this;\n            return {\n                handleEvent: function(event) {\n                    switch (event.type) {\n\n                        case api.needkey:\n                            if (event.initData) {\n                                var initData = ArrayBuffer.isView(event.initData) ? event.initData.buffer : event.initData;\n                                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_NEED_KEY,\n                                        new MediaPlayer.vo.protection.NeedKey(initData, \"cenc\"));\n                            }\n                            break;\n                    }\n                }\n            };\n        },\n        eventHandler = null,\n\n        // IE11 does not let you set MediaKeys until it has entered a certain\n        // readyState, so we need this logic to ensure we don't set the keys\n        // too early\n        setMediaKeys = function() {\n            var doSetKeys = function() {\n                videoElement.removeEventListener(\"loadedmetadata\", boundDoSetKeys);\n                videoElement[api.setMediaKeys](mediaKeys);\n                this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_VIDEO_ELEMENT_SELECTED);\n            };\n            if (videoElement.readyState >= 1) {\n                doSetKeys.call(this);\n            } else {\n                boundDoSetKeys = doSetKeys.bind(this);\n                videoElement.addEventListener(\"loadedmetadata\", boundDoSetKeys);\n            }\n\n        },\n\n        getKeyError = function(event) {\n            var code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR,\n                msg = \"MediakeyError\";\n\n            if (event.errorCode) {\n                switch (event.errorCode.code) {\n                    case 1:\n                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_UNKNOWN;\n                        msg = \"An unspecified error occurred. This value is used for errors that don't match any of the other codes.\";\n                        break;\n                    case 2:\n                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_CLIENT;\n                        msg = \"The Key System could not be installed or updated.\";\n                        break;\n                    case 3:\n                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_SERVICE;\n                        msg = \"The message passed into update indicated an error from the license service.\";\n                        break;\n                    case 4:\n                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_OUTPUT;\n                        msg = \"There is no available output device with the required characteristics for the content protection system.\";\n                        break;\n                    case 5:\n                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_HARDWARECHANGE;\n                        msg += \"A hardware configuration change caused a content protection error.\";\n                        break;\n                    case 6:\n                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_DOMAIN;\n                        msg = \"An error occurred in a multi-device domain licensing configuration. The most common error is a failure to join the domain.\";\n                        break;\n                    default:\n                        code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_UNKNOWN;\n                        msg = \"An unspecified error occurred. This value is used for errors that don't match any of the other codes.\";\n                        break;\n                }\n            } else {\n                code = MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_UNKNOWN;\n                msg = \"An unspecified error occurred. This value is used for errors that don't match any of the other codes.\";                \n            }\n            if (event.systemCode) {\n                msg += \"  (System Code = \" + event.systemCode + \")\";\n            }\n            return new MediaPlayer.vo.protection.KeyError(code, msg);\n        },\n\n        // Function to create our session token objects which manage the EME\n        // MediaKeySession and session-specific event handler\n        createSessionToken = function(keySession, initData) {\n            var self = this;\n            return { // Implements MediaPlayer.vo.protection.SessionToken\n                session: keySession,\n                initData: initData,\n\n                // This is our main event handler for all desired MediaKeySession events\n                // These events are translated into our API-independent versions of the\n                // same events\n                handleEvent: function(event) {\n                    switch (event.type) {\n\n                        case api.error:\n                            self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ERROR, getKeyError(event));\n                            break;\n\n                        case api.message:\n                            var message = ArrayBuffer.isView(event.message) ? event.message.buffer : event.message;\n                            self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_MESSAGE,\n                                    new MediaPlayer.vo.protection.KeyMessage(this, message, event.destinationURL));\n                            break;\n\n                        case api.ready:\n                            self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ADDED, this);\n                            break;\n\n                        case api.close:\n                            self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CLOSED, this.getSessionID());\n                            break;\n                    }\n                },\n\n                getSessionID: function() {\n                    return this.session.sessionId;\n                },\n\n                getExpirationTime: function() {\n                    return NaN;\n                },\n\n                getSessionType: function() {\n                    return \"temporary\";\n                }\n            };\n        };\n\n    return {\n        system: undefined,\n        notify: undefined,\n        subscribe: undefined,\n        unsubscribe: undefined,\n        protectionExt: undefined,\n        debug: undefined,\n        keySystem: null,\n\n        setup: function() {\n            eventHandler = createEventHandler.call(this);\n        },\n\n        /**\n         * Initialize this protection model\n         */\n        init: function() {\n            var tmpVideoElement = document.createElement(\"video\");\n            api = MediaPlayer.models.ProtectionModel_3Feb2014.detect(tmpVideoElement);\n        },\n\n        teardown: function() {\n            try {\n                for (var i = 0; i < sessions.length; i++) {\n                    this.closeKeySession(sessions[i]);\n                }\n                if (videoElement) {\n                    videoElement.removeEventListener(api.needkey, eventHandler);\n                }\n                this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_TEARDOWN_COMPLETE);\n            } catch (error) {\n                this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_TEARDOWN_COMPLETE,\n                        null, \"Error tearing down key sessions and MediaKeys! -- \" + error.message);\n            }\n        },\n\n        getAllInitData: function() {\n            var retVal = [];\n            for (var i = 0; i < sessions.length; i++) {\n                retVal.push(sessions[i].initData);\n            }\n            return retVal;\n        },\n\n        requestKeySystemAccess: function(ksConfigurations) {\n\n            // Try key systems in order, first one with supported key system configuration\n            // is used\n            var found = false;\n            for (var ksIdx = 0; ksIdx < ksConfigurations.length; ksIdx++) {\n                var systemString = ksConfigurations[ksIdx].ks.systemString;\n                var configs = ksConfigurations[ksIdx].configs;\n                var supportedAudio = null;\n                var supportedVideo = null;\n\n                this.debug.log(\"[DRM][3Feb2014] Request access for key system \" + systemString);\n\n                // Try key system configs in order, first one with supported audio/video\n                // is used\n                for (var configIdx = 0; configIdx < configs.length; configIdx++) {\n                    var audios = configs[configIdx].audioCapabilities;\n                    var videos = configs[configIdx].videoCapabilities;\n\n                    // Look for supported audio container/codecs\n                    if (audios && audios.length !== 0) {\n                        supportedAudio = []; // Indicates that we have a requested audio config\n                        for (var audioIdx = 0; audioIdx < audios.length; audioIdx++) {\n                            if (window[api.MediaKeys].isTypeSupported(systemString, audios[audioIdx].contentType)) {\n                                //this.debug.log(\"[DRM][3Feb2014] audio codec supported: \" + audios[audioIdx].contentType);\n                                supportedAudio.push(audios[audioIdx]);\n                            }\n                        }\n                    }\n\n                    // Look for supported video container/codecs\n                    if (videos && videos.length !== 0) {\n                        supportedVideo = []; // Indicates that we have a requested video config\n                        for (var videoIdx = 0; videoIdx < videos.length; videoIdx++) {\n                            if (window[api.MediaKeys].isTypeSupported(systemString, videos[videoIdx].contentType)) {\n                                //this.debug.log(\"[DRM][3Feb2014] video codec supported: \" + videos[audioIdx].contentType);\n                                supportedVideo.push(videos[videoIdx]);\n                            }\n                        }\n                    }\n\n                    // No supported audio or video in this configuration OR we have\n                    // requested audio or video configuration that is not supported\n                    if ((!supportedAudio && !supportedVideo) ||\n                            (supportedAudio && supportedAudio.length === 0) ||\n                            (supportedVideo && supportedVideo.length === 0)) {\n                        continue;\n                    }\n\n                    // This configuration is supported\n                    found = true;\n                    var ksConfig = new MediaPlayer.vo.protection.KeySystemConfiguration(supportedAudio, supportedVideo);\n                    var ks = this.protectionExt.getKeySystemBySystemString(systemString);\n                    var ksAccess = new MediaPlayer.vo.protection.KeySystemAccess(ks, ksConfig);\n                    this.debug.log(\"[DRM][3Feb2014] configuration supported = audio:\" + JSON.stringify(supportedAudio) + \", video:\" + JSON.stringify(supportedVideo));\n                    this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE,\n                            ksAccess);\n                    break;\n                }\n            }\n            if (!found) {\n                this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE,\n                        null, \"[DRM][3Feb2014] Key system access denied! -- No valid audio/video content configurations detected!\");\n            }\n        },\n\n        selectKeySystem: function(ksAccess) {\n            this.debug.log(\"[DRM][3Feb2014] Select key system \" + ksAccess.keySystem.systemString);\n            try {\n                mediaKeys = ksAccess.mediaKeys = new window[api.MediaKeys](ksAccess.keySystem.systemString);\n                this.keySystem = ksAccess.keySystem;\n                keySystemAccess = ksAccess;\n                if (videoElement) {\n                    setMediaKeys.call(this);\n                }\n                this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED);\n\n            } catch (error) {\n                this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED,\n                        null, \"Error selecting keys system (\" + this.keySystem.systemString + \")! Could not create MediaKeys -- TODO\");\n            }\n        },\n\n        setMediaElement: function(mediaElement) {\n            if (videoElement === mediaElement)\n                return;\n\n            // Replacing the previous element\n            if (videoElement) {\n                videoElement.removeEventListener(api.needkey, eventHandler);\n                videoElement.removeEventListener(\"loadedmetadata\", boundDoSetKeys);\n            }\n\n            videoElement = mediaElement;\n\n            // Only if we are not detaching from the existing element\n            if (videoElement) {\n                //videoElement.addEventListener(api.needkey, eventHandler);\n                if (mediaKeys) {\n                    setMediaKeys.call(this);\n                }\n            }\n\n            return Q.when();\n        },\n\n        createKeySession: function(initData, sessionType, cdmData) {\n\n            if (!this.keySystem || !mediaKeys || !keySystemAccess) {\n                throw new Error(\"Can not create sessions until you have selected a key system\");\n            }\n\n            this.debug.log(\"[DRM][3Feb2014] Create key session\");\n\n            // Use the first video capability for the contentType.\n            // TODO:  Not sure if there is a way to concatenate all capability data into a RFC6386-compatible format\n            var contentType = keySystemAccess.ksConfiguration.videoCapabilities[0].contentType;\n            var session = mediaKeys.createSession(contentType, new Uint8Array(initData), cdmData ? new Uint8Array(cdmData) : null);\n            var sessionToken = createSessionToken.call(this, session, initData);\n\n            // Add all event listeners\n            session.addEventListener(api.error, sessionToken);\n            session.addEventListener(api.message, sessionToken);\n            session.addEventListener(api.ready, sessionToken);\n            session.addEventListener(api.close, sessionToken);\n\n            // Add to our session list\n            sessions.push(sessionToken);\n\n            this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED, sessionToken);\n        },\n\n        updateKeySession: function(sessionToken, message) {\n\n            var session = sessionToken.session;\n\n            this.debug.log(\"[DRM][3Feb2014] Update key session\");\n\n            if (!this.protectionExt.isClearKey(this.keySystem)) {\n                // Send our request to the key session\n                session.update(new Uint8Array(message));\n            } else {\n                // For clearkey, message is a MediaPlayer.vo.protection.ClearKeyKeySet\n                session.update(new Uint8Array(message.toJWK()));\n            }\n        },\n\n        /**\n         * Close the given session and release all associated keys.  Following\n         * this call, the sessionToken becomes invalid\n         *\n         * @param sessionToken the session token\n         */\n        closeKeySession: function(sessionToken) {\n\n            this.debug.log(\"[DRM][3Feb2014] Close key session, token = \" + sessionToken.session.sessionId);\n\n            var session = sessionToken.session;\n\n            // Remove event listeners\n            session.removeEventListener(api.error, sessionToken);\n            session.removeEventListener(api.message, sessionToken);\n            session.removeEventListener(api.ready, sessionToken);\n            session.removeEventListener(api.close, sessionToken);\n\n            // Remove from our session list\n            for (var i = 0; i < sessions.length; i++) {\n                if (sessions[i] === sessionToken) {\n                    sessions.splice(i,1);\n                    break;\n                }\n            }\n\n            // Send our request to the key session\n            session[api.release]();\n        },\n\n        setServerCertificate: function(/*serverCertificate*/) { /* Not supported */ },\n\n        loadKeySession: function(/*sessionID*/) { /* Not supported */ },\n\n        removeKeySession: function(/*sessionToken*/) { /* Not supported */ },\n\n        checkIfEncrypted: function() { /* Not supported */ }\n\n    };\n};\n\n// Defines the supported 3Feb2014 API variations\nMediaPlayer.models.ProtectionModel_3Feb2014.APIs = [\n    // MS-prefixed (IE11, Windows 8.1)\n    {\n        // Video Element\n        setMediaKeys: \"msSetMediaKeys\",\n\n        // MediaKeys\n        MediaKeys: \"MSMediaKeys\",\n\n        // MediaKeySession\n        release: \"close\",\n\n        // Events\n        needkey: \"msneedkey\",\n        error: \"mskeyerror\",\n        message: \"mskeymessage\",\n        ready: \"mskeyadded\",\n        close: \"mskeyclose\"\n    },\n    \n    // Un-prefixed as per spec\n    // Chrome 38-39 (and some earlier versions) with chrome://flags -- Enable Encrypted Media Extensions\n    {\n        // Video Element\n        setMediaKeys: \"setMediaKeys\",\n\n        // MediaKeys\n        MediaKeys: \"MediaKeys\",\n\n        // MediaKeySession\n        release: \"close\",\n\n        // Events\n        needkey: \"needkey\",\n        error: \"keyerror\",\n        message: \"keymessage\",\n        ready: \"keyadded\",\n        close: \"keyclose\"\n    }\n];\n\n/**\n * Detects presence of EME v3Feb2014 APIs\n *\n * @param videoElement {HTMLMediaElement} the media element that will be\n * used for detecting APIs\n * @returns {Object} an API object that is used when initializing the\n * ProtectionModel instance or null if this EME version is not supported\n */\nMediaPlayer.models.ProtectionModel_3Feb2014.detect = function(videoElement) {\n    var apis = MediaPlayer.models.ProtectionModel_3Feb2014.APIs;\n    for (var i = 0; i < apis.length; i++) {\n        var api = apis[i];\n        if (typeof videoElement[api.setMediaKeys] !== 'function') {\n            continue;\n        }\n        if (typeof window[api.MediaKeys] !== 'function')  {\n            continue;\n        }\n        return api;\n    }\n\n    return null;\n};\n\nMediaPlayer.models.ProtectionModel_3Feb2014.prototype = {\n    constructor: MediaPlayer.models.ProtectionModel_3Feb2014\n};\n\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Most recent EME implementation\n *\n * Implemented by Google Chrome v36+ (Windows, OSX, Linux)\n *\n * @implements MediaPlayer.models.ProtectionModel\n * @class\n */\nMediaPlayer.models.ProtectionModel_21Jan2015 = function () {\n\n    var videoElement = null,\n        mediaKeys = null,\n        eventHandler = null,\n\n        // Session list\n        sessions = [],\n\n        arrayToHexString = function (array) {\n\n            var str = \"[\",\n                i;\n\n            for (i = 0; i < array.length; i++) {\n                str += \"0x\" + array[i].toString(16);\n                if (i < (array.length - 1)) {\n                    str += \",\";\n                }\n            }\n\n            str += \"]\";\n\n            return str;\n        },\n\n        requestKeySystemAccessInternal = function(ksConfigurations, idx) {\n            var self = this;\n\n            if (navigator.requestMediaKeySystemAccess === undefined ||\n                typeof navigator.requestMediaKeySystemAccess !== 'function') {\n                this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE, null, \"Insecure origins are not allowed\");\n                return;\n            }\n\n            (function(i) {\n                var keySystem = ksConfigurations[i].ks;\n                var configs = ksConfigurations[i].configs;\n                self.debug.log(\"[DRM][PM_21Jan2015] requestMediaKeySystemAccess: \" + keySystem.systemString);\n                navigator.requestMediaKeySystemAccess(keySystem.systemString, configs).then(function(mediaKeySystemAccess) {\n\n                    // Chrome 40 does not currently implement MediaKeySystemAccess.getConfiguration()\n                    var configuration = (typeof mediaKeySystemAccess.getConfiguration === 'function') ?\n                            mediaKeySystemAccess.getConfiguration() : null;\n                    var keySystemAccess = new MediaPlayer.vo.protection.KeySystemAccess(keySystem, configuration);\n                    keySystemAccess.mksa = mediaKeySystemAccess;\n                    self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE, keySystemAccess);\n                }).catch(function() {\n                    if (++i < ksConfigurations.length) {\n                        requestKeySystemAccessInternal.call(self, ksConfigurations, i);\n                    } else {\n                        self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_ACCESS_COMPLETE, null, \"Key system access denied!\");\n                    }\n                });\n            })(idx);\n        },\n\n        closeKeySessionInternal = function(sessionToken) {\n            var session = sessionToken.session;\n            // Remove event listeners\n            session.removeEventListener(\"keystatuseschange\", sessionToken);\n            session.removeEventListener(\"message\", sessionToken);\n\n            // Send our request to the key session\n            return session.close();\n        },\n\n        // This is our main event handler for all desired HTMLMediaElement events\n        // related to EME.  These events are translated into our API-independent\n        // versions of the same events\n        createEventHandler = function() {\n            var self = this;\n            return {\n                session : null,\n\n                handleEvent: function(event) {\n                    switch (event.type) {\n                        case \"encrypted\":\n                            self.debug.log(\"[DRM][PM_21Jan2015] 'encrypted' event\");\n                            if (event.initData) {\n                                var initData = ArrayBuffer.isView(event.initData) ? event.initData.buffer : event.initData;\n                                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_NEED_KEY,\n                                        new MediaPlayer.vo.protection.NeedKey(initData, \"cenc\"));\n                            }\n                            break;\n                        case \"waitingforkey\":\n                            self.debug.log(\"[DRM][PM_21Jan2015] 'waitingforkey' event\");\n                            if (this.session !== null && this.session.usable) {\n                                // Widevine CDM doesn't raised error if keys don't match\n                                // The unique way to check if the received license is valid is to track this event and raise an error\n                                // this.session = null;\n                                this.session.usable = false;\n                                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ERROR,\n                                    new MediaPlayer.vo.protection.KeyError(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_ENCRYPTED, \"Media is encrypted and no valid key is available\"));\n                            }\n                        break;\n                    }\n                }\n            };\n        },\n\n        removeSession = function(token) {\n            // Remove from our session list\n            for (var i = 0; i < sessions.length; i++) {\n                if (sessions[i] === token) {\n                    sessions.splice(i, 1);\n                    break;\n                }\n            }\n        },\n\n        // Function to create our session token objects which manage the EME\n        // MediaKeySession and session-specific event handler\n        createSessionToken = function(session, initData, sessionType) {\n            var self = this,\n                setSessionUsable = function (session, usable) {\n                    for (var i = 0; i < sessions.length; i++) {\n                        if (sessions[i].session === session) {\n                            sessions[i].usable = usable;\n                            break;\n                        }\n                    }\n                };\n\n            var token = { // Implements MediaPlayer.vo.protection.SessionToken\n                session: session,\n                initData: initData,\n                usable: false,\n\n                // This is our main event handler for all desired MediaKeySession events\n                // These events are translated into our API-independent versions of the\n                // same events\n                handleEvent: function(event) {\n\n                    switch (event.type) {\n\n                        case \"keystatuseschange\":\n                            self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_STATUSES_CHANGED, this);\n\n                            event.target.keyStatuses.forEach(function() {\n                                // has Edge and Chrome implement different version of keystatues, param are not on same order\n                                var status, keyId;\n                                if (arguments && arguments.length > 0) {\n                                    if (arguments[0]) {\n                                        if (typeof arguments[0] === 'string') {\n                                            status = arguments[0];\n                                        } else {\n                                            keyId = arguments[0];\n                                        }\n                                    }\n\n                                    if (arguments[1]) {\n                                        if (typeof arguments[1] === 'string') {\n                                            status = arguments[1];\n                                        } else {\n                                            keyId = arguments[1];\n                                        }\n                                    }\n                                }\n                                self.debug.log(\"[DRM][PM_21Jan2015] status = \" + status + \" for KID \" + arrayToHexString(new Uint8Array(keyId)));\n                                switch (status) {\n                                    case \"expired\":\n                                        setSessionUsable(event.target, false);\n                                        self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_STATUSES_CHANGED, null,\n                                            new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_EXPIRED, \"License has expired\", null));\n                                        break;\n                                    case \"output-restricted\":\n                                        setSessionUsable(event.target, false);\n                                        self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_STATUSES_CHANGED, null,\n                                            new MediaPlayer.vo.Error(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR_OUTPUT,\n                                                                     \"There is no available output device with the required characteristics for the content protection system\",\n                                                                     null));\n                                        break;\n                                    case \"usable\":\n                                        setSessionUsable(event.target, true);\n                                        // Check 'waitinfforkey' event in case the received license does not apply to current content\n                                        videoElement.addEventListener(\"waitingforkey\", eventHandler);\n                                        break;\n\n                                    //case \"status-pending\":\n                                    default:\n                                        self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_STATUSES_CHANGED,\n                                            {status:status, keyId: keyId});\n                                }\n                            });\n\n                            break;\n\n                        case \"message\":\n                            self.debug.log(\"[DRM][PM_21Jan2015] 'message' event: \", event);\n                            var message = ArrayBuffer.isView(event.message) ? event.message.buffer : event.message;\n                            self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_MESSAGE,\n                                    new MediaPlayer.vo.protection.KeyMessage(this, message, undefined, event.messageType));\n                            break;\n                    }\n                },\n\n                getSessionID: function() {\n                    return this.session.sessionId;\n                },\n\n                getExpirationTime: function() {\n                    return this.session.expiration;\n                },\n\n                getKeyStatuses: function() {\n                    return this.session.keyStatuses;\n                },\n\n                getSessionType: function() {\n                    return sessionType;\n                }\n            };\n\n            // Add all event listeners\n            session.addEventListener(\"keystatuseschange\", token);\n            session.addEventListener(\"message\", token);\n\n            // Register callback for session closed Promise\n            session.closed.then(function () {\n                removeSession(token);\n                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CLOSED,\n                        token.getSessionID());\n            });\n\n            // Add to our session list\n            sessions.push(token);\n\n            return token;\n        };\n\n    return {\n        system: undefined,\n        notify: undefined,\n        subscribe: undefined,\n        unsubscribe: undefined,\n        protectionExt: undefined,\n        keySystem: null,\n        config: null,\n        debug: null,\n\n        setup: function() {\n            eventHandler = createEventHandler.call(this);\n        },\n\n        /**\n         * Initialize this protection model\n         */\n        init: function() {\n            eventHandler.session = null;\n        },\n\n        teardown: function() {\n            var session,\n                nbSessions = sessions.length,\n                i,\n                self = this;\n\n            this.debug.log(\"[DRM][PM_21Jan2015] Teardown\");\n\n            if (!this.config.getParam(\"Protection.licensePersistence\", \"boolean\", false)) {\n                // If license persistence is not enabled, then close sessions and release/delete MediaKeys instance\n                // Called when we are done closing a session.\n                var done = function(session) {\n                    self.debug.log(\"[DRM][PM_21Jan2015] Session closed\");\n                    removeSession(session);\n                    if (i >= (nbSessions - 1)) {\n                        mediaKeys = null;\n                        self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_TEARDOWN_COMPLETE);\n                    }\n                };\n\n                if (nbSessions === 0) {\n                    mediaKeys = null;\n                    this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_TEARDOWN_COMPLETE);\n                    return;\n                }\n\n                for (i = 0; i < nbSessions; i++) {\n                    session = sessions[i];\n                    (function (s) {\n                        self.debug.log(\"[DRM][PM_21Jan2015] Close session \" + session.getSessionID());\n                        // Override closed promise resolver\n                        session.session.closed.then(function () {\n                            done(s);\n                        });\n                        // Close the session and handle errors, otherwise promise resolver above will be called\n                        closeKeySessionInternal(session).catch(function () {\n                            done(s);\n                        });\n                    })(session);\n                }\n            } else {\n                // If license persistence is enabled, then keep usable sessions data and MediaKeys instance\n                for (i = 0; i < sessions.length; i++) {\n                    session = sessions[i];\n                    if (!session.usable) {\n                       sessions.splice(i, 1);\n                       i--;\n                    }\n                }\n                this.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_TEARDOWN_COMPLETE);\n            }\n        },\n\n        getAllInitData: function() {\n            var retVal = [];\n            for (var i = 0; i < sessions.length; i++) {\n                retVal.push(sessions[i].initData);\n            }\n            return retVal;\n        },\n\n        requestKeySystemAccess: function(ksConfigurations) {\n            requestKeySystemAccessInternal.call(this, ksConfigurations, 0);\n        },\n\n        selectKeySystem: function(keySystemAccess) {\n\n            var self = this;\n\n            self.debug.log(\"[DRM][PM_21Jan2015] Select key system, create new MediaKeys\");\n\n            // In case of license persistence we do not reset MediaKeys instance\n            if (mediaKeys !== null) {\n                self.debug.log(\"[DRM][PM_21Jan2015] MediaKeys already created\");\n                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED);\n                return;\n            }\n\n            keySystemAccess.mksa.createMediaKeys().then(function(mkeys) {\n                self.keySystem = keySystemAccess.keySystem;\n                mediaKeys = mkeys;\n                if (videoElement) {\n                    videoElement.setMediaKeys(mediaKeys).then(\n                        function () {\n                            var serverCertificate = self.keySystem.getServerCertificate();\n                            if (serverCertificate) {\n                                // The server certificate must be set before creating any MediaKeySession\n                                self.setServerCertificate(serverCertificate).then(function() {\n                                    self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED);\n                                    videoElement.addEventListener(\"encrypted\", eventHandler);\n                                });\n                            } else {\n                                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED);\n                                videoElement.addEventListener(\"encrypted\", eventHandler);\n                            }\n                        }\n                    );\n                }\n            }).catch(function() {\n                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SYSTEM_SELECTED,\n                        null, \"Error selecting keys system (\" + keySystemAccess.keySystem.systemString + \")! Could not create MediaKeys -- TODO\");\n\n            });\n        },\n\n        setMediaElement: function(mediaElement) {\n            var self = this,\n                deferred = Q.defer();\n\n            if (videoElement === mediaElement) {\n                deferred.resolve();\n                return deferred.promise;\n            }\n\n            if (videoElement) {\n                videoElement.removeEventListener(\"encrypted\", eventHandler);\n                videoElement.removeEventListener(\"waitingforkey\", eventHandler);\n                if (videoElement.setMediaKeys) {\n                    videoElement.setMediaKeys(null).then(\n                        function () {\n                            self.debug.log(\"[DRM][PM_21Jan2015] Successfully detached MediaKeys from video element\");\n                            deferred.resolve();\n                        },\n                        function (e) {\n                            self.debug.error(\"[DRM][PM_21Jan2015] Failed to detach MediaKeys from video element: \" + e);\n                            deferred.resolve();\n                        }\n                    );\n                } else {\n                    deferred.resolve();\n                }\n            }\n\n            videoElement = mediaElement;\n\n            if (videoElement) {\n                if (mediaKeys && videoElement.setMediaKeys) {\n                    videoElement.addEventListener(\"encrypted\", eventHandler);\n                    videoElement.setMediaKeys(mediaKeys);\n                }\n            }\n\n            return deferred.promise;\n        },\n\n        setServerCertificate: function(serverCertificate) {\n            if (!this.keySystem || !mediaKeys) {\n                throw new Error(\"Can not set server certificate until you have selected a key system\");\n            }\n\n            this.debug.log(\"[DRM][PM_21Jan2015] Set server certificate\");\n\n            var self = this,\n                deferred = Q.defer();\n\n            mediaKeys.setServerCertificate(serverCertificate).then(function() {\n                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_SERVER_CERTIFICATE_UPDATED);\n                deferred.resolve();\n            }).catch(function(error) {\n                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_SERVER_CERTIFICATE_UPDATED,\n                        null, \"Error updating server certificate -- \" + error.name);\n                deferred.reject();\n            });\n\n            return deferred.promise;\n        },\n\n        createKeySession: function(initData, sessionType) {\n\n            if (!this.keySystem || !mediaKeys) {\n                throw new Error(\"Can not create sessions until you have selected a key system\");\n            }\n\n            this.debug.log(\"[DRM][PM_21Jan2015] Create key session, type = \" + sessionType);\n            this.debug.log(\"[DRM][PM_21Jan2015] initData = \" + String.fromCharCode.apply(null, new Uint8Array(initData)));\n\n            var session = mediaKeys.createSession(sessionType);\n            var sessionToken = createSessionToken.call(this, session, initData, sessionType);\n\n            // Generate initial key request\n            var self = this;\n            session.generateRequest(\"cenc\", initData).then(function() {\n                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED, sessionToken);\n            }).catch(function(ex) {\n                removeSession(sessionToken);\n                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED, null, {\n                    reason: \"Failed to generate key request\",\n                    error: new MediaPlayer.vo.Error(ex.code, ex.name, ex.message)\n                });\n            });\n        },\n\n        updateKeySession: function(sessionToken, message) {\n\n            var session = sessionToken.session;\n\n            // Send our request to the key session\n            var self = this;\n\n            self.debug.log(\"[DRM][PM_21Jan2015] Update key session. SessionID = \" + session.sessionId);\n\n            if (this.protectionExt.isClearKey(this.keySystem)) {\n                message = message.toJWK();\n            }\n            session.update(message)\n            .then(function() {\n                eventHandler.session = sessionToken;\n            })\n            .catch(function (ex) {\n                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_ERROR,\n                    new MediaPlayer.vo.protection.KeyError(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_KEYERR, \"Error while providing license to the CDM\", ex));\n            });\n        },\n\n        loadKeySession: function(sessionID) {\n            if (!this.keySystem || !mediaKeys) {\n                throw new Error(\"Can not load sessions until you have selected a key system\");\n            }\n\n            this.debug.log(\"[DRM][PM_21Jan2015] Load key session. SessionID = \" + sessionID);\n\n            var session = mediaKeys.createSession();\n\n            // Load persisted session data into our newly created session object\n            var self = this;\n            session.load(sessionID).then(function (success) {\n                if (success) {\n                    var sessionToken = createSessionToken.call(this, session);\n                    self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED, sessionToken);\n                } else {\n                    self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED, null, {\n                        reason: \"Failed to load session \" + sessionID,\n                        error: null\n                    });\n                }\n            }).catch(function (ex) {\n                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CREATED, {\n                    reason: \"Failed to load session \" + sessionID,\n                    error: new MediaPlayer.vo.Error(ex.code, ex.name, ex.message)\n                });\n            });\n        },\n\n        removeKeySession: function(sessionToken) {\n\n            var session = sessionToken.session;\n\n            this.debug.log(\"[DRM][PM_21Jan2015] Remove key session. SessionID = \" + sessionToken.getSessionID());\n\n            var self = this;\n            session.remove().then(function () {\n                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_REMOVED,\n                    sessionToken.getSessionID());\n            }, function (error) {\n                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_REMOVED,\n                    null, \"Error removing session (\" + sessionToken.getSessionID() + \"). \" + error.name);\n            });\n        },\n\n        closeKeySession: function(sessionToken) {\n\n            this.debug.log(\"[DRM][PM_21Jan2015] Close key session. SessionID = \" + sessionToken.getSessionID());\n\n            // Send our request to the key session\n            var self = this;\n            closeKeySessionInternal(sessionToken).catch(function(error) {\n                removeSession(sessionToken);\n                self.notify(MediaPlayer.models.ProtectionModel.eventList.ENAME_KEY_SESSION_CLOSED,\n                        null, \"Error closing session (\" + sessionToken.getSessionID() + \") \" + error.name);\n            });\n        },\n\n        checkIfEncrypted: function() { /* Not supported */ }\n    };\n};\n\n/**\n * Detects presence of EME v21Jan2015 APIs\n *\n * @param videoElement {HTMLMediaElement} the media element that will be\n * used for detecting API support\n * @returns {Boolean} true if support was detected, false otherwise\n */\nMediaPlayer.models.ProtectionModel_21Jan2015.detect = function(videoElement) {\n    if (videoElement.onencrypted === undefined ||\n        videoElement.mediaKeys === undefined) {\n        return false;\n    }\n\n    if (window.MSMediaKeys) {\n        return false;\n    }\n\n    // Do not check requestMediaKeySystemAccess function since it can be disable on insecure origins\n    // if (navigator.requestMediaKeySystemAccess === undefined ||\n    //     typeof navigator.requestMediaKeySystemAccess !== 'function') {\n    //     return false;\n    // }\n\n    return true;\n};\n\nMediaPlayer.models.ProtectionModel_21Jan2015.prototype = {\n    constructor: MediaPlayer.models.ProtectionModel_21Jan2015\n};\n\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Defines the public interface for all Key Systems (DRMs) supported\n * by the player.\n *\n * @interface\n */\n\nMediaPlayer.dependencies.protection.KeySystem = function() {};\n\n/**\n * Key system name string (e.g. 'org.w3.clearkey')\n *\n * @instance\n * @name systemString\n * @memberof MediaPlayer.dependencies.protection.KeySystem\n * @readonly\n * @type String\n */\n\n/**\n * Key system UUID in the form '01234567-89ab-cdef-0123-456789abcdef'\n *\n * @instance\n * @name uuid\n * @memberof MediaPlayer.dependencies.protection.KeySystem\n * @readonly\n * @type String\n */\n\n/**\n * The scheme ID URI for this key system in the form\n * 'urn:uuid:01234567-89ab-cdef-0123-456789abcdef' as used\n * in DASH ContentProtection elements\n *\n * @instance\n * @name schemeIdURI\n * @memberof MediaPlayer.dependencies.protection.KeySystem\n * @readonly\n * @type String\n */\n\n\n/**\n * The sessionType used for the CDM\n *\n * @instance\n * @name sessionType\n * @memberof MediaPlayer.dependencies.protection.KeySystem\n * @readonly\n * @type String\n */\n\n/**\n * Parse DRM-specific init data from the ContentProtection\n * element.\n *\n * @function\n * @name MediaPlayer.dependencies.protection.KeySystem#getInitData\n * @param {Object} contentProtection the json-style contentProtection\n * object representing the ContentProtection element parsed from the\n * MPD XML document.\n * @returns {ArrayBuffer} EME initialization data\n */\n\n/**\n * For some key systems, the CDM message contains HTTP headers that\n * can be parsed by the application and attached to the license request.\n * Returns a header object with key/value pairs as object properties/values\n *\n * @function\n * @name MediaPlayer.dependencies.protection.KeySystem#getRequestHeadersFromMessage\n * @param {ArrayBuffer} message the CDM message\n * @returns {?Object} headers object with header names as the object property\n * names and header values as the corresponding object property values.  Return\n * null if no such headers were found or if the mechanism is not supported by\n * this key system\n */\n\n/**\n * For some key systems, the CDM message contains more than just the\n * license request data.  This method will pull the license request from\n * the CDM message, if necessary.\n *\n * @function\n * @name MediaPlayer.dependencies.protection.KeySystem#getKeySystemConfigurations\n * @param {object} videoInfo contains relevant info about video (mimeType, codec)\n * @param {object} audioInfo contains relevant info about audio (mimeType, codec)\n * @param {String} sessionType the session type like \"temporary\" or \"persistent-license\"\n * @returns {Array} list of {MediaPlayer.vo.protection.KeySystemConfiguration}\n *\n\n * @function\n * @name MediaPlayer.dependencies.protection.KeySystem#getLicenseRequestFromMessage\n * @param message {ArrayBuffer} the CDM message\n * @returns {Uint8Array} the license request message as will be passed to\n * XMLHttpRequest.send()\n */\n\n/**\n * Returns a license server URL as parsed from key system initialization data (PSSH).\n *\n * @function\n * @name MediaPlayer.dependencies.protection.KeySystem#getLicenseServerURLFromInitData\n * @param initData {ArrayBuffer} the initialization data.  This is just the \"Data\" field\n * from the PSSH box definition\n * @returns {?string} The license server URL or null if URL is not available in initData\n */\n\n/**\n * Returns specific CDM (custom) data.\n *\n * @function\n * @name MediaPlayer.dependencies.protection.KeySystem#getCDMData\n * @returns {ArrayBuffer} the CDM (custom) data\n */\n\n /**\n * Returns the server certificate.\n *\n * @function\n * @name MediaPlayer.dependencies.protection.KeySystem#getServerCertificate\n * @returns {ArrayBuffer} the server certificate\n */","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Adobe Access DRM\n *\n * @class\n * @implements MediaPlayer.dependencies.protection.KeySystem\n */\nMediaPlayer.dependencies.protection.KeySystem_Access = function() {\n    \"use strict\";\n};\n\nMediaPlayer.dependencies.protection.KeySystem_Access.prototype = {\n    constructor: MediaPlayer.dependencies.protection.KeySystem_Access\n};\n\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nMediaPlayer.dependencies.protection.KeySystem_ClearKey = function() {\n    \"use strict\";\n\n    var keySystemStr = \"org.w3.clearkey\",\n        keySystemUUID = \"1077efec-c0b2-4d02-ace3-3c1e52e2fb4b\",\n        protData;\n\n    return {\n\n        system: undefined,\n        schemeIdURI: \"urn:uuid:\" + keySystemUUID,\n        systemString: keySystemStr,\n        uuid: keySystemUUID,\n        sessionType:\"temporary\",\n\n        init: function(protectionData){\n            protData = protectionData;\n        },\n\n        getInitData: MediaPlayer.dependencies.protection.CommonEncryption.parseInitDataFromContentProtection,\n\n        getKeySystemConfigurations: MediaPlayer.dependencies.protection.CommonEncryption.getKeySystemConfigurations,\n\n        getRequestHeadersFromMessage: function(/*message*/) { return null; },\n\n        getLicenseRequestFromMessage: function(message) { return new Uint8Array(message); },\n\n        getLicenseServerURLFromInitData: function(/*initData*/) { return null; },\n\n        getCDMData: function () {return null;},\n\n        getServerCertificate: function () { return null; },\n    };\n};\n\nMediaPlayer.dependencies.protection.KeySystem_ClearKey.prototype = {\n    constructor: MediaPlayer.dependencies.protection.KeySystem_ClearKey\n};\n\n/**\n * Returns desired clearkeys (as specified in the CDM message) from protection data\n *\n * @param {MediaPlayer.vo.protection.ProtectionData} protData the protection data\n * @param {ArrayBuffer} message the ClearKey CDM message\n * @returns {MediaPlayer.vo.protection.ClearKeyKeySet} the key set or null if none found\n * @throws {Error} if a keyID specified in the CDM message was not found in the\n * protection data\n * @memberof MediaPlayer.dependencies.protection.KeySystem_ClearKey\n */\nMediaPlayer.dependencies.protection.KeySystem_ClearKey.getClearKeysFromProtectionData = function(protData, message) {\n    var clearkeySet = null;\n    if (protData) {\n        // ClearKey is the only system that does not require a license server URL, so we\n        // handle it here when keys are specified in protection data\n        var jsonMsg = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(message)));\n        var keyPairs = [];\n        for (var i = 0; i < jsonMsg.kids.length; i++) {\n            var clearkeyID = jsonMsg.kids[i],\n                    clearkey = (protData.clearkeys.hasOwnProperty(clearkeyID)) ? protData.clearkeys[clearkeyID] : null;\n            if (!clearkey) {\n                throw new Error(\"[DRM] ClearKey keyID (\" + clearkeyID + \") is not known!\");\n            }\n            // KeyIDs from CDM are not base64 padded.  Keys may or may not be padded\n            keyPairs.push(new MediaPlayer.vo.protection.KeyPair(clearkeyID, clearkey));\n        }\n        clearkeySet = new MediaPlayer.vo.protection.ClearKeyKeySet(keyPairs);\n    }\n    return clearkeySet;\n};\n\n\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Microsoft PlayReady DRM\n *\n * @class\n * @implements MediaPlayer.dependencies.protection.KeySystem\n */\nMediaPlayer.dependencies.protection.KeySystem_PlayReady = function() {\n    \"use strict\";\n\n    var keySystemStr = \"com.microsoft.playready\",\n        keySystemUUID = \"9a04f079-9840-4286-ab92-e65be0885f95\",\n        messageFormat = \"utf16\",\n        PRCDMData = '<PlayReadyCDMData type=\"LicenseAcquisition\"><LicenseAcquisition version=\"1.0\" Proactive=\"false\"><CustomData encoding=\"base64encoded\">%CUSTOMDATA%</CustomData></LicenseAcquisition></PlayReadyCDMData>',\n        protData,\n\n        getRequestHeaders = function(message) {\n            var msg,\n                xmlDoc,\n                headers = {},\n                data = (message instanceof ArrayBuffer) ? message : message.buffer,\n                dataview = (messageFormat === \"utf16\") ? new Uint16Array(data) : new Uint8Array(data),\n                headerNameList,\n                headerValueList,\n                i = 0;\n\n            msg = String.fromCharCode.apply(null, dataview);\n            xmlDoc = this.domParser.createXmlTree(msg);\n\n            headerNameList = xmlDoc.getElementsByTagName(\"name\");\n            headerValueList = xmlDoc.getElementsByTagName(\"value\");\n            for (i = 0; i < headerNameList.length; i += 1) {\n                headers[headerNameList[i].childNodes[0].nodeValue] = headerValueList[i].childNodes[0].nodeValue;\n            }\n            // Some versions of the PlayReady CDM return 'Content' instead of 'Content-Type'.\n            // this is NOT w3c conform and license servers may reject the request!\n            // -> rename it to proper w3c definition!\n            if (headers.hasOwnProperty('Content')) {\n                headers['Content-Type'] = headers.Content;\n                delete headers.Content;\n            }\n\n            // Some versions of the PlayReady CDM do not return headers at all, which means the Content-Type\n            // does not get set and most license servers will just refuse the license request.\n            // -> set it manually if is missing.\n            if (!headers.hasOwnProperty('Content-Type')) {\n                headers['Content-Type'] = 'text/xml; charset=utf-8';\n            }\n\n            return headers;\n        },\n\n        getLicenseRequest = function(message) {\n            var msg,\n                xmlDoc,\n                licenseRequest = null,\n                data = (message instanceof ArrayBuffer) ? message : message.buffer,\n                dataview = (messageFormat === \"utf16\") ? new Uint16Array(data) : new Uint8Array(data),\n                Challenge;\n\n            msg = String.fromCharCode.apply(null, dataview);\n            xmlDoc = this.domParser.createXmlTree(msg);\n\n            if (xmlDoc.getElementsByTagName(\"Challenge\")[0]) {\n                Challenge = xmlDoc.getElementsByTagName(\"Challenge\")[0].childNodes[0].nodeValue;\n                if (Challenge) {\n                    licenseRequest = BASE64.decode(Challenge);\n                }\n            } else {\n                // Some versions of the PlayReady CDM do not return the Microsoft-specified XML structure\n                // but just return the raw license request. If we can't extract the license request, let's\n                // assume it is the latter and just return the whole message.\n                licenseRequest = msg;\n            }\n            return licenseRequest;\n        },\n\n        getLicenseServerURL = function(initData) {\n            if (initData) {\n                var data = new DataView(initData),\n                        numRecords = data.getUint16(4, true),\n                        offset = 6,\n                        i = 0,\n                        recordType,\n                        recordLength,\n                        recordData,\n                        record,\n                        xmlDoc,\n                        laurl,\n                        luiurl;\n\n                for (i = 0; i < numRecords; i++) {\n                    // Parse the PlayReady Record header\n                    recordType = data.getUint16(offset, true);\n                    offset += 2;\n                    recordLength = data.getUint16(offset, true);\n                    offset += 2;\n                    if (recordType !== 0x0001) {\n                        offset += recordLength;\n                        continue;\n                    }\n\n                    recordData = initData.slice(offset, offset+recordLength);\n                    record = String.fromCharCode.apply(null, new Uint16Array(recordData));\n                    xmlDoc = this.domParser.createXmlTree(record);\n\n                    // First try <LA_URL>\n                    if (xmlDoc.getElementsByTagName(\"LA_URL\")[0]) {\n                        laurl = xmlDoc.getElementsByTagName(\"LA_URL\")[0].childNodes[0].nodeValue;\n                        if (laurl) {\n                            return laurl;\n                        }\n                    }\n\n                    // Optionally, try <LUI_URL>\n                    if (xmlDoc.getElementsByTagName(\"LUI_URL\")[0]) {\n                        luiurl = xmlDoc.getElementsByTagName(\"LUI_URL\")[0].childNodes[0].nodeValue;\n                        if (luiurl) {\n                            return luiurl;\n                        }\n                    }\n                }\n            }\n\n            return null;\n\n        },\n\n        parseInitDataFromContentProtection = function(cpData) {\n            // * desc@ getInitData\n            // *   generate PSSH data from PROHeader defined in MPD file\n            // *   PSSH format:\n            // *   size (4)\n            // *   box type(PSSH) (8)\n            // *   Protection SystemID (16)\n            // *   protection system data size (4) - length of decoded PROHeader\n            // *   decoded PROHeader data from MPD file\n            var byteCursor = 0,\n                PROSize,\n                PSSHSize,\n                PSSHBoxType = new Uint8Array([0x70, 0x73, 0x73, 0x68, 0x00, 0x00, 0x00, 0x00 ]), //'PSSH' 8 bytes\n                playreadySystemID = new Uint8Array([0x9a, 0x04, 0xf0, 0x79, 0x98, 0x40, 0x42, 0x86, 0xab, 0x92, 0xe6, 0x5b, 0xe0, 0x88, 0x5f, 0x95]),\n                uint8arraydecodedPROHeader = null,\n                PSSHBoxBuffer,\n                PSSHBox,\n                PSSHData;\n\n            // Handle common encryption PSSH\n            if (\"pssh\" in cpData) {\n                return MediaPlayer.dependencies.protection.CommonEncryption.parseInitDataFromContentProtection(cpData);\n            }\n            // Handle native MS PlayReady ContentProtection elements\n            if (\"pro\" in cpData) {\n                uint8arraydecodedPROHeader = BASE64.decodeArray(cpData.pro.__text);\n            }\n            else if (\"prheader\" in cpData) {\n                uint8arraydecodedPROHeader = BASE64.decodeArray(cpData.prheader.__text);\n            }\n            else {\n                return null;\n            }\n\n            PROSize = uint8arraydecodedPROHeader.length;\n            PSSHSize = 0x4 + PSSHBoxType.length + playreadySystemID.length + 0x4 + PROSize;\n\n            PSSHBoxBuffer = new ArrayBuffer(PSSHSize);\n\n            PSSHBox = new Uint8Array(PSSHBoxBuffer);\n            PSSHData = new DataView(PSSHBoxBuffer);\n\n            PSSHData.setUint32(byteCursor, PSSHSize);\n            byteCursor += 0x4;\n\n            PSSHBox.set(PSSHBoxType, byteCursor);\n            byteCursor += PSSHBoxType.length;\n\n            PSSHBox.set(playreadySystemID, byteCursor);\n            byteCursor += playreadySystemID.length;\n\n            PSSHData.setUint32(byteCursor, PROSize);\n            byteCursor += 0x4;\n\n            PSSHBox.set(uint8arraydecodedPROHeader, byteCursor);\n            byteCursor += PROSize;\n\n            return PSSHBox.buffer;\n        },\n\n        doGetCDMData = function () {\n            var customData,\n                cdmData,\n                cdmDataBytes,\n                i;\n\n            if (protData && protData.cdmData) {\n\n                // Convert custom data into multibyte string\n                customData = [];\n                for (i = 0; i < protData.cdmData.length; ++i) {\n                    customData.push(protData.cdmData.charCodeAt(i));\n                    customData.push(0);\n                }\n                customData = String.fromCharCode.apply(null, customData);\n\n                // Encode in Base 64 the custom data string\n                customData = BASE64.encode(customData);\n\n                // Initialize CDM data with Base 64 encoded custom data\n                // (see https://msdn.microsoft.com/en-us/library/dn457361.aspx)\n                cdmData = PRCDMData.replace('%CUSTOMDATA%', customData);\n\n                // Convert CDM data into multibyte characters\n                cdmDataBytes = [];\n                for (i = 0; i < cdmData.length; ++i) {\n                    cdmDataBytes.push(cdmData.charCodeAt(i));\n                    cdmDataBytes.push(0);\n                }\n\n                return new Uint8Array(cdmDataBytes).buffer;\n            }\n\n            return null;\n        };\n\n    return {\n\n        schemeIdURI: \"urn:uuid:\" + keySystemUUID,\n        systemString: keySystemStr,\n        uuid: keySystemUUID,\n        notify: undefined,\n        subscribe: undefined,\n        unsubscribe: undefined,\n        domParser: undefined,\n        /*sessionType:\"persistent-license\",*/\n        sessionType:\"temporary\",\n\n        init: function(protectionData){\n            if(protectionData){\n                protData = protectionData;\n                if(protData.sessionType){\n                    this.sessionType = protData.sessionType;\n                }\n            }\n        },\n\n        getInitData: parseInitDataFromContentProtection,\n\n        getKeySystemConfigurations: MediaPlayer.dependencies.protection.CommonEncryption.getKeySystemConfigurations,\n\n        getRequestHeadersFromMessage: getRequestHeaders,\n\n        getLicenseRequestFromMessage: getLicenseRequest,\n\n        getLicenseServerURLFromInitData: getLicenseServerURL,\n\n        getCDMData: doGetCDMData,\n\n        getServerCertificate: function () { return null; },\n\n        /**\n         * It seems that some PlayReady implementations return their XML-based CDM\n         * messages using UTF16, while others return them as UTF8.  Use this function\n         * to modify the message format to expect when parsing CDM messages.\n         *\n         * @param {string} format the expected message format.  Either \"utf8\" or \"utf16\".\n         * @throws {Error} Specified message format is not one of \"utf8\" or \"utf16\"\n         */\n        setPlayReadyMessageFormat: function(format) {\n            if (format !== \"utf8\" && format !== \"utf16\") {\n                throw new Error(\"Illegal PlayReady message format! -- \" + format);\n            }\n            messageFormat = format;\n        }\n    };\n};\n\nMediaPlayer.dependencies.protection.KeySystem_PlayReady.prototype = {\n    constructor: MediaPlayer.dependencies.protection.KeySystem_PlayReady\n};\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Google Widevine DRM\n *\n * @class\n * @implements MediaPlayer.dependencies.protection.KeySystem\n */\nMediaPlayer.dependencies.protection.KeySystem_Widevine = function() {\n    \"use strict\";\n\n    var keySystemStr = \"com.widevine.alpha\",\n        keySystemUUID = \"edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\",\n        protData = null,\n\n        replaceKID = function (pssh, KID) {\n            var pssh_array,\n                replace = true,\n                kidLen = 16,\n                pos,\n                i, j;\n\n            pssh_array = new Uint8Array(pssh);\n\n            for (i = 0; i <= pssh_array.length - (kidLen + 2); i++) {\n                if (pssh_array[i] === 0x12 && pssh_array[i+1] === 0x10) {\n                    pos = i + 2;\n                    for (j = pos; j < (pos + kidLen); j++) {\n                        if (pssh_array[j] !== 0xFF) {\n                            replace = false;\n                            break;\n                        }\n                    }\n                    break;\n                }\n            }\n\n            if (replace) {\n                pssh_array.set(KID, pos);\n            }\n\n            return pssh_array.buffer;\n        },\n\n        doGetInitData = function(cpData) {\n            var pssh = null;\n            // Get pssh from protectionData or from manifest\n            if (protData && protData.pssh) {\n                pssh = BASE64.decodeArray(protData.pssh).buffer;\n            } else {\n                pssh = MediaPlayer.dependencies.protection.CommonEncryption.parseInitDataFromContentProtection(cpData);\n            }\n\n            // Check if KID within pssh is empty, in that case set KID value according to 'cenc:default_KID' value\n            if (pssh) {\n                pssh = replaceKID(pssh, cpData['cenc:default_KID']);\n            }\n\n            return pssh;\n        },\n\n        doGetKeySystemConfigurations = function(videoCodec, audioCodec, sessionType) {\n            var ksConfigurations = MediaPlayer.dependencies.protection.CommonEncryption.getKeySystemConfigurations(videoCodec, audioCodec, sessionType);\n            if (protData) {\n                if (protData.audioRobustness) {\n                    ksConfigurations[0].audioCapabilities[0].robustness = protData.audioRobustness;\n                }\n                if (protData.videoRobustness) {\n                    ksConfigurations[0].videoCapabilities[0].robustness = protData.videoRobustness;\n                }\n            }\n            return ksConfigurations;\n        },\n\n        doGetServerCertificate = function() {\n            if (protData && protData.serverCertificate && protData.serverCertificate.length > 0) {\n                return BASE64.decodeArray(protData.serverCertificate).buffer;\n            }\n            return null;\n        };\n\n    return {\n\n        schemeIdURI: \"urn:uuid:\" + keySystemUUID,\n        systemString: keySystemStr,\n        uuid: keySystemUUID,\n        sessionType: \"temporary\",\n\n        init: function(protectionData) {\n            if (protectionData) {\n                protData = protectionData;\n                if (protData.sessionType) {\n                    this.sessionType = protData.sessionType;\n                }\n            }\n        },\n\n        getInitData: doGetInitData,\n\n        getKeySystemConfigurations: doGetKeySystemConfigurations,\n\n        getRequestHeadersFromMessage: function(/*message*/) { return null; },\n\n        getLicenseRequestFromMessage: function(message) { return new Uint8Array(message); },\n\n        getLicenseServerURLFromInitData: function(/*initData*/) { return null; },\n\n        getCDMData: function() { return null; },\n\n        getServerCertificate: doGetServerCertificate\n\n    };\n};\n\nMediaPlayer.dependencies.protection.KeySystem_Widevine.prototype = {\n    constructor: MediaPlayer.dependencies.protection.KeySystem_Widevine\n};","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * CableLabs ClearKey license server implementation\n *\n * For testing purposes and evaluating potential uses for ClearKey, we have developed\n * a dirt-simple API for requesting ClearKey licenses from a remote server.\n *\n * @implements MediaPlayer.dependencies.protection.servers.LicenseServer\n * @class\n */\nMediaPlayer.dependencies.protection.servers.ClearKey = function() {\n    \"use strict\";\n\n    return {\n\n        getServerURLFromMessage: function(url, message /*, messageType*/ ) {\n            // Build ClearKey server query string\n            var jsonMsg = JSON.parse(String.fromCharCode.apply(null, new Uint8Array(message))),\n                i = 0;\n            url += \"/?\";\n            for (i = 0; i < jsonMsg.kids.length; i++) {\n                url += jsonMsg.kids[i] + \"&\";\n            }\n            url = url.substring(0, url.length - 1);\n            return url;\n        },\n\n        getHTTPMethod: function( /*messageType*/ ) {\n            return 'GET';\n        },\n\n        getResponseType: function( /*keySystemStr*/ ) {\n            return 'json';\n        },\n\n        getLicenseMessage: function(serverResponse /*, keySystemStr, messageType*/ ) {\n            var i, keyPairs = [],\n                keypair,\n                keyid,\n                key;\n            if (!serverResponse.hasOwnProperty(\"keys\")) {\n                return null;\n            }\n\n            for (i = 0; i < serverResponse.keys.length; i++) {\n                keypair = serverResponse.keys[i];\n                keyid = keypair.kid.replace(/=/g, \"\");\n                key = keypair.k.replace(/=/g, \"\");\n                keyPairs.push(new MediaPlayer.vo.protection.KeyPair(keyid, key));\n            }\n            return new MediaPlayer.vo.protection.ClearKeyKeySet(keyPairs);\n        },\n\n        getErrorResponse: function(serverResponse/*, keySystemStr, messageType*/) {\n            return {\n                code: 0,\n                name: \"UnknownError\",\n                message: String.fromCharCode.apply(null, new Uint8Array(serverResponse))\n            };\n        }\n    };\n};\n\nMediaPlayer.dependencies.protection.servers.ClearKey.prototype = {\n    constructor: MediaPlayer.dependencies.protection.servers.ClearKey\n};\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * CastLabs DRMToday License Server implementation\n *\n * @implements MediaPlayer.dependencies.protection.servers.LicenseServer\n * @class\n */\nMediaPlayer.dependencies.protection.servers.DRMToday = function() {\n    \"use strict\";\n\n    var keySystems = {\n        \"com.widevine.alpha\": {\n            responseType: \"json\",\n            getLicenseMessage: function(response) {\n                return BASE64.decodeArray(response.license);\n            },\n            getErrorResponse: function(response) {\n                return response;\n            }\n        },\n        \"com.microsoft.playready\": {\n            responseType: \"arraybuffer\",\n            getLicenseMessage: function(response) {\n                return response;\n            },\n            getErrorResponse: function(response) {\n                return String.fromCharCode.apply(null, new Uint8Array(response));\n            }\n        }\n    };\n\n    return {\n\n        getServerURLFromMessage: function(url /*, message, messageType*/) { return url; },\n\n        getHTTPMethod: function(/*messageType*/) { return 'POST'; },\n\n        getResponseType: function(keySystemStr/*, messageType*/) {\n            return keySystems[keySystemStr].responseType;\n        },\n\n        getLicenseMessage: function(serverResponse, keySystemStr/*, messageType*/) {\n            return keySystems[keySystemStr].getLicenseMessage(serverResponse);\n        },\n\n        getErrorResponse: function(serverResponse, keySystemStr/*, messageType*/) {\n            return {\n                code: 0,\n                name: \"UnknownError\",\n                message: keySystems[keySystemStr].getErrorResponse(serverResponse)\n            };\n        }\n    };\n};\n\nMediaPlayer.dependencies.protection.servers.DRMToday.prototype = {\n    constructor: MediaPlayer.dependencies.protection.servers.DRMToday\n};\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Defines the public interface for license server implementations supported\n * by the player.\n *\n * Different license servers have different requirements regarding the methods\n * used to request DRM licenses.  Things like request headers, license response\n * formats (for both error and success cases) need to be customized for a\n * specific server implementation\n *\n * License servers handle requests for more than just initial license retrieval.\n * Each API takes a parameter which describes the message type as supported by\n * the Encrypted Media Extensions.\n *\n * @interface\n */\n\nMediaPlayer.dependencies.protection.servers.LicenseServer = function() {};\n\n/**\n * Returns a new or updated license server URL based on the requirements of the\n * license server and possibly from information passed in the CDM license message\n *\n * @function\n * @name MediaPlayer.dependencies.protection.servers.LicenseServer#getServerURLFromMessage\n * @param {?string} url the initially established URL (from ProtectionData or initData)\n * @param {ArrayBuffer} message the CDM message which may be needed to generate the license\n * requests URL\n * @param {String} messageType the message type associated with this request.  Supported\n * message types can be found {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}.\n * @returns {string} the URL to use in license requests\n */\n\n/**\n * Returns the HTTP method to be used (i.e. \"GET\", \"POST\", etc.) in\n * XMLHttpRequest.open().\n *\n * @function\n * @name MediaPlayer.dependencies.protection.servers.LicenseServer#getHTTPMethod\n * @param {String} messageType the message type associated with this request.  Supported\n * message types can be found {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}.\n * @returns {string} the HTTP method\n */\n\n/**\n * Returns the response type to set for XMLHttpRequest.responseType\n *\n * @function\n * @name MediaPlayer.dependencies.protection.servers.LicenseServer#getResponseType\n * @param {string} keySystemStr the key system string representing the key system\n * associated with a license request.  Multi-DRM license servers may have different\n * response types depending on the key system.\n * @param {String} messageType the message type associated with this request.  Supported\n * message types can be found {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}.\n * @returns {string} the response type\n */\n\n/**\n * Parses the license server response for any message intended for\n * the CDM.\n *\n * @function\n * @name MediaPlayer.dependencies.protection.servers.LicenseServer#getLicenseMessage\n * @param {Object} serverResponse the response as returned in XMLHttpRequest.response\n * @param {string} keySystemStr the key system string representing the key system\n * associated with a license request.\n * @param {String} messageType the message type associated with this request.  Supported\n * message types can be found {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}.\n * @returns {ArrayBuffer} message that will be sent to the CDM or null if no CDM message\n * was present in the response.\n */\n\n/**\n * Parses the license server response during error conditions and returns a\n * string to display for debugging purposes\n *\n * @function\n * @name MediaPlayer.dependencies.protection.servers.LicenseServer#getErrorResponse\n * @param {Object} serverResponse the server response\n * @param {String} messageType the message type associated with this request.  Supported\n * message types can be found {@link https://w3c.github.io/encrypted-media/#idl-def-MediaKeyMessageType|here}.\n * @returns {string} an error message that indicates the reason for the failure\n */\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Microsoft PlayReady Test License Server\n *\n * For testing content that uses the PlayReady test server at\n *\n * @implements MediaPlayer.dependencies.protection.servers.LicenseServer\n * @class\n */\nMediaPlayer.dependencies.protection.servers.PlayReady = function() {\n    \"use strict\";\n\n    var decodeUtf8 = function(arrayBuffer) {\n            var result = \"\",\n                i = 0,\n                c = 0,\n                c2 = 0,\n                c3 = 0,\n                data = new Uint8Array(arrayBuffer);\n\n            // If we have a BOM skip it\n            if (data.length >= 3 && data[0] === 0xef && data[1] === 0xbb && data[2] === 0xbf) {\n                i = 3;\n            }\n\n            while (i < data.length) {\n                c = data[i];\n\n                if (c < 128) {\n                    result += String.fromCharCode(c);\n                    i++;\n                } else if (c > 191 && c < 224) {\n                    if (i + 1 >= data.length) {\n                        throw \"UTF-8 Decode failed. Two byte character was truncated.\";\n                    }\n                    c2 = data[i + 1];\n                    result += String.fromCharCode(((c & 31) << 6) | (c2 & 63));\n                    i += 2;\n                } else {\n                    if (i + 2 >= data.length) {\n                        throw \"UTF-8 Decode failed. Multi byte character was truncated.\";\n                    }\n                    c2 = data[i + 1];\n                    c3 = data[i + 2];\n                    result += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));\n                    i += 3;\n                }\n            }\n            return result;\n        },\n\n        parseServerResponse = function(serverResponse) {\n            var stringResponse = decodeUtf8(serverResponse),\n                xmlDoc = this.domParser.createXmlTree(stringResponse),\n                enveloppe = xmlDoc ? this.domParser.getChildNode(xmlDoc, \"soap:Envelope\") : null,\n                body = enveloppe ? this.domParser.getChildNode(enveloppe, \"soap:Body\") : null,\n                fault = body ? this.domParser.getChildNode(body, \"soap:Fault\") : null;\n\n            if (fault) {\n                return null;\n            }\n\n            return serverResponse;\n        },\n\n        parseErrorResponse = function(serverResponse) {\n            var stringResponse = decodeUtf8(serverResponse),\n                xmlDoc = this.domParser.createXmlTree(stringResponse),\n                enveloppe = xmlDoc ? this.domParser.getChildNode(xmlDoc, \"soap:Envelope\") : null,\n                body = enveloppe ? this.domParser.getChildNode(enveloppe, \"soap:Body\") : null,\n                fault = body ? this.domParser.getChildNode(body, \"soap:Fault\") : null,\n                detail = fault ? this.domParser.getChildNode(fault, \"detail\") : null,\n                exception = detail ? this.domParser.getChildNode(detail, \"Exception\") : null,\n                node = null,\n                faultstring = \"\",\n                statusCode = \"\",\n                message = \"\",\n                idStart = -1,\n                idEnd = -1;\n\n            if (fault === null) {\n                return {\n                    code: 0,\n                    name: \"UnknownError\",\n                    message: String.fromCharCode.apply(null, new Uint8Array(serverResponse))\n                };\n            }\n\n            node = this.domParser.getChildNode(fault, \"faultstring\").firstChild;\n            faultstring = node ? node.nodeValue : null;\n\n            if (exception !== null) {\n                node = this.domParser.getChildNode(exception, \"StatusCode\");\n                statusCode = node ? node.firstChild.nodeValue : null;\n\n                node = this.domParser.getChildNode(exception, \"Message\");\n                message = node ? node.firstChild.nodeValue : null;\n                idStart = message ? message.lastIndexOf('[') + 1 : -1;\n                idEnd = message ? message.indexOf(']') : -1;\n            }\n\n            return {\n                code: statusCode,\n                name: faultstring,\n                message: message ? message.substring(idStart, idEnd) : \"\"\n            };\n        };\n\n    return {\n        domParser: undefined,\n\n        getServerURLFromMessage: function(url /*, message, messageType*/) { return url; },\n\n        getHTTPMethod: function(/*messageType*/) { return 'POST'; },\n\n        getResponseType: function(/*keySystemStr, messageType*/) { return 'arraybuffer'; },\n\n        getLicenseMessage: function(serverResponse/*, keySystemStr, messageType*/) {\n            return parseServerResponse.call(this, serverResponse);\n        },\n\n        getErrorResponse: function(serverResponse/*, keySystemStr, messageType*/) {\n            return parseErrorResponse.call(this, serverResponse);\n        }\n    };\n};\n\nMediaPlayer.dependencies.protection.servers.PlayReady.prototype = {\n    constructor: MediaPlayer.dependencies.protection.servers.PlayReady\n};\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nMediaPlayer.dependencies.protection.servers.Widevine = function() {\n    \"use strict\";\n\n    return {\n\n        getServerURLFromMessage: function(url /*, message, messageType*/) { return url; },\n\n        getHTTPMethod: function(/*messageType*/) { return 'POST'; },\n\n        getResponseType: function(/*keySystemStr, messageType*/) { return 'arraybuffer'; },\n\n        getLicenseMessage: function(serverResponse/*, keySystemStr, messageType*/) {\n            return serverResponse;\n        },\n\n        getErrorResponse: function(serverResponse/*, keySystemStr, messageType*/) {\n            return {\n                code: 0,\n                name: \"UnknownError\",\n                message: String.fromCharCode.apply(null, new Uint8Array(serverResponse))\n            };\n        }\n    };\n};\n\nMediaPlayer.dependencies.protection.servers.Widevine.prototype = {\n    constructor: MediaPlayer.dependencies.protection.servers.Widevine\n};\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * A collection of ClearKey encryption keys with an (optional) associated\n * type\n *\n * @param keyPairs {MediaPlayer.vo.protection.KeyPair[]} array of key pairs\n * @param type the type of keys in this set.  One of either 'persistent'\n * or 'temporary'.  Can also be null or undefined.\n * @constructor\n */\nMediaPlayer.vo.protection.ClearKeyKeySet = function(keyPairs, type) {\n    if (type && type !== \"persistent\" && type !== \"temporary\")\n        throw new Error(\"Invalid ClearKey key set type!  Must be one of 'persistent' or 'temporary'\");\n    this.keyPairs = keyPairs;\n    this.type = type;\n\n    /**\n     * Convert this key set to its JSON Web Key (JWK) representation\n     *\n     * @return {ArrayBuffer} JWK object UTF-8 encoded as ArrayBuffer\n     */\n    this.toJWK = function() {\n        var i, numKeys = this.keyPairs.length,\n            jwk = {};\n        jwk.keys = [];\n        for (i = 0; i < numKeys; i++) {\n            var key = {\n                kty: \"oct\",\n                alg: \"A128KW\",\n                kid: this.keyPairs[i].keyID,\n                k: this.keyPairs[i].key\n            };\n            jwk.keys.push(key);\n        }\n        if (this.type) {\n            jwk.type = this.type;\n        }\n        var jwkString = JSON.stringify(jwk);\n        var len = jwkString.length;\n\n        // Convert JSON string to ArrayBuffer\n        var buf = new ArrayBuffer(len);\n        var bView = new Uint8Array(buf);\n        for (i = 0; i < len; i++)\n            bView[i] = jwkString.charCodeAt(i);\n        return buf;\n    };\n};\n\nMediaPlayer.vo.protection.ClearKeyKeySet.prototype = {\n    constructor: MediaPlayer.vo.protection.ClearKeyKeySet\n};\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * EME-independent KeyError\n *\n * @param sessionToken the key session to which this error is associated\n * @param errorString an informational error message\n * @class\n * @deprecated Newest versions of EME APIs will not use this error object\n */\nMediaPlayer.vo.protection.KeyError = function(code, message, data) {\n    \"use strict\";\n    this.code = code;\n    this.message = message;\n    this.data = data;\n};\n\nMediaPlayer.vo.protection.KeyError.prototype = {\n    constructor: MediaPlayer.vo.protection.KeyError\n};\n\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * EME-independent KeyMessage\n *\n * @param {MediaPlayer.vo.protection.SessionToken} sessionToken the session\n * to which the key message is associated\n * @param {ArrayBuffer} message the key message\n * @param [defaultURL] license acquisition URL provided by the CDM\n * @param [messageType] the message type.  One of \"license-request\",\n * \"license-renewal\", \"license-release\", \"individualization-request\"\n * @constructor\n */\nMediaPlayer.vo.protection.KeyMessage = function(sessionToken, message, defaultURL, messageType) {\n    \"use strict\";\n    this.sessionToken = sessionToken;\n    this.message = message;\n    this.defaultURL = defaultURL;\n    this.messageType = messageType;\n};\n\nMediaPlayer.vo.protection.KeyMessage.prototype = {\n    constructor: MediaPlayer.vo.protection.KeyMessage\n};\n\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Represents a 128-bit keyID and 128-bit encryption key\n *\n * @param keyID {String} 128-bit key ID, base64 encoded, with no padding\n * @param key {String} 128-bit encryption key, base64 encoded, with no padding\n * @constructor\n */\nMediaPlayer.vo.protection.KeyPair = function(keyID, key) {\n    \"use strict\";\n    this.keyID = keyID;\n    this.key = key;\n};\n\nMediaPlayer.vo.protection.KeyPair.prototype = {\n    constructor: MediaPlayer.vo.protection.KeyPair\n};\n\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Creates a new key system access token.  Represents a valid key system for\n * given piece of content and key system requirements.  Used to initialize license\n * acquisition operations.\n *\n * @param {MediaPlayer.dependencies.protection.KeySystem} keySystem the key system\n * @param {MediaPlayer.vo.protection.KeySystemConfiguration} ksConfiguration the\n * subset of configurations passed to the key system access request that are supported\n * by this user agent\n * @constructor\n */\nMediaPlayer.vo.protection.KeySystemAccess = function(keySystem, ksConfiguration) {\n    this.keySystem = keySystem;\n    this.ksConfiguration = ksConfiguration;\n};\n\nMediaPlayer.vo.protection.KeySystemAccess.prototype = {\n    constructor: MediaPlayer.vo.protection.KeySystemAccess\n};\n\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n *\n * @param {MediaPlayer.vo.protection.MediaCapability[]} audioCapabilities\n * @param {MediaPlayer.vo.protection.MediaCapability[]} videoCapabilities\n * @param {string} [distinctiveIdentifier]\n * @param {string} [persistentState]\n * @constructor\n */\nMediaPlayer.vo.protection.KeySystemConfiguration = function(audioCapabilities, videoCapabilities, distinctiveIdentifier, persistentState, sessionTypes) {\n    this.initDataTypes = [ \"cenc\" ];\n    this.audioCapabilities = audioCapabilities;\n    this.videoCapabilities = videoCapabilities;\n    this.distinctiveIdentifier = distinctiveIdentifier;\n    this.persistentState = persistentState;\n    this.sessionTypes = sessionTypes;\n};\n\nMediaPlayer.vo.protection.KeySystemConfiguration.prototype = {\n    constructor: MediaPlayer.vo.protection.KeySystemConfiguration\n};","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Event indicating the receipt of a response from a license server\n *\n * @param message {Uint8Array} license response message\n * @param requestData a request-specific data object\n * @constructor\n */\nMediaPlayer.vo.protection.LicenseRequestComplete = function(message, requestData) {\n    \"use strict\";\n    this.message = message;\n    this.requestData = requestData;\n};\n\nMediaPlayer.vo.protection.LicenseRequestComplete.prototype = {\n    constructor: MediaPlayer.vo.protection.LicenseRequestComplete\n};\n\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n/**\n * A media capability\n *\n * @param {string} contentType MIME type and codecs (RFC6386)\n * @param {string} [robustness]\n * @constructor\n */\nMediaPlayer.vo.protection.MediaCapability = function(contentType, robustness) {\n    this.contentType = contentType;\n    this.robustness = robustness;\n};\n\nMediaPlayer.vo.protection.MediaCapability.prototype = {\n    constructor: MediaPlayer.vo.protection.MediaCapability\n};\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n/**\n * EME-independent NeedKey\n *\n * @param initData the initialization data\n * @param [initDataType] initialization data type\n * @constructor\n */\nMediaPlayer.vo.protection.NeedKey = function(initData, initDataType) {\n    this.initData = initData;\n    this.initDataType = initDataType;\n};\n\nMediaPlayer.vo.protection.NeedKey.prototype = {\n    constructor: MediaPlayer.vo.protection.NeedKey\n};\n\n","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Data used to customize KeySystems and override default or CDM-provided\n * values\n *\n * @param {string} laURL a license acquisition URL to use with this key system\n * @param {Object} httpRequestHeaders headers to add to the http request\n * @param {Object} bearerToken\n * @param {Object} clearkeys defines a set of clear keys that are available to\n * the key system.  Object properties are base64-encoded keyIDs (with no padding).\n * Corresponding property values are keys, base64-encoded (no padding).\n * @constructor\n */\nMediaPlayer.vo.protection.ProtectionData = function(laURL, httpRequestHeaders, bearerToken, clearkeys) {\n    this.laURL = laURL;\n    this.httpRequestHeaders = httpRequestHeaders;\n    this.bearerToken = bearerToken;\n    this.clearkeys = clearkeys;\n};\n\nMediaPlayer.vo.protection.ProtectionData.prototype = {\n    constructor: MediaPlayer.vo.protection.ProtectionData\n};","/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n/**\n * All session tokens returns by ProtectionModel implementations\n * are guaranteed to contain initialization data and optionally\n * session IDs\n *\n * @constructor\n */\nMediaPlayer.models.SessionToken = function () {\n    \"use strict\";\n};\n\nMediaPlayer.models.SessionToken.prototype = {\n\n    /**\n     * The initialization data used to create this session\n     *\n     * {Uint8Array} initialization data\n     */\n    initData: null,\n\n    /**\n     * The unique session ID designated to this session\n     *\n     * @return {string} the session ID or the empty string if the implementation\n     * does not support session IDs or the sessionID has not yet been established\n     */\n    getSessionID: function() { return \"\"; },\n\n    /**\n     * The time, in milliseconds since 01 January, 1970 UTC, after which\n     * the key(s) in the session will no longer be usable to decrypt\n     * media data, or NaN if no such time exists\n     *\n     * @returns {Number} the expiration time\n     */\n    getExpirationTime: function() { return NaN; },\n\n    /**\n     * Returns a read-only map of key IDs known to the session to the\n     * current status of the associated key.\n     *\n     * @returns {maplike<BufferSource,MediaKeyStatus>}\n     */\n    getKeyStatuses: function() { return null; }\n};\n\n\n\n","/**\n * This file contains an adaptation of the AES decryption algorithm\n * from the Standford Javascript Cryptography Library. That work is\n * covered by the following copyright and permissions notice:\n *\n * Copyright 2009-2010 Emily Stark, Mike Hamburg, Dan Boneh.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE\n * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN\n * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation\n * are those of the authors and should not be interpreted as representing\n * official policies, either expressed or implied, of the authors.\n */\n\nHls.dependencies.AES = function() {\n\n    /**\n    * Schedule out an AES key for both encryption and decryption. This\n    * is a low-level class. Use a cipher mode to do bulk encryption.\n    *\n    * @constructor\n    * @param key {Array} The key as an array of 4, 6 or 8 words.\n    */\n    this.init = function (key) {\n\n        /**\n         * The expanded S-box and inverse S-box tables. These will be computed\n         * on the client so that we don't have to send them down the wire.\n         *\n         * There are two tables, _tables[0] is for encryption and\n         * _tables[1] is for decryption.\n         *\n         * The first 4 sub-tables are the expanded S-box with MixColumns. The\n         * last (_tables[01][4]) is the S-box itself.\n         *\n         * @private\n         */\n        this._tables = [[[],[],[],[],[]],[[],[],[],[],[]]];\n\n        this._precompute.call(this);\n\n        var i, j, tmp,\n        encKey, decKey,\n        sbox = this._tables[0][4], decTable = this._tables[1],\n        keyLen = key.length, rcon = 1;\n\n        if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {\n            throw new Error('Invalid aes key size=' + keyLen);\n        }\n\n        encKey = key.slice(0);\n        decKey = [];\n        this._key = [encKey, decKey];\n\n        // schedule encryption keys\n        for (i = keyLen; i < 4 * keyLen + 28; i++) {\n            tmp = encKey[i-1];\n\n            // apply sbox\n            if (i%keyLen === 0 || (keyLen === 8 && i%keyLen === 4)) {\n                tmp = sbox[tmp>>>24]<<24 ^ sbox[tmp>>16&255]<<16 ^ sbox[tmp>>8&255]<<8 ^ sbox[tmp&255];\n\n                // shift rows and add rcon\n                if (i%keyLen === 0) {\n                    tmp = tmp<<8 ^ tmp>>>24 ^ rcon<<24;\n                    rcon = rcon<<1 ^ (rcon>>7)*283;\n                }\n            }\n\n            encKey[i] = encKey[i-keyLen] ^ tmp;\n        }\n\n        // schedule decryption keys\n        for (j = 0; i; j++, i--) {\n            tmp = encKey[j&3 ? i : i - 4];\n            if (i<=4 || j<4) {\n                decKey[j] = tmp;\n            } else {\n                decKey[j] = decTable[0][sbox[tmp>>>24]] ^\n                decTable[1][sbox[tmp>>16  & 255]] ^\n                decTable[2][sbox[tmp>>8   & 255]] ^\n                decTable[3][sbox[tmp      & 255]];\n            }\n        }\n    };\n\n    /**\n    * Expand the S-box tables.\n    *\n    * @private\n    */\n    this._precompute = function () {\n        var encTable = this._tables[0], decTable = this._tables[1],\n            sbox = encTable[4], sboxInv = decTable[4],\n            i, x, xInv, d=[], th=[], x2, x4, x8, s, tEnc, tDec;\n\n        // Compute double and third tables\n        for (i = 0; i < 256; i++) {\n            th[( d[i] = i<<1 ^ (i>>7)*283 )^i]=i;\n        }\n\n        for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {\n            // Compute sbox\n            s = xInv ^ xInv<<1 ^ xInv<<2 ^ xInv<<3 ^ xInv<<4;\n            s = s>>8 ^ s&255 ^ 99;\n            sbox[x] = s;\n            sboxInv[s] = x;\n\n            // Compute MixColumns\n            x8 = d[x4 = d[x2 = d[x]]];\n            tDec = x8*0x1010101 ^ x4*0x10001 ^ x2*0x101 ^ x*0x1010100;\n            tEnc = d[s]*0x101 ^ s*0x1010100;\n\n            for (i = 0; i < 4; i++) {\n                encTable[i][x] = tEnc = tEnc<<24 ^ tEnc>>>8;\n                decTable[i][s] = tDec = tDec<<24 ^ tDec>>>8;\n            }\n        }\n\n        // Compactify. Considerable speedup on Firefox.\n        for (i = 0; i < 5; i++) {\n            encTable[i] = encTable[i].slice(0);\n            decTable[i] = decTable[i].slice(0);\n        }\n    };\n\n    /**\n    * Decrypt 16 bytes, specified as four 32-bit words.\n    * @param encrypted0 {number} the first word to decrypt\n    * @param encrypted1 {number} the second word to decrypt\n    * @param encrypted2 {number} the third word to decrypt\n    * @param encrypted3 {number} the fourth word to decrypt\n    * @param out {Int32Array} the array to write the decrypted words\n    * into\n    * @param offset {number} the offset into the output array to start\n    * writing results\n    * @return {Array} The plaintext.\n    */\n    this.decrypt = function (encrypted0, encrypted1, encrypted2, encrypted3, out, offset) {\n        var key = this._key[1],\n            // state variables a,b,c,d are loaded with pre-whitened data\n            a = encrypted0 ^ key[0],\n            b = encrypted3 ^ key[1],\n            c = encrypted2 ^ key[2],\n            d = encrypted1 ^ key[3],\n            a2, b2, c2,\n\n            nInnerRounds = key.length / 4 - 2, // key.length === 2 ?\n            i,\n            kIndex = 4,\n            table = this._tables[1],\n\n            // load up the tables\n            table0    = table[0],\n            table1    = table[1],\n            table2    = table[2],\n            table3    = table[3],\n            sbox  = table[4];\n\n        // Inner rounds. Cribbed from OpenSSL.\n        for (i = 0; i < nInnerRounds; i++) {\n            a2 = table0[a>>>24] ^ table1[b>>16 & 255] ^ table2[c>>8 & 255] ^ table3[d & 255] ^ key[kIndex];\n            b2 = table0[b>>>24] ^ table1[c>>16 & 255] ^ table2[d>>8 & 255] ^ table3[a & 255] ^ key[kIndex + 1];\n            c2 = table0[c>>>24] ^ table1[d>>16 & 255] ^ table2[a>>8 & 255] ^ table3[b & 255] ^ key[kIndex + 2];\n            d  = table0[d>>>24] ^ table1[a>>16 & 255] ^ table2[b>>8 & 255] ^ table3[c & 255] ^ key[kIndex + 3];\n            kIndex += 4;\n            a=a2; b=b2; c=c2;\n        }\n\n        // Last round.\n        for (i = 0; i < 4; i++) {\n            out[(3 & -i) + offset] =\n            sbox[a>>>24      ]<<24 ^\n            sbox[b>>16  & 255]<<16 ^\n            sbox[c>>8   & 255]<<8  ^\n            sbox[d      & 255]     ^\n            key[kIndex++];\n            a2=a; a=b; b=c; c=d; d=a2;\n        }\n    };\n};\n\nHls.dependencies.AES.prototype = {\n    constructor: Hls.dependencies.AES\n};\n\nHls.dependencies.AES128Decrypter = function(key, iv) {\n    \"use strict\";\n\n    this.key = key;\n    this.iv = iv;\n\n    /**\n    * Convert network-order (big-endian) bytes into their little-endian\n    * representation.\n    */\n    this.ntoh = function(word) {\n        return (word << 24) |\n               ((word & 0xff00) << 8) |\n               ((word & 0xff0000) >> 8) |\n               (word >>> 24);\n    };\n\n    /**\n    * Decrypt bytes using AES-128 with CBC and PKCS#7 padding.\n    * @param encrypted {Uint8Array} the encrypted bytes\n    * @param key {Uint32Array} the bytes of the decryption key\n    * @param initVector {Uint32Array} the initialization vector (IV) to\n    * use for the first round of CBC.\n    * @return {Uint8Array} the decrypted bytes\n    *\n    * @see http://en.wikipedia.org/wiki/Advanced_Encryption_Standard\n    * @see http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_Block_Chaining_.28CBC.29\n    * @see https://tools.ietf.org/html/rfc2315\n    */\n    this.doDecrypt = function(encrypted, key, initVector) {\n        var\n            // word-level access to the encrypted bytes\n            encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2),\n\n            decipher = new Hls.dependencies.AES(),\n\n            // byte and word-level access for the decrypted output\n            decrypted = new Uint8Array(encrypted.byteLength),\n            decrypted32 = new Int32Array(decrypted.buffer),\n\n            // temporary variables for working with the IV, encrypted, and\n            // decrypted data\n            init0, init1, init2, init3,\n            encrypted0, encrypted1, encrypted2, encrypted3,\n\n            // iteration variable\n            wordIx;\n\n        decipher.init(Array.prototype.slice.call(key));\n\n        // pull out the words of the IV to ensure we don't modify the\n        // passed-in reference and easier access\n        init0 = ~~initVector[0];\n        init1 = ~~initVector[1];\n        init2 = ~~initVector[2];\n        init3 = ~~initVector[3];\n\n        // decrypt four word sequences, applying cipher-block chaining (CBC)\n        // to each decrypted block\n        for (wordIx = 0; wordIx < encrypted32.length; wordIx += 4) {\n            // convert big-endian (network order) words into little-endian\n            // (javascript order)\n            encrypted0 = ~~this.ntoh(encrypted32[wordIx]);\n            encrypted1 = ~~this.ntoh(encrypted32[wordIx + 1]);\n            encrypted2 = ~~this.ntoh(encrypted32[wordIx + 2]);\n            encrypted3 = ~~this.ntoh(encrypted32[wordIx + 3]);\n\n            // decrypt the block\n            decipher.decrypt(encrypted0,\n                encrypted1,\n                encrypted2,\n                encrypted3,\n                decrypted32,\n                wordIx);\n\n            // XOR with the IV, and restore network byte-order to obtain the\n            // plaintext\n            decrypted32[wordIx]     = this.ntoh(decrypted32[wordIx] ^ init0);\n            decrypted32[wordIx + 1] = this.ntoh(decrypted32[wordIx + 1] ^ init1);\n            decrypted32[wordIx + 2] = this.ntoh(decrypted32[wordIx + 2] ^ init2);\n            decrypted32[wordIx + 3] = this.ntoh(decrypted32[wordIx + 3] ^ init3);\n\n            // setup the IV for the next round\n            init0 = encrypted0;\n            init1 = encrypted1;\n            init2 = encrypted2;\n            init3 = encrypted3;\n        }\n\n        return decrypted;\n    };\n\n    this.localDecrypt = function(encrypted, key, initVector, decrypted) {\n        var bytes = this.doDecrypt(encrypted,\n            key,\n            initVector);\n            decrypted.set(bytes, encrypted.byteOffset);\n    };\n\n    this.decrypt = function(encrypted) {\n        var step = 4 * 8000,\n            //encrypted32 = new Int32Array(encrypted.buffer),\n            encrypted32 = new Int32Array(encrypted),\n            decrypted = new Uint8Array(encrypted.byteLength),\n            i = 0;\n\n        // split up the encryption job and do the individual chunks asynchronously\n        var key = this.key;\n        var initVector = this.iv;\n        this.localDecrypt(encrypted32.subarray(i, i + step), key, initVector, decrypted);\n\n        for (i = step; i < encrypted32.length; i += step) {\n            initVector = new Uint32Array([\n                this.ntoh(encrypted32[i - 4]),\n                this.ntoh(encrypted32[i - 3]),\n                this.ntoh(encrypted32[i - 2]),\n                this.ntoh(encrypted32[i - 1])\n            ]);\n            this.localDecrypt(encrypted32.subarray(i, i + step), key, initVector, decrypted);\n        }\n\n        return decrypted;\n    };\n};\n\nHls.dependencies.AES128Decrypter.prototype = {\n    constructor: Hls.dependencies.AES128Decrypter\n};","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nHls.dependencies.HlsDemux = function() {\n    \"use strict\";\n\n    var _appendArray = function(array1, array2) {\n        var tmp = new Uint8Array(array1.byteLength + array2.byteLength);\n        tmp.set(array1, 0);\n        tmp.set(array2, array1.byteLength);\n        return tmp;\n    };\n\n    // List of considered H.264 NALU types\n    var H264_NALU_TYPES = [1, 5, 6];\n\n    var trackIdCounter = 1,\n        pidToTrack = [],\n        tracks = [],\n        baseDts = -1,\n        dtsOffset = -1,\n\n        getTsPacket = function(data, offset, pid, pusi) {\n            var i = offset,\n                tsPacket;\n\n            while (i < data.length) {\n                tsPacket = new mpegts.ts.TsPacket();\n                tsPacket.parse(data.subarray(i, i + mpegts.ts.TsPacket.prototype.TS_PACKET_SIZE));\n\n                //this.debug.log(\"[HlsDemux] TS packet: pid=\" + tsPacket.getPid() + \", pusi = \" + tsPacket.getPusi());\n\n                if ((tsPacket.getPid() === pid) && ((pusi === undefined) || (tsPacket.getPusi() === pusi))) {\n                    return {\n                        offset: i,\n                        packet: tsPacket\n                    };\n                }\n\n                i += mpegts.ts.TsPacket.prototype.TS_PACKET_SIZE;\n            }\n\n            return null;\n        },\n\n        checkTsPacket = function(data) {\n            var tsPacket = new mpegts.ts.TsPacket();\n            return tsPacket.checkSyncWord(data.subarray(0, mpegts.ts.TsPacket.prototype.TS_PACKET_SIZE));\n        },\n\n        getPAT = function(data) {\n            var tsPacket = getTsPacket.call(this, data, 0, mpegts.ts.TsPacket.prototype.PAT_PID);\n\n            if (tsPacket === null) {\n                return null;\n            }\n\n            var pat = new mpegts.si.PAT();\n            pat.parse(tsPacket.packet.getPayload());\n\n            return pat;\n        },\n\n        getPMT = function(data, pid) {\n            var tsPacket = getTsPacket.call(this, data, 0, pid);\n\n            if (tsPacket === null) {\n                return null;\n            }\n\n            var pmt = new mpegts.si.PMT();\n            pmt.parse(tsPacket.packet.getPayload());\n\n            return pmt;\n        },\n\n        demuxTsPacket = function(data) {\n            var tsPacket,\n                pid,\n                track,\n                sample = null,\n                sampleData = null,\n                pesPacket;\n\n            tsPacket = new mpegts.ts.TsPacket();\n            tsPacket.parse(data);\n\n            // If packet has only adaptation field, then ignore\n            if (tsPacket.hasAdaptationFieldOnly()) {\n                return;\n            }\n\n            // Get PID and corresponding track\n            pid = tsPacket.getPid();\n            track = pidToTrack[pid];\n            if (!track) {\n                return;\n            }\n\n            // PUSI => start storing new AU\n            if (tsPacket.getPusi()) {\n\n                // Parse PES header\n                pesPacket = new mpegts.pes.PesPacket();\n                pesPacket.parse(tsPacket.getPayload());\n\n                // Store new access unit\n                sample = new MediaPlayer.vo.Mp4Track.Sample();\n                sample.cts = pesPacket.getPts().getValue();\n                sample.dts = (pesPacket.getDts() !== null) ? pesPacket.getDts().getValue() : sample.cts;\n                sample.size = 0;\n                sample.duration = 0;\n                sample.subSamples = [];\n\n                if (baseDts === -1) {\n                    baseDts = sample.dts;\n                }\n\n                // Store original MPEG2TS timestamp to help determining offset between absolute samples timestamps and MPEG2TS timestamps (see WebVTT parser)\n                sample.mpegTimestamp = sample.cts;\n\n                sample.dts -= baseDts;\n                sample.cts -= baseDts;\n\n                sample.dts += dtsOffset;\n                sample.cts += dtsOffset;\n\n                //this.debug.log(\"[HlsDemux][\" + track.type + \"] dts = \" + sample.dts + \", cts = \" + sample.cts);\n\n                // Store payload of PES packet as a subsample\n                sampleData = pesPacket.getPayload();\n\n                // Set sample flags\n                if (track.type === \"audio\") {\n                    sample.flags = 0x01000000; // sample_depends_on = 1, other flags = 0\n                }\n                if (track.type === \"video\" && (track.streamType.search('H.264') !== -1)) {\n                    // In case of H.264 stream, check if the sample is an IDR sample\n                    // If IDR: sample_depends_on = 2, sample_is_non_sync_sample = false\n                    // If non-IDR: sample_depends_on = 1, sample_is_non_sync_sample = true\n                    sample.flags = mpegts.h264.isIDR(sampleData) ? 0x02000000 : 0x01010000;\n                }\n\n                sample.subSamples.push(sampleData);\n\n                if (sample.dts >= 0) {\n                     track.samples.push(sample);\n                } else {\n                    // Check A/V desynchronisation\n                    var offset = Math.abs(sample.dts) / 90000;\n                    if (offset > 10) {\n                        throw {\n                            name: MediaPlayer.dependencies.ErrorHandler.prototype.HLS_DEMUX_ERROR,\n                            message: \"A/V desynchronization (\" + Math.round(offset) + \" s.)\"\n                        };\n                    }\n                }\n            } else if (track.samples.length > 0) {\n                // Get currently buffered access unit\n                sample = track.samples[track.samples.length - 1];\n\n                // Store payload of TS packet as a subsample\n                sample.subSamples.push(tsPacket.getPayload());\n            }\n        },\n\n        postProcess = function(track) {\n            var sample,\n                length = 0,\n                offset = 0,\n                subSamplesLength,\n                i, s;\n\n            if (track.samples.length === 0) {\n                return;\n            }\n\n            // Determine total length of track samples data\n            // Set samples duration and size\n            for (i = 0; i < track.samples.length; i++) {\n                subSamplesLength = 0;\n                sample = track.samples[i];\n\n                for (s = 0; s < sample.subSamples.length; s++) {\n                    subSamplesLength += sample.subSamples[s].length;\n                }\n\n                if (i > 0) {\n                    track.samples[i - 1].duration = track.samples[i].dts - track.samples[i - 1].dts;\n                }\n\n                sample.size = subSamplesLength;\n                length += subSamplesLength;\n            }\n            track.samples[track.samples.length - 1].duration = track.samples[track.samples.length - 2].duration;\n\n            // Allocate track data\n            track.data = new Uint8Array(length);\n\n            track.dataCTS = [];\n\n            for (i = 0; i < track.samples.length; i++) {\n                sample = track.samples[i];\n\n                // In case of ADTS, for each input sample (i.e. PES packet), we store the CTS (=PTS)\n                // in order to set the correct timestamp to each AAC frames after ADTS demultiplexing (see demuxADTS()),\n                // and then get around missing frames in input stream\n                if (track.streamType.search('ADTS') !== -1) {\n                    track.dataCTS[offset] = sample.cts;\n                }\n\n                // Copy all sub-sample parts into track data\n                for (s = 0; s < sample.subSamples.length; s++) {\n                    track.data.set(sample.subSamples[s], offset);\n                    offset += sample.subSamples[s].length;\n                }\n            }\n\n            // In case of H.264 stream, convert bytestream to MP4 format (NALU size field instead of start codes)\n            if (track.streamType.search('H.264') !== -1) {\n                convertH264Frames.call(this, track);\n            }\n\n            // In case of AAC-ADTS stream, demultiplex ADTS frames into AAC frames\n            // (Demultiplexing is performed on the whole segment data in case ADTS packets are not aligned\n            // on PES packets)\n            if (track.streamType.search('ADTS') !== -1) {\n                demuxADTS.call(this, track);\n            }\n\n            // Patch first frame timestamp and duration in case of missing frames at the end of the previous segment\n            if (track.previousCts && track.previousDuration) {\n                sample = track.samples[0];\n                var gap = sample.cts - (track.previousCts + track.previousDuration);\n                if (gap > 0 && gap < track.timescale) {\n                    sample.cts -= gap;\n                    sample.dts -= gap;\n                    sample.duration += gap;\n                    this.debug.log(\"[HlsDemux][\" + track.type + \"] Patch sample duration, cts = \" + (sample.cts / 90000).toFixed(3) + \", duration = \" + (sample.duration / 90000).toFixed(3));\n                }\n            }\n\n        },\n\n        convertH264Frames = function(track) {\n            var sample,\n                nalu,\n                totalLength,\n                data,\n                offset,\n                i, n;\n\n            // Parse all NALUs and determine total data length according to filtered NALUs\n            totalLength = 0;\n            offset = 0;\n            for (i = 0; i < track.samples.length; i++) {\n                sample = track.samples[i];\n                sample.nalus = mpegts.h264.parseNALUs(track.data.subarray(offset, offset + sample.size));\n                for (n = 0; n < sample.nalus.length; n++) {\n                    nalu = sample.nalus[n];\n                    // this.debug.log(\"[HlsDemux][\" + track.type + \"] H264 NALU, type = \" + nalu.type + \", size = \" + nalu.size + \" - write: \" + (H264_NALU_TYPES.indexOf(nalu.type) !== -1));\n                    if (H264_NALU_TYPES.indexOf(nalu.type) !== -1) {\n                        // Set NALU offset relative to whole data array\n                        nalu.offset += offset;\n                        totalLength += 4 + sample.nalus[n].size; // 4 = NALUSize field length\n                    } else {\n                        // Remove NALU\n                        sample.nalus.splice(n, 1);\n                        n--;\n                    }\n                }\n                offset += sample.size;\n            }\n\n            // Allocate new data\n            data = new Uint8Array(totalLength);\n\n            // Copy all NALUs from each sample (AU) into output data\n            offset = 0;\n            for (i = 0; i < track.samples.length; i++) {\n                sample = track.samples[i];\n                sample.size = 0;\n                for (n = 0; n < sample.nalus.length; n++) {\n                    nalu = sample.nalus[n];\n                    data[offset++] = (nalu.size & 0xFF000000) >> 24;\n                    data[offset++] = (nalu.size & 0x00FF0000) >> 16;\n                    data[offset++] = (nalu.size & 0x0000FF00) >> 8;\n                    data[offset++] = (nalu.size & 0x000000FF);\n                    data.set(track.data.subarray(nalu.offset, nalu.offset + nalu.size), offset);\n                    offset += nalu.size;\n                    sample.size += 4 + nalu.size;\n                }\n            }\n\n            // Replace track data with converted H.264 frames\n            track.data = data;\n        },\n\n        demuxADTS = function(track) {\n            var aacFrames,\n                aacSamples = [],\n                length,\n                offset,\n                data,\n                sample,\n                cts,\n                duration,\n                i;\n\n            // Parse AAC-ADTS access units and get AAC frames description\n            aacFrames = mpegts.aac.parseADTS(track.data, track.dataCTS);\n\n            // And determine total length of AAC frames\n            length = 0;\n            for (i = 0; i < aacFrames.length; i++) {\n                length += aacFrames[i].length;\n            }\n\n            // Allocate new data section that will contains all AAC frames\n            data = new Uint8Array(length);\n\n            // Store first sample info\n            cts = track.samples[0].cts;\n\n            // Determine sample duration\n            duration = track.timescale * 1024.0 / track.samplingRate;\n\n            // Copy AAC frames data and create AAC samples\n            offset = 0;\n            for (i = 0; i < aacFrames.length; i++) {\n                // Create sample\n                sample = new MediaPlayer.vo.Mp4Track.Sample();\n\n                // Set CTS according to ADTS frame CTS (=PES CTS) or according to sample duration\n                sample.cts = sample.dts = (aacFrames[i].cts ? aacFrames[i].cts : cts);\n                sample.size = aacFrames[i].length;\n                sample.duration = duration;\n                sample.flags = 0x01000000; // sample_depends_on = 1, other flags = 0\n\n                // Store original MPEG2TS timestamp to help determining offset between absolute samples timestamps and MPEG2TS timestamps (see WebVTT parser)\n                if (aacSamples.length === 0) {\n                    sample.mpegTimestamp = track.samples[0].mpegTimestamp;\n                }\n\n                aacSamples.push(sample);\n\n                // Update cts for next frame\n                cts = sample.cts + duration;\n\n                // Update previous sample duration in case of missing frames\n                if (i > 0) {\n                    aacSamples[i - 1].duration = aacSamples[i].cts - aacSamples[i - 1].cts;\n                    if (aacSamples[i - 1].duration > duration) {\n                        this.debug.log(\"[HlsDemux][\" + track.type + \"] Patch sample duration, cts = \" + (aacSamples[i - 1].cts / 90000).toFixed(3) + \", duration = \" + (aacSamples[i - 1].duration / 90000).toFixed(3));\n                    }\n                }\n\n                // Copy AAC frame data\n                data.set(track.data.subarray(aacFrames[i].offset, aacFrames[i].offset + aacFrames[i].length), offset);\n                offset += aacFrames[i].length;\n            }\n\n            // Replace track data\n            track.data = data;\n\n            // Replace track's AAC-ADTS samples by demultiplexed AAC samples\n            track.samples = aacSamples;\n        },\n\n        arrayToHexString = function(array) {\n            var str = \"\",\n                i = 0,\n                h = 0;\n\n            for (i = 0; i < array.length; i++) {\n                h = array[i].toString(16);\n                if (h.length < 2) {\n                    h = \"0\" + h;\n                }\n                str += h;\n            }\n            return str;\n        },\n\n        doReset = function() {\n            this.debug.log(\"[HlsDemux] Reset\");\n            // pat = null;\n            // pmt = null;\n            trackIdCounter = 1;\n            pidToTrack = [];\n            tracks = [];\n            baseDts = -1;\n            dtsOffset = -1;\n        },\n\n\n        getTrackCodecInfo = function(data, track) {\n            var tsPacket,\n                pesPacket,\n                esBytes,\n                sequenceHeader,\n                nalHeader,\n                codecPrivateData,\n                objectType,\n                samplingFrequencyIndex;\n\n            // Get first TS packet containing start of a PES/sample\n            tsPacket = getTsPacket.call(this, data, 0, track.pid, true);\n\n            // We have no packet of track's PID , need some more packets to get track info\n            if (tsPacket === null) {\n                // We throw an error since the <video> element will raise a MEDIA_ERR_SRC_NOT_SUPPORTED error\n                // when pushing the initialization segment\n                throw {\n                    name: MediaPlayer.dependencies.ErrorHandler.prototype.HLS_DEMUX_ERROR,\n                    message: \"No packets for track \" + track.type\n                };\n            }\n\n            // Get PES packet\n            pesPacket = new mpegts.pes.PesPacket();\n            pesPacket.parse(tsPacket.packet.getPayload());\n            esBytes = pesPacket.getPayload();\n\n            // H264\n            if (track.streamType.search('H.264') !== -1) {\n                sequenceHeader = mpegts.h264.getSequenceHeader(esBytes);\n\n                while (sequenceHeader === null) {\n                    tsPacket = getTsPacket.call(this, data, (tsPacket.offset + mpegts.ts.TsPacket.prototype.TS_PACKET_SIZE), track.pid, false);\n                    esBytes = _appendArray(esBytes, tsPacket.packet.getPayload());\n                    sequenceHeader = mpegts.h264.getSequenceHeader(esBytes);\n                }\n\n                track.codecPrivateData = arrayToHexString(sequenceHeader.bytes);\n                track.codecs = \"avc1.\";\n\n                // Extract from the CodecPrivateData field the hexadecimal representation of the following\n                // three bytes in the sequence parameter set NAL unit.\n                // => Find the SPS nal header\n                nalHeader = /00000001[0-9]7/.exec(track.codecPrivateData);\n                if (nalHeader && nalHeader[0]) {\n                    // => Take the 6 characters after the SPS nalHeader (if it exists)\n                    track.codecs += track.codecPrivateData.substr(track.codecPrivateData.indexOf(nalHeader[0]) + 10, 6);\n                }\n\n                // Extract width and height from SPS\n                track.width = sequenceHeader.width;\n                track.height = sequenceHeader.height;\n                this.debug.log(\"[HlsDemux] width  = \" + track.width);\n                this.debug.log(\"[HlsDemux] height = \" + track.height);\n            }\n\n            // AAC\n            if (track.streamType.search('AAC') !== -1) {\n                codecPrivateData = mpegts.aac.getAudioSpecificConfig(esBytes);\n                objectType = (codecPrivateData[0] & 0xF8) >> 3;\n                track.codecPrivateData = arrayToHexString(codecPrivateData);\n                track.codecs = \"mp4a.40.\" + objectType;\n\n                samplingFrequencyIndex = (codecPrivateData[0] & 0x07) << 1 | (codecPrivateData[1] & 0x80) >> 7;\n                track.samplingRate = mpegts.aac.SAMPLING_FREQUENCY[samplingFrequencyIndex];\n                track.channels = (codecPrivateData[1] & 0x78) >> 3;\n                track.bandwidth = 0;\n                /* code for HE AAC v2 to be tested\n                var arr16 = new Uint16Array(2);\n                arr16[0] = (codecPrivateData[0] << 8) + codecPrivateData[1];\n                arr16[1] = (codecPrivateData[2] << 8) + codecPrivateData[3];\n                //convert decimal to hex value\n                var codecPrivateDataHex = arr16[0].toString(16)+arr16[1].toString(16);\n                track.codecPrivateData = codecPrivateDataHex.toUpperCase();*/\n            }\n\n            this.debug.log(\"[HlsDemux] codecs = \" + track.codecs);\n            this.debug.log(\"[HlsDemux] codecPrivateData = \" + track.codecPrivateData);\n        },\n\n        doGetTracks = function(data) {\n            var i = 0,\n                pat,\n                pmt,\n                es,\n                pid,\n                track,\n                streamTypeDesc;\n\n            // First, check that packet is really a TS packet\n            if( !checkTsPacket.call(this,data) ) {\n                throw {\n                    name: MediaPlayer.dependencies.ErrorHandler.prototype.HLS_INVALID_PACKET_ERROR,\n                    message: \"Failed to demux, packet is invalid, missing SYNC byte\"\n                };\n            }\n\n            // Get PSI (PAT, PMT)\n            pat = getPAT.call(this, data);\n            if (pat === null) {\n                throw {\n                    name: MediaPlayer.dependencies.ErrorHandler.prototype.HLS_DEMUX_ERROR,\n                    message: \"Failed to demux, missing signalization (PAT)\"\n                };\n            }\n\n            pmt = getPMT.call(this, data, pat.getPmtPid());\n            if (pmt === null) {\n                throw {\n                    name: MediaPlayer.dependencies.ErrorHandler.prototype.HLS_DEMUX_ERROR,\n                    message: \"Failed to demux, missing signalization (PMT)\"\n                };\n            }\n\n            // Create a track for each elementary stream\n            for (i = 0; i < pmt.m_listOfComponents.length; i++) {\n                es = pmt.m_listOfComponents[i];\n                pid = es.m_elementary_PID;\n\n                track = pidToTrack[pid];\n\n                if (!track) {\n                    // Create new track\n                    track = new MediaPlayer.vo.Mp4Track();\n                    track.timescale = mpegts.Pts.prototype.SYSTEM_CLOCK_FREQUENCY;\n                    track.pid = pid;\n\n                    // Get elemantary stream type\n                    streamTypeDesc = pmt.gStreamTypes[es.m_stream_type];\n                    if (streamTypeDesc === null) {\n                        this.debug.log(\"[HlsDemux] Stream Type \" + es.m_stream_type + \" unknown!\");\n                        continue;\n                    }\n\n                    // Determine track type\n                    track.streamType = streamTypeDesc.name;\n                    switch (streamTypeDesc.value) {\n                        case 0xE0:\n                            track.type = \"video\";\n                            break;\n                        case 0xC0:\n                            track.type = \"audio\";\n                            break;\n                        case 0xFC:\n                            track.type = \"data\";\n                            break;\n                        default:\n                            track.type = \"und\";\n                    }\n                }\n\n                // Get/update track codec details\n                getTrackCodecInfo.call(this, data, track);\n                if (track.codecs === \"\") {\n                    throw {\n                        name: MediaPlayer.dependencies.ErrorHandler.prototype.HLS_DEMUX_ERROR,\n                        message: \"Failed to get codec information for track \" + track.type\n                    };\n                }\n\n                if (!pidToTrack[pid]) {\n                    // Set trackId\n                    track.trackId = trackIdCounter;\n                    trackIdCounter++;\n                    this.debug.log(\"[HlsDemux] Add track: type = \" + track.type + \", PID = \" + track.pid + \", trackId = \" + track.trackId);\n                    tracks.push(track);\n                    pidToTrack[pid] = track;\n                }\n            }\n\n            return tracks;\n        },\n\n        doDemux = function(data, request) {\n            var track,\n                i = 0,\n                firstDts = -1,\n                offset;\n\n            if (dtsOffset === -1) {\n                dtsOffset = request.startTime * 90000;\n                this.debug.log(\"[HlsDemux] Media start time = \" + dtsOffset + \" (\" + request.startTime + \")\");\n            }\n\n            this.debug.log(\"[HlsDemux] Demux chunk, size = \" + data.length + \", nb packets = \" + Math.round(data.length / mpegts.ts.TsPacket.prototype.TS_PACKET_SIZE));\n\n            // Get PAT, PMT and tracks information if not yet received\n            doGetTracks.call(this, data);\n\n            // Clear current tracks' data\n            for (i = 0; i < tracks.length; i++) {\n                track = tracks[i];\n\n                // Store last sample timestamp and duration (in case of lost/missing samples)\n                if (track.samples.length > 0) {\n                    track.previousCts = track.samples[track.samples.length - 1].cts;\n                    track.previousDuration = track.samples[track.samples.length - 1].duration;\n                }\n\n                tracks[i].samples = [];\n                tracks[i].data = null;\n            }\n\n            // Parse and demux TS packets\n            i = 0;\n            while (i < data.length) {\n                if ((i + mpegts.ts.TsPacket.prototype.TS_PACKET_SIZE) > data.length) {\n                    this.debug.log(\"[HlsDemux] Demux chunk, residual bytes = \" + (data.length - i));\n                    break;\n                }\n                demuxTsPacket.call(this, data.subarray(i, i + mpegts.ts.TsPacket.prototype.TS_PACKET_SIZE));\n                i += mpegts.ts.TsPacket.prototype.TS_PACKET_SIZE;\n            }\n\n            // Re-assemble samples from sub-samples\n            //this.debug.log(\"[HlsDemux] Demux: baseDts = \" + baseDts + \", dtsOffset = \" + dtsOffset);\n            for (i = 0; i < tracks.length; i++) {\n                track = tracks[i];\n\n                if (track.samples.length === 0) {\n                    continue;\n                }\n\n                postProcess.call(this, track);\n\n                this.debug.log(\"[HlsDemux][\" + track.type + \"] Demux: 1st PTS = \" + track.samples[0].dts + \" (\" + (track.samples[0].dts / 90000) + \")\");\n\n                // Check tracks desynchronization (if > 10 sec)\n                firstDts = Math.max(firstDts, track.samples[0].dts);\n                offset = Math.abs(track.samples[0].dts - firstDts) / 90000;\n                if (offset > 10) {\n                    throw {\n                        name: MediaPlayer.dependencies.ErrorHandler.prototype.HLS_DEMUX_ERROR,\n                        message: \"A/V desynchronization (\" + Math.round(offset) + \" s.)\"\n                    };\n                }\n            }\n\n            var _tracks = [];\n            for (i = 0; i < tracks.length; i++) {\n                if (tracks[i].samples.length > 0) {\n                    _tracks.push(tracks[i]);\n                }\n            }\n\n            return _tracks;\n        };\n\n    return {\n        debug: undefined,\n\n        reset: doReset,\n        getTracks: doGetTracks,\n        demux: doDemux\n    };\n};\n\nHls.dependencies.HlsDemux.prototype = {\n    constructor: Hls.dependencies.HlsDemux\n};\n","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nHls.dependencies.HlsFragmentController = function () {\n    \"use strict\";\n\n    var decryptionInfos = {},\n\n        generateMediaSegment = function (data, request) {\n            var i = 0,\n                // Demultiplex HLS chunk to get samples\n                tracks = rslt.hlsDemux.demux(new Uint8Array(data), request);\n\n            // Update fragment start time (=tfdt)\n            for (i = 0; i < tracks.length; i += 1) {\n\n                if (!rslt.manifestModel.getValue().timestampMap && tracks[i].samples[0].mpegTimestamp) {\n                    rslt.manifestModel.getValue().timestampMap = {\n                        local: tracks[i].samples[0].cts / 90000.0,\n                        mpegts: tracks[i].samples[0].mpegTimestamp\n                    };\n                }\n            }\n\n            // Generate init (moov) and media segment (moof)\n            return rslt.mp4Processor.generateInitMediaSegment(tracks);\n        },\n\n        createInitializationVector = function (segmentNumber) {\n            var uint8View = new Uint8Array(16),\n                i = 0;\n\n            for (i = 12; i < 16; i++) {\n                uint8View[i] = (segmentNumber >> 8 * (15 - i)) & 0xff;\n            }\n\n            return uint8View;\n        },\n\n        decrypt = function (data, decryptionInfo) {\n\n            var t = new Date();\n\n            var view = new DataView(decryptionInfo.key.buffer);\n            var key = new Uint32Array([\n                view.getUint32(0),\n                view.getUint32(4),\n                view.getUint32(8),\n                view.getUint32(12)\n            ]);\n\n            view = new DataView(createInitializationVector(decryptionInfo.iv).buffer);\n            var iv = new Uint32Array([\n                view.getUint32(0),\n                view.getUint32(4),\n                view.getUint32(8),\n                view.getUint32(12)\n            ]);\n\n            var decrypter = new Hls.dependencies.AES128Decrypter(key, iv);\n            rslt.debug.log(\"[HlsFragmentController] decrypted chunk (\" + (((new Date()).getTime() - t.getTime()) / 1000).toFixed(3) + \"s.)\");\n\n            return decrypter.decrypt(data);\n        },\n\n        loadDecryptionKey = function (decryptionInfo) {\n            var deferred = Q.defer();\n\n            this.debug.log(\"[HlsFragmentController]\", \"Load decryption key: \" + decryptionInfo.uri);\n            var xhr = new MediaPlayer.dependencies.XHRLoader();\n            // Do not retry for encrypted key, we assume the key file has to be present if playlist if present\n            xhr.initialize('arraybuffer', 0, 0);\n            xhr.load(decryptionInfo.uri).then(\n                function (request) {\n                    decryptionInfo.key = new Uint8Array(request.response);\n                    deferred.resolve();\n                },\n                function (request) {\n                    if (!request || request.aborted) {\n                        deferred.reject();\n                    } else {\n                        deferred.reject({\n                            name: MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_MANIFEST,\n                            message: \"Failed to download HLS decryption key\",\n                            data: {\n                                url: decryptionInfo.uri,\n                                status: request.status\n                            }\n                        });\n                    }\n                }\n            );\n\n            return deferred.promise;\n        },\n\n        decryptSegment = function (bytes, request) {\n            var deferred = Q.defer(),\n                decryptionInfo,\n                self = this;\n\n            if (!request.decryptionInfo || request.decryptionInfo.method === \"NONE\") {\n                deferred.resolve(bytes);\n                return deferred.promise;\n            }\n\n            // check if decryption key has not been already downloaded\n            // if (!manifest.decryptionInfos) {\n            //     manifest.decryptionInfos = {};\n            // }\n            decryptionInfo = decryptionInfos[request.decryptionInfo.uri];\n            if (decryptionInfo) {\n                deferred.resolve(decrypt.call(this, bytes, decryptionInfo));\n            } else {\n                decryptionInfo = request.decryptionInfo;\n                loadDecryptionKey.call(this, decryptionInfo).then(\n                    function () {\n\n                        // check key\n                        if (decryptionInfo.key && decryptionInfo.key.byteLength !== 16) {\n                            return deferred.reject({\n                                name: MediaPlayer.dependencies.ErrorHandler.prototype.HLS_INVALID_KEY_ERROR,\n                                message: \"Invalid HLS key - Key length (\" + decryptionInfo.key.byteLength + \") does not respect specification\"\n                            });\n                        }\n                        decryptionInfos[decryptionInfo.uri] = decryptionInfo;\n                        deferred.resolve(decrypt.call(self, bytes, decryptionInfo));\n                    },\n                    function (e) {\n                        deferred.reject(e);\n                    }\n                );\n            }\n\n            return deferred.promise;\n        };\n\n    var rslt = MediaPlayer.utils.copyMethods(MediaPlayer.dependencies.FragmentController);\n\n    rslt.manifestModel = undefined;\n    rslt.hlsDemux = undefined;\n    rslt.mp4Processor = undefined;\n\n    rslt.process = function (bytes, request /*, representation*/ ) {\n        var deferred = Q.defer(),\n            result = null;\n\n        if ((bytes === null) || (bytes === undefined) || (bytes.byteLength === 0)) {\n            deferred.resolve(null);\n            return deferred.promise;\n        }\n\n        if (!request || (request.type !== \"Media Segment\")) {\n            deferred.resolve(null);\n            return deferred.promise;\n        }\n\n        // If text track (WebVTT), then do not process segment\n        if (request.streamType === 'text') {\n            deferred.resolve(bytes);\n            return deferred.promise;\n        }\n\n        // Decrypt the segment if encrypted\n        decryptSegment.call(rslt, bytes, request).then(function (data) {\n            //console.saveBinArray(data, request.url.substring(request.url.lastIndexOf('/') + 1));\n            try {\n                // First check stream has not been reset while decrypting the chunk\n                if (!rslt.manifestModel.getValue()) {\n                    deferred.resolve(null);\n                } else {\n                    // Generate media segment (moof) from demultiplexed MPEG2-TS chunk\n                    result = generateMediaSegment(data, request);\n                    rslt.sequenceNumber++;\n                    deferred.resolve(result);\n                }\n            } catch (e) {\n                deferred.reject(e);\n            }\n        }, function (e) {\n            deferred.reject(e);\n        });\n\n        //return result;\n        return deferred.promise;\n    };\n\n    return rslt;\n};\n\nHls.dependencies.HlsFragmentController.prototype = {\n    constructor: Hls.dependencies.HlsFragmentController\n};\n","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nHls.dependencies.HlsHandler = function() {\n    \"use strict\";\n    var getInit = function(representation) {\n        var period = null,\n            self = this,\n            presentationStartTime = null,\n            deferred = Q.defer(),\n            manifest,\n            isDynamic,\n            request;\n\n        //Mss.dependencies.MssHandler.prototype.getInitRequest.call(this,quality,data).then(onGetInitRequestSuccess);\n        // get the period and startTime\n        period = representation.adaptation.period;\n        presentationStartTime = period.start;\n\n        manifest = rslt.manifestModel.getValue();\n        isDynamic = rslt.manifestExt.getIsDynamic(manifest);\n\n        request = new MediaPlayer.vo.SegmentRequest();\n\n        request.streamType = rslt.getType();\n        request.type = \"Initialization Segment\";\n        request.url = null;\n        request.data = 1; //used to activate Loaded event in BufferControler\n        request.range = representation.range;\n        request.availabilityStartTime = self.timelineConverter.calcAvailabilityStartTimeFromPresentationTime(presentationStartTime, representation.adaptation.period.mpd, isDynamic);\n        request.availabilityEndTime = self.timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationStartTime + period.duration, period.mpd, isDynamic);\n\n        request.quality = representation.index;\n        deferred.resolve(request);\n        return deferred.promise;\n    };\n\n    var rslt = MediaPlayer.utils.copyMethods(Dash.dependencies.DashHandler);\n\n    rslt.getInitRequest = getInit;\n\n    return rslt;\n};\n\nHls.dependencies.HlsHandler.prototype = {\n    constructor: Hls.dependencies.HlsHandler\n};","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nHls.dependencies.HlsParser = function() {\n    var REGEXP_EXTXSTREAMINF = /#EXT-X-STREAM-INF:([^\\n\\r]*)[\\r\\n]+([^\\r\\n]+)/g,\n        REGEXP_EXTXMEDIA = /#EXT-X-MEDIA:(.*)/g,\n        REGEXP_EXTXMEDIASEQUENCE = '(?:#(EXT-X-MEDIA-SEQUENCE):*(\\\\d+))',\n        REGEXP_EXTXTARGETDURATION = '(?:#(EXT-X-TARGETDURATION):*(\\\\d+))',\n        REGEXP_EXTXPROGRAMDATETIME = '(?:#(EXT-X-PROGRAM-DATE-TIME):*(.+))',\n        REGEXP_EXTXKEY = '(?:#(EXT-X-KEY):(.+))',\n        REGEXP_EXTXINF = '(?:#(EXTINF):*(\\\\d+(?:\\\\.\\\\d+)?)(?:,(.*))?[\\r\\n]*(.*))',\n        REGEXP_EXTXENDLIST = '(?:#(EXT-X-ENDLIST))',\n        REGEXP_ATTRIBUTES = /\\s*(.+?)\\s*=((?:\\\".*?\\\")|.*?)(?:,|$)/g,\n        REGEXP_PLAYLIST = new RegExp('(?:' +\n                                     REGEXP_EXTXMEDIASEQUENCE + '|' +\n                                     REGEXP_EXTXTARGETDURATION + '|' +\n                                     REGEXP_EXTXPROGRAMDATETIME + '|' +\n                                     REGEXP_EXTXKEY + '|' +\n                                     REGEXP_EXTXINF + '|' +\n                                     REGEXP_EXTXENDLIST +\n                                     ')', 'g'),\n        DEFAULT_RETRY_ATTEMPTS = 2,\n        DEFAULT_RETRY_INTERVAL = 500,\n        retryAttempts = DEFAULT_RETRY_ATTEMPTS,\n        retryInterval = DEFAULT_RETRY_INTERVAL,\n        xhrLoader,\n\n        getTagAttributes = function (attributes) {\n            var attrs = {},\n                match, name, value;\n\n            while ((match = REGEXP_ATTRIBUTES.exec(attributes)) !== null) {\n                name = match[1];\n                value = match[2].replace(/\"/g, ''); // Remove '\"' characters\n                attrs[name] = value;\n            }\n            return attrs;\n        },\n\n        getAbsoluteURI = function(uri, baseUrl) {\n            if ((uri.indexOf(\"http://\") === 0) ||\n                (uri.indexOf(\"https://\") === 0)) {\n                return uri;\n            }\n\n            return baseUrl + uri;\n        },\n\n        getVariantStreams = function(manifest) {\n            var streams = [], stream,\n                match, attrs,\n                codecs, audioCodec, videoCodec,\n                resolution, width, height,\n                i;\n\n            while ((match = REGEXP_EXTXSTREAMINF.exec(manifest)) !== null) {\n                attrs = getTagAttributes(match[1]);\n\n                codecs = attrs['CODECS'] || '';\n\n                codecs = codecs.split(',');\n                audioCodec = videoCodec = '';\n                for (i = 0; i < codecs.length; i++) {\n                    if (codecs[i].indexOf('avc1') !== -1) {\n                        videoCodec = codecs[i];\n                    } else {\n                        audioCodec = codecs[i];\n                    }\n                }\n\n                resolution = attrs['RESOLUTION'] || '0x0';\n                resolution = resolution.split('x');\n                width = parseInt(resolution[0], 10);\n                height = parseInt(resolution[1], 10);\n\n                stream = {\n                    programId: attrs['PROGRAM-ID'] || '',\n                    bandwidth: parseInt(attrs['BANDWIDTH'] || '0', 10),\n                    audioCodec: audioCodec,\n                    videoCodec: videoCodec,\n                    width: width,\n                    height: height,\n                    audioId: attrs['AUDIO'] || '',\n                    subtitlesId: attrs['SUBTITLES'] || '',\n                    uri: match[2]\n                };\n                streams.push(stream);\n            }\n            return streams;\n        },\n\n        getMedias = function(manifest) {\n            var medias = [],\n                match, attrs, type, media;\n\n            while ((match = REGEXP_EXTXMEDIA.exec(manifest)) !== null) {\n                attrs = getTagAttributes(match[1]);\n                // Ignore if type attribute is not set\n                type = (attrs['TYPE'] || '').toLowerCase();\n                if (type.length === 0) {\n                    break;\n                }\n                media = {\n                    type: type,\n                    groupId: attrs['GROUP-ID'] || '',\n                    name: type + (attrs['NAME'] ? ('_' + attrs['NAME']) : ''),\n                    language: attrs['LANGUAGE'] || '',\n                    autoSelect: attrs['AUTO-SELECT'] === 'YES' ? true : false,\n                    default: attrs['SUTITLES'] === 'YES' ? true : false,\n                    uri: attrs['URI'] || ''\n                };\n                medias.push(media);\n            }\n            return medias;\n        },\n\n        removeSegments = function(segments, sequenceNumber) {\n            for (var i = 0; i < segments.length; i++) {\n                if (segments[i].sequenceNumber < sequenceNumber) {\n                    segments.shift();\n                    i--;\n                } else {\n                    break;\n                }\n            }\n        },\n\n        parsePlaylist = function(manifest, representation, adaptation) {\n            var segmentList,\n                segments,\n                segment,\n                initialization,\n                decryptionInfo = null,\n                duration = 0,\n                sequenceNumber = 0,\n                programDateTime = null,\n                i;\n\n            // Check playlist header\n            if (!manifest || (manifest && manifest.length < 0)) {\n                return false;\n            }\n\n            // this.debug.log(manifest);\n\n            if (manifest.indexOf('#EXTM3U') !== 0) {\n                return false;\n            }\n\n            segmentList = representation['SegmentList'];\n            if (!segmentList) {\n                // Initialize SegmentList\n                segmentList = {\n                    name: 'SegmentList',\n                    isRoot: false,\n                    isArray: false,\n                    // children: [],\n                    duration: 0,\n                    startNumber: 0,\n                    timescale: 1,\n                    BaseURL: representation.BaseURL,\n                    SegmentURL_asArray: []\n                };\n                representation['SegmentList'] = segmentList;\n            }\n\n            segments = segmentList.SegmentURL_asArray;\n\n            // Set representation duration, by default set to  (=\"dynamic\")\n            representation.duration = Infinity;\n\n            var match, tag, attrs;\n\n            while ((match = REGEXP_PLAYLIST.exec(manifest)) !== null) {\n                match = match.filter(function(n) { return (n !== undefined); });\n                tag = match[1];\n\n                switch (tag) {\n                    case 'EXT-X-MEDIA-SEQUENCE':\n                        sequenceNumber = parseInt(match[2]);\n                        segmentList.startNumber = sequenceNumber;\n                        break;\n                    case 'EXT-X-TARGETDURATION':\n                        segmentList.duration = parseInt(match[2]);\n                        break;\n                    case 'EXT-X-KEY':\n                        attrs = getTagAttributes(match[2]);\n                        decryptionInfo = {\n                            method: attrs['METHOD'] || 'NONE',\n                            uri: getAbsoluteURI(attrs['URI'], segmentList.BaseURL),\n                            iv: attrs['IV']\n                        };\n                        break;\n                    case 'EXTINF':\n                        segment = {\n                            name: \"SegmentURL\",\n                            isRoot: false,\n                            isArray: true,\n                            media: getAbsoluteURI(match[4], segmentList.BaseURL),\n                            sequenceNumber: sequenceNumber,\n                            time: (segments.length === 0) ? 0 : segments[segments.length - 1].time + segments[segments.length - 1].duration,\n                            duration: parseFloat(match[2]),\n                            decryptionInfo: decryptionInfo\n                        };\n\n                        if (segment.decryptionInfo && !segment.decryptionInfo.iv) {\n                            segment.decryptionInfo.iv = segment.sequenceNumber;\n                        }\n\n                        if (segments.length === 0 || segment.sequenceNumber > segments[segments.length-1].sequenceNumber) {\n                            segments.push(segment);\n                        }\n                        sequenceNumber++;\n                        duration += segment.duration;\n\n                        if (programDateTime) {\n                            segment.programDateTime = programDateTime;\n                            programDateTime += (segment.duration * 1000);\n                        }\n\n                        break;\n                    case 'EXT-X-ENDLIST':\n                        representation.duration = duration;\n                        break;\n                    case 'EXT-X-PROGRAM-DATE-TIME':\n                        programDateTime = Date.parse(match[2]);\n                        break;\n                    default:\n                        break;\n                }\n            }\n\n            // Remove segments from previous playlist\n            removeSegments(segments, segmentList.startNumber);\n\n            // Correct segments timeline according to previous segment list (in case of variant stream switching)\n            if (adaptation.segments) {\n                // Align segment list according to sequence number\n                removeSegments(segments, adaptation.segments[0].sequenceNumber);\n                removeSegments(adaptation.segments, segments[0].sequenceNumber);\n                if (segments[0].time !== adaptation.segments[0].time) {\n                    segments[0].time = adaptation.segments[0].time;\n                    for (i = 1; i < segments.length; i++) {\n                        segments[i].time = segments[i - 1].time + segments[i - 1].duration;\n                    }\n                }\n            }\n\n            adaptation.segments = segments;\n\n            var range = {\n                start: segments[0].time,\n                end: segments[segments.length - 1].time + segments[segments.length - 1].duration\n            };\n\n            if (programDateTime) {\n                range.programStart = segments[0].programDateTime;\n                range.programEnd = segments[segments.length - 1].programDateTime + segments[segments.length - 1].duration;\n            }\n\n            if (adaptation.contentType === 'video') {\n                this.metricsModel.addDVRInfo('video', new Date(), range);\n            }\n\n            // Set initialization segment info\n            initialization = {\n                name: \"Initialization\",\n                sourceURL: representation.SegmentList.SegmentURL_asArray[0].media\n            };\n            representation.SegmentList.Initialization = initialization;\n\n            // PATCH Live = VOD\n            //representation.duration = duration;\n\n            return true;\n        },\n\n        postProcess = function(manifest, quality) {\n            var deferred = Q.defer(),\n                period = manifest.Period_asArray[0],\n                // Consider video AdaptationSet (always the 1st one)\n                adaptationSet = period.AdaptationSet_asArray[0],\n                // Consider representation of current and downloaded quality\n                representation = adaptationSet.Representation_asArray[quality],\n                request = new MediaPlayer.vo.SegmentRequest(),\n                manifestDuration,\n                mpdLoadedTime,\n                maxSequenceNumber,\n                i, j, k;\n\n            period.start = 0; //segmentTimes[adaptationSet.Representation_asArray[0].SegmentList.startNumber];\n\n            // Copy duration from first representation's duration\n            adaptationSet.duration = representation.duration;\n            period.duration = representation.duration;\n\n            if (representation.duration !== Infinity) {\n                manifest.mediaPresentationDuration = representation.duration;\n            }\n\n            // Set manifest type, \"static\" vs \"dynamic\"\n            manifest.type = (representation.duration === Infinity) ? \"dynamic\" : \"static\";\n\n            manifestDuration = representation.SegmentList.duration * representation.SegmentList.SegmentURL_asArray.length;\n\n            // Dynamic use case\n            if (manifest.type === \"dynamic\") {\n                // Set availabilityStartTime property\n                mpdLoadedTime = new Date();\n                manifest.availabilityStartTime = new Date(mpdLoadedTime.getTime() - (manifestDuration * 1000));\n\n                // Set timeshift buffer depth\n                manifest.timeShiftBufferDepth = manifestDuration;\n            }\n\n            // Set minBufferTime\n            manifest.minBufferTime = representation.SegmentList.duration * 3; //MediaPlayer.dependencies.BufferExtensions.DEFAULT_MIN_BUFFER_TIME\n\n            // Align segment lists of all adaptations\n            maxSequenceNumber = Math.max.apply(null, period.AdaptationSet_asArray.map(function(adaptation) {\n                var repIndex = quality > adaptation.Representation_asArray.length ? 0 : quality;\n                return adaptation.Representation_asArray[repIndex].SegmentList.startNumber;\n            }));\n            for (i = 0; i < period.AdaptationSet_asArray.length; i++) {\n                var adaptation = period.AdaptationSet_asArray[i];\n                for (j = 0; j < adaptation.Representation_asArray.length; j++) {\n                    if (adaptation.Representation_asArray[j].SegmentList) {\n                        var segments = adaptation.Representation_asArray[j].SegmentList.SegmentURL_asArray;\n                        if (segments[0].sequenceNumber < maxSequenceNumber) {\n                            removeSegments(segments, maxSequenceNumber);\n                            if (segments.length > 0) {\n                                segments[0].time = 0;\n                                for (k = 1; k < segments.length; k++) {\n                                    segments[k].time = segments[k - 1].time + segments[k - 1].duration;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            // Download initialization data (PSI, IDR...) of 1st representation to obtain codec information\n            representation = adaptationSet.Representation_asArray[quality];\n            request.type = \"Initialization Segment\";\n            request.url = representation.SegmentList.Initialization.sourceURL;\n\n            var onLoaded = function(representation, response) {\n\n                // Parse initialization data to obtain codec information\n                var tracks = this.hlsDemux.getTracks(new Uint8Array(response.data)),\n                    i = 0;\n\n                representation.codecs = \"\";\n                for (i = 0; i < tracks.length; i++) {\n                    representation.codecs += tracks[i].codecs;\n                    if (i < (tracks.length - 1)) {\n                        representation.codecs += \",\";\n                    }\n                }\n\n                deferred.resolve();\n            };\n\n            var onError = function() {\n                deferred.resolve();\n            };\n\n            if (representation.codecs === \"\") {\n                this.debug.log(\"[HlsParser]\", \"Load initialization segment: \" + request.url);\n                this.fragmentLoader.load(request).then(onLoaded.bind(this, representation), onError.bind(this));\n            } else {\n                deferred.resolve();\n            }\n\n            return deferred.promise;\n        },\n\n        parseBaseUrl = function(url) {\n            var base = null;\n\n            if (url.indexOf(\"/\") !== -1) {\n                if (url.indexOf(\"?\") !== -1) {\n                    url = url.substring(0, url.indexOf(\"?\"));\n                }\n                base = url.substring(0, url.lastIndexOf(\"/\") + 1);\n            }\n\n            return base;\n        },\n\n        updatePlaylist = function(representation, adaptation) {\n            var self = this,\n                deferred = Q.defer();\n\n            this.debug.log(\"[HlsParser]\", \"Load playlist manifest: \" + representation.url);\n            xhrLoader = new MediaPlayer.dependencies.XHRLoader();\n            xhrLoader.initialize('text', retryAttempts, retryInterval);\n            xhrLoader.load(representation.url).then(\n                function (request) {\n                    if (parsePlaylist.call(self, request.response, representation, adaptation)) {\n                        deferred.resolve();\n                    } else {\n                        deferred.reject({\n                            name: MediaPlayer.dependencies.ErrorHandler.prototype.MANIFEST_ERR_PARSE,\n                            message: \"Failed to parse variant stream playlist\",\n                            data: {\n                                url: representation.url\n                            }\n                        });\n                    }\n                },\n                function(request) {\n                    if (!request || request.aborted) {\n                        deferred.reject();\n                    } else {\n                        deferred.reject({\n                            name: MediaPlayer.dependencies.ErrorHandler.prototype.DOWNLOAD_ERR_MANIFEST,\n                            message: \"Failed to download variant stream playlist\",\n                            data: {\n                                url: representation.url,\n                                status: request.status\n                            }\n                        });\n                    }\n                }\n            );\n\n            return deferred.promise;\n        },\n\n        processManifest = function(manifest, baseUrl) {\n            var self = this,\n                deferred = Q.defer(),\n                mpd,\n                period,\n                adaptationsSets = [],\n                adaptationSet,\n                representations,\n                representation,\n                representationId = 0,\n                streams = [],\n                stream,\n                medias = [],\n                media,\n                quality,\n                playlistDefers = [],\n                i = 0;\n\n            if (manifest.indexOf('#EXTM3U') !== 0) {\n                this.debug.error(\"[HlsParser] no stream in HLS manifest\");\n                deferred.reject();\n                return deferred.promise;\n            }\n\n            // MPD\n            mpd = {};\n            mpd.name = \"M3U\";\n            mpd.isRoot = true;\n            mpd.isArray = true;\n            mpd.parent = null;\n            // mpd.children = [];\n            mpd.BaseURL = baseUrl;\n\n            mpd.profiles = \"urn:mpeg:dash:profile:isoff-live:2011\";\n            mpd.type = \"static\"; // Updated in postProcess()\n\n            // PERIOD\n            period = {};\n            period.name = \"Period\";\n            period.isRoot = false;\n            period.isArray = false;\n            period.parent = mpd;\n            period.duration = 0; // To be set at variant playlist parsing\n            period.BaseURL = mpd.BaseURL;\n\n            mpd.Period = period;\n            mpd.Period_asArray = [period];\n\n            // ADAPTATION SET\n            adaptationsSets = [];\n            period.AdaptationSet = adaptationsSets;\n            period.AdaptationSet_asArray = adaptationsSets;\n\n            // Get variant streams\n            streams = getVariantStreams(manifest);\n\n            if (streams.length === 0) {\n                this.debug.error(\"[HlsParser] No stream in HLS manifest\");\n                deferred.reject();\n                return deferred.promise;\n            }\n\n            // Sort streams by bandwidth\n            streams.sort(function(a, b) {\n                return a.bandwidth - b.bandwidth;\n            });\n\n            // Create AdaptationSet and a representation for each variant stream\n            adaptationSet = {\n                name: \"AdaptationSet\",\n                isRoot: false,\n                isArray: true,\n                id: \"video\",\n                lang: \"\",\n                contentType: \"video\",\n                mimeType: \"video/mp4\",\n                maxWidth: 0,\n                maxHeight: 0,\n                BaseURL: period.BaseURL\n            };\n\n            representations = [];\n            for (i = 0; i < streams.length; i++) {\n                stream = streams[i];\n                // Do not consider representation with bandwidth <= 64K which corresponds to audio only variant stream\n                if (stream.bandwidth <= 64000) {\n                    break;\n                }\n                representation = {\n                    name: \"Representation\",\n                    isRoot: false,\n                    isArray: true,\n                    id: representationId.toString(),\n                    mimeType: \"video/mp4\",\n                    // Consider audio codec only if no alternate track for audio\n                    codecs: (stream.videoCodec.length > 0) ? (stream.audioId.length > 0 ? stream.videoCodec : (stream.videoCodec + ',' + stream.audioCodec)) : \"\",\n                    bandwidth: stream.bandwidth,\n                    width: stream.width,\n                    height: stream.height,\n                    url: getAbsoluteURI(stream.uri, adaptationSet.BaseURL)\n                };\n                representation.BaseURL = parseBaseUrl(representation.url);\n                representations.push(representation);\n                representationId++;\n            }\n\n            adaptationSet.Representation = (representations.length > 1) ? representations : representations[0];\n            adaptationSet.Representation_asArray = representations;\n            adaptationsSets.push(adaptationSet);\n\n            // Download and process representation (variant stream) playlist\n            quality = this.abrController.getPlaybackQuality(\"video\", adaptationsSets[0]).quality;\n            representation = adaptationsSets[0].Representation_asArray[quality];\n            playlistDefers.push(updatePlaylist.call(this, representation, adaptationSet));\n\n            // Alternative renditions of the same content (alternative audio tracks or subtitles) #EXT-X-MEDIA\n            medias = getMedias(manifest);\n            for (i =0; i < medias.length; i++) {\n                media = medias[i];\n                adaptationSet = {\n                    name: 'AdaptationSet',\n                    isRoot: false,\n                    isArray: true,\n                    id: media.name,\n                    lang: media.language,\n                    contentType: media.type,\n                    mimeType: media.type === 'audio' ? 'audio/mp4' : 'text/vtt',\n                    maxWidth: 0,\n                    maxHeight: 0,\n                    BaseURL: period.BaseURL\n                };\n\n                representation = {\n                    name: 'Representation',\n                    isRoot: false,\n                    isArray: true,\n                    id: '',\n                    mimeType: media.type === 'audio' ? 'audio/mp4' : 'text/vtt',\n                    codecs: media.type === 'audio' ? streams[0].audioCodec : 'WebVTT',\n                    bandwidth: 0,\n                    width: 0,\n                    height: 0,\n                    url: getAbsoluteURI(media.uri, adaptationSet.BaseURL)\n                };\n                representation.BaseURL = parseBaseUrl(representation.url);\n\n                adaptationSet.Representation = representation;\n                adaptationSet.Representation_asArray = [representation];\n                adaptationsSets.push(adaptationSet);\n                playlistDefers.push(updatePlaylist.call(this, representation, adaptationSet));\n            }\n\n            // Get representation (variant stream) playlist\n            Q.all(playlistDefers).then(\n                function() {\n                    postProcess.call(self, mpd, quality).then(function() {\n                        deferred.resolve(mpd);\n                    });\n                },\n                function(error) {\n                    // error undefined in case of playlist download aborted\n                    if (error) {\n                        // Variant stream playlist download error\n                        deferred.reject(error);\n                    } else {\n                        // Variant stream playlist download aborted\n                        deferred.resolve(null);\n                    }\n                }\n            );\n\n            return deferred.promise;\n        },\n\n        internalParse = function(data, baseUrl) {\n            this.hlsDemux.reset();\n            this.debug.log(\"[HlsParser]\", \"Doing parse.\");\n            this.debug.log(\"[HlsParser]\", data);\n            return processManifest.call(this, data, baseUrl);\n        },\n\n        abort = function() {\n            if (xhrLoader !== null) {\n                xhrLoader.abort();\n            }\n        };\n\n    return {\n        debug: undefined,\n        config: undefined,\n        manifestModel: undefined,\n        fragmentLoader: undefined,\n        abrController: undefined,\n        hlsDemux: undefined,\n        metricsModel: undefined,\n\n        setup: function() {\n            retryAttempts = this.config.getParam(\"ManifestLoader.RetryAttempts\", \"number\", DEFAULT_RETRY_ATTEMPTS);\n            retryInterval = this.config.getParam(\"ManifestLoader.RetryInterval\", \"number\", DEFAULT_RETRY_INTERVAL);\n        },\n\n        parse: internalParse,\n\n        updatePlaylist: updatePlaylist,\n\n        abort: abort\n    };\n};\n\nHls.dependencies.HlsParser.prototype = {\n    constructor: Hls.dependencies.HlsParser\n};","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n * \n * Copyright (c) 2014, Orange\n * All rights reserved.\n * \n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n * \n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n /*jshint -W020 */\nMss = (function () {\n    \"use strict\";\n\n    return {\n        dependencies: {}\n    };\n}());","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// Define Number.MAX_SAFE_INTEGER value in case it is not defined (such as in IE11)\nif (!Number.MAX_SAFE_INTEGER) {\n    Number.MAX_SAFE_INTEGER = 9007199254740991;\n}\n\nMss.dependencies.MssParser = function() {\n    \"use strict\";\n\n    var TIME_SCALE_100_NANOSECOND_UNIT = 10000000.0,\n        SUPPORTED_CODECS = [\"AAC\", \"AACL\", \"AVC1\", \"H264\", \"TTML\", \"DFXP\"],\n        samplingFrequencyIndex = {\n            96000: 0x0,\n            88200: 0x1,\n            64000: 0x2,\n            48000: 0x3,\n            44100: 0x4,\n            32000: 0x5,\n            24000: 0x6,\n            22050: 0x7,\n            16000: 0x8,\n            12000: 0x9,\n            11025: 0xA,\n            8000: 0xB,\n            7350: 0xC\n        },\n        mimeTypeMap = {\n            \"video\": \"video/mp4\",\n            \"audio\": \"audio/mp4\",\n            \"text\": \"application/ttml+xml+mp4\"\n        },\n        xmlDoc = null,\n        baseURL = null,\n\n        mapPeriod = function() {\n            var period = {},\n                adaptations = [],\n                adaptation,\n                smoothNode = this.domParser.getChildNode(xmlDoc, \"SmoothStreamingMedia\"),\n                i;\n\n            period.BaseURL = baseURL;\n\n            // For each StreamIndex node, create an AdaptationSet element\n            for (i = 0; i < smoothNode.childNodes.length; i++) {\n                if (smoothNode.childNodes[i].nodeName === \"StreamIndex\") {\n                    adaptation = mapAdaptationSet.call(this, smoothNode.childNodes[i]);\n                    if (adaptation !== null) {\n                        adaptations.push(adaptation);\n                    }\n                }\n            }\n\n            if (adaptations.length > 0) {\n                period.AdaptationSet = (adaptations.length > 1) ? adaptations : adaptations[0];\n            }\n            period.AdaptationSet_asArray = adaptations;\n\n            return period;\n        },\n\n        mapAdaptationSet = function(streamIndex) {\n\n            var adaptationSet = {},\n                representations = [],\n                representation,\n                segmentTemplate = {},\n                qualityLevels = null,\n                subType = null,\n                i;\n\n            adaptationSet.id = this.domParser.getAttributeValue(streamIndex, \"Name\");\n            adaptationSet.lang = this.domParser.getAttributeValue(streamIndex, \"Language\");\n            adaptationSet.contentType = this.domParser.getAttributeValue(streamIndex, \"Type\");\n            adaptationSet.mimeType = mimeTypeMap[adaptationSet.contentType];\n            adaptationSet.maxWidth = this.domParser.getAttributeValue(streamIndex, \"MaxWidth\");\n            adaptationSet.maxHeight = this.domParser.getAttributeValue(streamIndex, \"MaxHeight\");\n            adaptationSet.BaseURL = baseURL;\n\n            subType = this.domParser.getAttributeValue(streamIndex, \"Subtype\");\n            if (subType) {\n                adaptationSet.subType = subType;\n            }\n\n            // Create a SegmentTemplate with a SegmentTimeline\n            segmentTemplate = mapSegmentTemplate.call(this, streamIndex);\n\n            qualityLevels = this.domParser.getChildNodes(streamIndex, \"QualityLevel\");\n            // For each QualityLevel node, create a Representation element\n            for (i = 0; i < qualityLevels.length; i++) {\n                // Propagate BaseURL and mimeType\n                qualityLevels[i].BaseURL = adaptationSet.BaseURL;\n                qualityLevels[i].mimeType = adaptationSet.mimeType;\n\n                // Set quality level id\n                qualityLevels[i].Id = adaptationSet.id + \"_\" + this.domParser.getAttributeValue(qualityLevels[i], \"Index\");\n\n                // Map Representation to QualityLevel\n                representation = mapRepresentation.call(this, qualityLevels[i], streamIndex);\n\n                if (representation !== null) {\n                    // Copy SegmentTemplate into Representation\n                    representation.SegmentTemplate = segmentTemplate;\n\n                    representations.push(representation);\n                }\n            }\n\n            if (representations.length === 0) {\n                return null;\n            }\n\n            adaptationSet.Representation = (representations.length > 1) ? representations : representations[0];\n            adaptationSet.Representation_asArray = representations;\n\n            // Set SegmentTemplate\n            adaptationSet.SegmentTemplate = segmentTemplate;\n\n            return adaptationSet;\n        },\n\n        mapRepresentation = function(qualityLevel, streamIndex) {\n\n            var representation = {},\n                fourCCValue = null,\n                type = this.domParser.getAttributeValue(streamIndex, \"Type\");\n\n            representation.id = qualityLevel.Id;\n            representation.bandwidth = parseInt(this.domParser.getAttributeValue(qualityLevel, \"Bitrate\"), 10);\n            representation.mimeType = qualityLevel.mimeType;\n            representation.width = parseInt(this.domParser.getAttributeValue(qualityLevel, \"MaxWidth\"), 10);\n            representation.height = parseInt(this.domParser.getAttributeValue(qualityLevel, \"MaxHeight\"), 10);\n\n            fourCCValue = this.domParser.getAttributeValue(qualityLevel, \"FourCC\");\n\n            // If FourCC not defined at QualityLevel level, then get it from StreamIndex level\n            if (fourCCValue === null || fourCCValue === \"\") {\n                fourCCValue = this.domParser.getAttributeValue(streamIndex, \"FourCC\");\n            }\n\n            // If still not defined (optionnal for audio stream, see https://msdn.microsoft.com/en-us/library/ff728116%28v=vs.95%29.aspx),\n            // then we consider the stream is an audio AAC stream\n            if (fourCCValue === null || fourCCValue === \"\") {\n                if (type === 'audio') {\n                    fourCCValue = \"AAC\";\n                } else {\n                    this.errHandler.sendWarning(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CODEC_UNSUPPORTED, type + \" codec/FourCC not provided\", {codec: ''});\n                    return null;\n                }\n            }\n\n            // Check if codec is supported\n            if (SUPPORTED_CODECS.indexOf(fourCCValue.toUpperCase()) === -1) {\n                // Do not send warning\n                //this.errHandler.sendWarning(MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CODEC_UNSUPPORTED, \"Codec/FourCC not supported\", {codec: fourCCValue});\n                this.debug.warn(\"[MssParser] Codec not supported: \" + fourCCValue);\n                return null;\n            }\n\n            // Get codecs value according to FourCC field\n            if (fourCCValue === \"H264\" || fourCCValue === \"AVC1\") {\n                representation.codecs = getH264Codec.call(this, qualityLevel);\n            } else if (fourCCValue.indexOf(\"AAC\") >= 0) {\n                representation.codecs = getAACCodec.call(this, qualityLevel, fourCCValue);\n                representation.audioSamplingRate = parseInt(this.domParser.getAttributeValue(qualityLevel, \"SamplingRate\"), 10);\n                representation.audioChannels = parseInt(this.domParser.getAttributeValue(qualityLevel, \"Channels\"), 10);\n            }\n\n            representation.codecPrivateData = \"\" + this.domParser.getAttributeValue(qualityLevel, \"CodecPrivateData\");\n            representation.BaseURL = qualityLevel.BaseURL;\n\n            return representation;\n        },\n\n        getH264Codec = function(qualityLevel) {\n            var codecPrivateData = this.domParser.getAttributeValue(qualityLevel, \"CodecPrivateData\").toString(),\n                nalHeader,\n                avcoti;\n\n\n            // Extract from the CodecPrivateData field the hexadecimal representation of the following\n            // three bytes in the sequence parameter set NAL unit.\n            // => Find the SPS nal header\n            nalHeader = /00000001[0-9]7/.exec(codecPrivateData);\n            // => Find the 6 characters after the SPS nalHeader (if it exists)\n            avcoti = nalHeader && nalHeader[0] ? (codecPrivateData.substr(codecPrivateData.indexOf(nalHeader[0]) + 10, 6)) : undefined;\n\n            return \"avc1.\" + avcoti;\n        },\n\n        getAACCodec = function(qualityLevel, fourCCValue) {\n            var objectType = 0,\n                codecPrivateData = this.domParser.getAttributeValue(qualityLevel, \"CodecPrivateData\").toString(),\n                codecPrivateDataHex,\n                samplingRate = parseInt(this.domParser.getAttributeValue(qualityLevel, \"SamplingRate\"), 10),\n                arr16,\n                indexFreq,\n                extensionSamplingFrequencyIndex;\n\n            //chrome problem, in implicit AAC HE definition, so when AACH is detected in FourCC\n            //set objectType to 5 => strange, it should be 2\n            if (fourCCValue === \"AACH\") {\n                objectType = 0x05;\n            }\n            //if codecPrivateData is empty, build it :\n            if (codecPrivateData === undefined || codecPrivateData === \"\") {\n                objectType = 0x02; //AAC Main Low Complexity => object Type = 2\n                indexFreq = samplingFrequencyIndex[samplingRate];\n                if (fourCCValue === \"AACH\") {\n                    // 4 bytes :     XXXXX         XXXX          XXXX             XXXX                  XXXXX      XXX   XXXXXXX\n                    //           ' ObjectType' 'Freq Index' 'Channels value'   'Extens Sampl Freq'  'ObjectType'  'GAS' 'alignment = 0'\n                    objectType = 0x05; // High Efficiency AAC Profile = object Type = 5 SBR\n                    codecPrivateData = new Uint8Array(4);\n                    extensionSamplingFrequencyIndex = samplingFrequencyIndex[samplingRate * 2]; // in HE AAC Extension Sampling frequence\n                    // equals to SamplingRate*2\n                    //Freq Index is present for 3 bits in the first byte, last bit is in the second\n                    codecPrivateData[0] = (objectType << 3) | (indexFreq >> 1);\n                    codecPrivateData[1] = (indexFreq << 7) | (qualityLevel.Channels << 3) | (extensionSamplingFrequencyIndex >> 1);\n                    codecPrivateData[2] = (extensionSamplingFrequencyIndex << 7) | (0x02 << 2); // origin object type equals to 2 => AAC Main Low Complexity\n                    codecPrivateData[3] = 0x0; //alignment bits\n\n                    arr16 = new Uint16Array(2);\n                    arr16[0] = (codecPrivateData[0] << 8) + codecPrivateData[1];\n                    arr16[1] = (codecPrivateData[2] << 8) + codecPrivateData[3];\n                    //convert decimal to hex value\n                    codecPrivateDataHex = arr16[0].toString(16);\n                    codecPrivateDataHex = arr16[0].toString(16) + arr16[1].toString(16);\n\n                } else {\n                    // 2 bytes :     XXXXX         XXXX          XXXX              XXX\n                    //           ' ObjectType' 'Freq Index' 'Channels value'   'GAS = 000'\n                    codecPrivateData = new Uint8Array(2);\n                    //Freq Index is present for 3 bits in the first byte, last bit is in the second\n                    codecPrivateData[0] = (objectType << 3) | (indexFreq >> 1);\n                    codecPrivateData[1] = (indexFreq << 7) | (parseInt(this.domParser.getAttributeValue(qualityLevel, \"Channels\"), 10) << 3);\n                    // put the 2 bytes in an 16 bits array\n                    arr16 = new Uint16Array(1);\n                    arr16[0] = (codecPrivateData[0] << 8) + codecPrivateData[1];\n                    //convert decimal to hex value\n                    codecPrivateDataHex = arr16[0].toString(16);\n                }\n\n                codecPrivateData = \"\" + codecPrivateDataHex;\n                codecPrivateData = codecPrivateData.toUpperCase();\n                qualityLevel.setAttribute(\"CodecPrivateData\", codecPrivateData);\n            } else if (objectType === 0) {\n                objectType = (parseInt(codecPrivateData.substr(0, 2), 16) & 0xF8) >> 3;\n            }\n\n            return \"mp4a.40.\" + objectType;\n        },\n\n        mapSegmentTemplate = function(streamIndex) {\n\n            var segmentTemplate = {},\n                mediaUrl;\n\n            mediaUrl = this.domParser.getAttributeValue(streamIndex, \"Url\").replace('{bitrate}', '$Bandwidth$');\n            mediaUrl = mediaUrl.replace('{start time}', '$Time$');\n\n            segmentTemplate.media = mediaUrl;\n            segmentTemplate.timescale = TIME_SCALE_100_NANOSECOND_UNIT;\n\n            segmentTemplate.SegmentTimeline = mapSegmentTimeline.call(this, streamIndex);\n\n            return segmentTemplate;\n        },\n\n        mapSegmentTimeline = function(streamIndex) {\n\n            var segmentTimeline = {},\n                chunks = this.domParser.getChildNodes(streamIndex, \"c\"),\n                segments = [],\n                segment,\n                prevSegment,\n                i,\n                tManifest,\n                duration = 0;\n\n            for (i = 0; i < chunks.length; i++) {\n                segment = {};\n\n                // Get time 't' attribute value (as string in order to handle large values, i.e. > 2^53)\n                tManifest = this.domParser.getAttributeValue(chunks[i], \"t\");\n\n                // Check if time is not greater than 2^53\n                // => segment.tManifest = original timestamp value as a string (for constructing the fragment request url, see DashHandler)\n                // => segment.t = number value of timestamp (maybe rounded value, but only for 0.1 microsecond)\n                if (tManifest && goog.math.Long.fromString(tManifest).greaterThan(goog.math.Long.fromNumber(Number.MAX_SAFE_INTEGER))) {\n                    segment.tManifest = tManifest;\n                }\n\n                segment.t = parseFloat(tManifest);\n\n                // Get duration 'd' attribute value\n                segment.d = parseFloat(this.domParser.getAttributeValue(chunks[i], \"d\"));\n\n                // If 't' not defined for first segment then t=0\n                if ((i === 0) && !segment.t) {\n                    segment.t = 0;\n                }\n\n                if (i > 0) {\n                    prevSegment = segments[segments.length - 1];\n                    // Update previous segment duration if not defined\n                    if (!prevSegment.d) {\n                       if (prevSegment.tManifest) {\n                           prevSegment.d = goog.math.Long.fromString(tManifest).subtract(goog.math.Long.fromString(prevSegment.tManifest)).toNumber();\n                       } else {\n                           prevSegment.d = segment.t - prevSegment.t;\n                       }\n                    }\n                    // Set segment absolute timestamp if not set in manifest\n                    if (!segment.t) {\n                        if (prevSegment.tManifest) {\n                           segment.tManifest = goog.math.Long.fromString(prevSegment.tManifest).add(goog.math.Long.fromNumber(prevSegment.d)).toString();\n                           segment.t = parseFloat(segment.tManifest);\n                       } else {\n                           segment.t = prevSegment.t + prevSegment.d;\n                       }\n                    }\n                }\n\n                duration += segment.d;\n\n                // Create new segment\n                segments.push(segment);\n            }\n\n            segmentTimeline.S = segments;\n            segmentTimeline.S_asArray = segments;\n            segmentTimeline.duration = duration / TIME_SCALE_100_NANOSECOND_UNIT;\n\n            return segmentTimeline;\n        },\n\n        /* @if PROTECTION=true */\n        getKIDFromProtectionHeader = function(protectionHeader) {\n            var prHeader,\n                wrmHeader,\n                xmlReader,\n                KID;\n\n            // Get PlayReady header as byte array (base64 decoded)\n            prHeader = BASE64.decodeArray(protectionHeader.firstChild.data);\n\n            // Get Right Management header (WRMHEADER) from PlayReady header\n            wrmHeader = getWRMHeaderFromPRHeader(prHeader);\n\n            // Convert from multi-byte to unicode\n            wrmHeader = new Uint16Array(wrmHeader.buffer);\n\n            // Convert to string\n            wrmHeader = String.fromCharCode.apply(null, wrmHeader);\n\n            // Parse <WRMHeader> to get KID field value\n            xmlReader = (new DOMParser()).parseFromString(wrmHeader, \"application/xml\");\n            KID = xmlReader.querySelector(\"KID\").textContent;\n\n            // Get KID (base64 decoded) as byte array\n            KID = BASE64.decodeArray(KID);\n\n            // Convert UUID from little-endian to big-endian\n            convertUuidEndianness(KID);\n\n            return KID;\n        },\n\n        getWRMHeaderFromPRHeader = function(prHeader) {\n            var length,\n                recordCount,\n                recordType,\n                recordLength,\n                recordValue,\n                i = 0;\n\n            // Parse PlayReady header\n\n            // Length - 32 bits (LE format)\n            length = (prHeader[i + 3] << 24) + (prHeader[i + 2] << 16) + (prHeader[i + 1] << 8) + prHeader[i];\n            i += 4;\n\n            // Record count - 16 bits (LE format)\n            recordCount = (prHeader[i + 1] << 8) + prHeader[i];\n            i += 2;\n\n            // Parse records\n            while (i < prHeader.length) {\n                // Record type - 16 bits (LE format)\n                recordType = (prHeader[i + 1] << 8) + prHeader[i];\n                i += 2;\n\n                // Check if Rights Management header (record type = 0x01)\n                if (recordType === 0x01) {\n\n                    // Record length - 16 bits (LE format)\n                    recordLength = (prHeader[i + 1] << 8) + prHeader[i];\n                    i += 2;\n\n                    // Record value => contains <WRMHEADER>\n                    recordValue = new Uint8Array(recordLength);\n                    recordValue.set(prHeader.subarray(i, i + recordLength));\n                    return recordValue;\n                }\n            }\n\n            return null;\n        },\n\n        convertUuidEndianness = function(uuid) {\n            swapBytes(uuid, 0, 3);\n            swapBytes(uuid, 1, 2);\n            swapBytes(uuid, 4, 5);\n            swapBytes(uuid, 6, 7);\n        },\n\n        swapBytes = function(bytes, pos1, pos2) {\n            var temp = bytes[pos1];\n            bytes[pos1] = bytes[pos2];\n            bytes[pos2] = temp;\n        },\n\n\n        createPRContentProtection = function(protectionHeader) {\n\n            var contentProtection = {},\n                keySystem = this.system.getObject(\"ksPlayReady\"),\n                pro;\n\n            pro = {\n                __text: protectionHeader.firstChild.data,\n                __prefix: \"mspr\"\n            };\n\n            contentProtection.schemeIdUri = keySystem.schemeIdURI;\n            contentProtection.value = keySystem.systemString;\n            contentProtection.pro = pro;\n            contentProtection.pro_asArray = pro;\n\n            return contentProtection;\n        },\n\n        createWidevineContentProtection = function(/*protectionHeader*/) {\n\n            var contentProtection = {},\n                keySystem = this.system.getObject(\"ksWidevine\");\n\n            contentProtection.schemeIdUri = keySystem.schemeIdURI;\n            contentProtection.value = keySystem.systemString;\n\n            return contentProtection;\n        },\n        /* @endif */\n\n        addDVRInfo = function(adaptationSet) {\n            var segmentTemplate = adaptationSet.SegmentTemplate,\n                segments = segmentTemplate.SegmentTimeline.S_asArray;\n\n            if (segments.length === 0) {\n                return;\n            }\n\n            var range = {\n                start: segments[0].t / segmentTemplate.timescale,\n                end: (segments[segments.length - 1].t + segments[segments.length - 1].d) / segmentTemplate.timescale\n            };\n\n            this.metricsModel.addDVRInfo(adaptationSet.contentType, new Date(), range);\n        },\n\n        processManifest = function(manifestLoadedTime) {\n            var mpd = {},\n                period,\n                adaptations,\n                contentProtection,\n                contentProtections = [],\n                smoothNode = this.domParser.getChildNode(xmlDoc, \"SmoothStreamingMedia\"),\n                protection = this.domParser.getChildNode(smoothNode, 'Protection'),\n                protectionHeader = null,\n                KID,\n                timestampOffset,\n                startTime,\n                segments,\n                i, j;\n\n            // Set mpd node properties\n            mpd.name = 'MSS';\n            mpd.profiles = \"urn:mpeg:dash:profile:isoff-live:2011\";\n            var isLive = this.domParser.getAttributeValue(smoothNode, 'IsLive');\n            mpd.type = (isLive !== null && isLive.toLowerCase() === 'true') ? 'dynamic' : 'static';\n            mpd.timeShiftBufferDepth = parseFloat(this.domParser.getAttributeValue(smoothNode, 'DVRWindowLength')) / TIME_SCALE_100_NANOSECOND_UNIT;\n            var duration = parseFloat(this.domParser.getAttributeValue(smoothNode, 'Duration'));\n\n            // If live manifest with Duration and no DVRWindowLength, we consider it as a start-over manifest\n            if (mpd.type === \"dynamic\" && duration > 0) {\n                mpd.timeShiftBufferDepth = duration / TIME_SCALE_100_NANOSECOND_UNIT;\n                duration = 0;\n                mpd.startOver = true;\n            }\n\n            // Complete manifest/mpd initialization\n            mpd.mediaPresentationDuration = (duration === 0) ? Infinity : (duration / TIME_SCALE_100_NANOSECOND_UNIT);\n            mpd.BaseURL = baseURL;\n            mpd.minBufferTime = MediaPlayer.dependencies.BufferExtensions.DEFAULT_MIN_BUFFER_TIME;\n\n            // In case of live streams, set availabilityStartTime property according to DVRWindowLength\n            if (mpd.type === \"dynamic\") {\n                mpd.availabilityStartTime = new Date(manifestLoadedTime.getTime() - (mpd.timeShiftBufferDepth * 1000));\n            }\n\n            // Map period node to manifest root node\n            mpd.Period = mapPeriod.call(this);\n            mpd.Period_asArray = [mpd.Period];\n\n            period = mpd.Period;\n\n            // Complete period initialization\n            period.start = 0;\n\n            // Test live to static\n            // if (mpd.type !== 'static') {\n            //     mpd.type = 'static';\n            //     mpd.mediaPresentationDuration = mpd.timeShiftBufferDepth;\n            // }\n\n            // ContentProtection node\n            if (protection !== undefined) {\n                /* @if PROTECTION=true */\n                protectionHeader = this.domParser.getChildNode(protection, 'ProtectionHeader');\n\n                // Some packagers put newlines into the ProtectionHeader base64 string, which is not good\n                // because this cannot be correctly parsed. Let's just filter out any newlines found in there.\n                protectionHeader.firstChild.data = protectionHeader.firstChild.data.replace(/\\n|\\r/g, \"\");\n\n                // Get KID (in CENC format) from protection header\n                KID = getKIDFromProtectionHeader(protectionHeader);\n\n                // Create ContentProtection for PR\n                contentProtection = createPRContentProtection.call(this, protectionHeader);\n                contentProtection[\"cenc:default_KID\"] = KID;\n                contentProtections.push(contentProtection);\n\n                // Create ContentProtection for Widevine (as a CENC protection)\n                contentProtection = createWidevineContentProtection.call(this, protectionHeader);\n                contentProtection[\"cenc:default_KID\"] = KID;\n                contentProtections.push(contentProtection);\n\n                mpd.ContentProtection = (contentProtections.length > 1) ? contentProtections : contentProtections[0];\n                mpd.ContentProtection_asArray = contentProtections;\n                /* @endif */\n\n                /* @if PROTECTION=false */\n                /* @exec sendError('MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_ENCRYPTED','\"protected content detected but protection module is not included.\"') */\n                /* @exec reject('\"[MssParser] Protected content detected but protection module is not included.\"') */\n                /* @endif */\n            }\n\n            adaptations = period.AdaptationSet_asArray;\n\n            for (i = 0; i < adaptations.length; i += 1) {\n                // Propagate content protection information into each adaptation\n                if (mpd.ContentProtection !== undefined) {\n                    adaptations[i].ContentProtection = mpd.ContentProtection;\n                    adaptations[i].ContentProtection_asArray = mpd.ContentProtection_asArray;\n                }\n\n                if (mpd.type === \"dynamic\") {\n                    // Match timeShiftBufferDepth to video segment timeline duration\n                    if (mpd.timeShiftBufferDepth > 0 &&\n                        adaptations[i].contentType === 'video' &&\n                        mpd.timeShiftBufferDepth > adaptations[i].SegmentTemplate.SegmentTimeline.duration) {\n                        mpd.timeShiftBufferDepth = adaptations[i].SegmentTemplate.SegmentTimeline.duration;\n                    }\n\n                    // Add DVRInfo for live streams\n                    addDVRInfo.call(this, adaptations[i]);\n                }\n            }\n\n            if (mpd.timeShiftBufferDepth < mpd.minBufferTime) {\n                mpd.minBufferTime = mpd.timeShiftBufferDepth;\n            }\n\n            // Delete Content Protection under root mpd node\n            delete mpd.ContentProtection;\n            delete mpd.ContentProtection_asArray;\n\n            // In case of VOD streams, check if start time is greater than 0\n            // Then determine timestamp offset according to higher audio/video start time\n            // (use case = live stream delinearization)\n            if (mpd.type === \"static\") {\n                for (i = 0; i < adaptations.length; i++) {\n                    if (adaptations[i].contentType === 'audio' || adaptations[i].contentType === 'video') {\n                        segments = adaptations[i].SegmentTemplate.SegmentTimeline.S_asArray;\n                        startTime = segments[0].t;\n                        if (!timestampOffset) {\n                            timestampOffset = startTime;\n                        }\n                        timestampOffset = Math.min(timestampOffset, startTime);\n                        // Correct content duration according to minimum adaptation's segments duration\n                        // in order to force <video> element sending 'ended' event\n                        mpd.mediaPresentationDuration = Math.min(mpd.mediaPresentationDuration, ((segments[segments.length-1].t + segments[segments.length-1].d) / TIME_SCALE_100_NANOSECOND_UNIT).toFixed(3));\n                    }\n                }\n\n                // Patch segment templates timestamps and determine period start time (since audio/video should not be aligned to 0)\n                if (timestampOffset > 0) {\n                    for (i = 0; i < adaptations.length; i++) {\n                        segments = adaptations[i].SegmentTemplate.SegmentTimeline.S_asArray;\n                        for (j = 0; j < segments.length; j++) {\n                            if (!segments[j].tManifest) {\n                                segments[j].tManifest = segments[j].t;\n                            }\n                            segments[j].t -= timestampOffset;\n                        }\n                        if (adaptations[i].contentType === 'audio' || adaptations[i].contentType === 'video') {\n                            period.start = Math.max(segments[0].t, period.start);\n                        }\n                    }\n                    period.start /= TIME_SCALE_100_NANOSECOND_UNIT;\n                }\n            }\n\n            period.duration = mpd.mediaPresentationDuration;\n\n            return mpd;\n        },\n\n        internalParse = function(data, baseUrl) {\n            this.debug.info(\"[MssParser]\", \"Doing parse.\");\n\n            var start = new Date(),\n                xml = null,\n                manifest = null,\n                mss2dash = null;\n\n            //this.debug.log(\"[MssParser]\", \"Converting from XML.\");\n            xmlDoc = this.domParser.createXmlTree(data);\n            xml = new Date();\n\n            if (xmlDoc === null) {\n                return Q.reject(null);\n            }\n\n            baseURL = baseUrl;\n\n            // Convert MSS manifest into DASH manifest\n            manifest = processManifest.call(this, start);\n            mss2dash = new Date();\n            //this.debug.log(\"mpd: \" + JSON.stringify(manifest, null, '\\t'));\n\n            this.debug.info(\"[MssParser]\", \"Parsing complete (xmlParser: \" + (xml.getTime() - start.getTime()) + \"ms, mss2dash: \" + (mss2dash.getTime() - xml.getTime()) + \"ms, total: \" + ((new Date().getTime() - start.getTime()) / 1000) + \"s)\");\n            //console.info(\"manifest\",JSON.stringify(manifest) );\n            return Q.when(manifest);\n        };\n\n    return {\n        debug: undefined,\n        system: undefined,\n        errHandler: undefined,\n        domParser: undefined,\n        metricsModel: undefined,\n\n        parse: internalParse\n    };\n};\n\nMss.dependencies.MssParser.prototype = {\n    constructor: Mss.dependencies.MssParser\n};","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMss.dependencies.MssHandler = function() {\n    \"use strict\";\n\n    var getAudioChannels = function(adaptation, representation) {\n            var channels = 1;\n\n            if (adaptation.audioChannels) {\n                channels = adaptation.audioChannels;\n            } else if (representation.audioChannels) {\n                channels = representation.audioChannels;\n            }\n\n            return channels;\n        },\n\n        getAudioSamplingRate = function(adaptation, representation) {\n            var samplingRate = 1;\n\n            if (adaptation.audioSamplingRate) {\n                samplingRate = adaptation.audioSamplingRate;\n            } else {\n                samplingRate = representation.audioSamplingRate;\n            }\n\n            return samplingRate;\n        },\n\n        // Generates initialization segment data from representation information\n        // by using mp4lib library\n        getInitData = function(representation) {\n            var manifest = rslt.manifestModel.getValue(),\n                adaptation,\n                realAdaptation,\n                realRepresentation,\n                track,\n                codec;\n\n            if (representation.initData) {\n                return representation.initData;\n            }\n\n            // Get required media information from manifest  to generate initialisation segment\n            adaptation = representation.adaptation;\n            realAdaptation = manifest.Period_asArray[adaptation.period.index].AdaptationSet_asArray[adaptation.index];\n            realRepresentation = realAdaptation.Representation_asArray[representation.index];\n\n            track = new MediaPlayer.vo.Mp4Track();\n            track.type = rslt.getType() || 'und';\n            track.trackId = adaptation.index + 1; // +1 since track_id shall start from '1'\n            track.timescale = representation.timescale;\n            track.duration = representation.adaptation.period.duration;\n            track.codecs = realRepresentation.codecs;\n            track.codecPrivateData = realRepresentation.codecPrivateData;\n            track.bandwidth = realRepresentation.bandwidth;\n\n            if (track.type !== 'text') {\n                codec = realRepresentation.mimeType + ';codecs=\"' + realRepresentation.codecs + '\"';\n                if (!this.capabilities.supportsCodec(this.videoModel.getElement(), codec)) {\n                    throw {\n                        name: MediaPlayer.dependencies.ErrorHandler.prototype.MEDIA_ERR_CODEC_UNSUPPORTED,\n                        message: 'Codec is not supported (HTMLMediaElement)',\n                        data: {\n                            codec: codec,\n                            bandwidth: realRepresentation.bandwidth,\n                            codecPrivateData: realRepresentation.codecPrivateData\n                        }\n                    };\n                }\n            }\n\n            // DRM Protected Adaptation is detected\n            if (realAdaptation.ContentProtection_asArray && (realAdaptation.ContentProtection_asArray.length > 0)) {\n                track.contentProtection = realAdaptation.ContentProtection_asArray;\n            }\n\n            // Video related informations\n            track.width = realRepresentation.width || realAdaptation.maxWidth;\n            track.height = realRepresentation.height || realAdaptation.maxHeight;\n\n            // Audio related informations\n            track.language = realAdaptation.lang ? realAdaptation.lang : 'und';\n\n            track.channels = getAudioChannels(realAdaptation, realRepresentation);\n            track.samplingRate = getAudioSamplingRate(realAdaptation, realRepresentation);\n\n            representation.initData = rslt.mp4Processor.generateInitSegment([track]);\n\n            return representation.initData;\n\n        };\n\n    var rslt = MediaPlayer.utils.copyMethods(Dash.dependencies.DashHandler);\n    rslt.mp4Processor = undefined;\n\n    rslt.getInitRequest = function(representation) {\n        var period = null,\n            self = this,\n            presentationStartTime = null,\n            request = null,\n            deferred = Q.defer();\n\n        if (!representation) {\n            throw new Error(\"MssHandler.getInitRequest(): representation is undefined\");\n        }\n\n        period = representation.adaptation.period;\n        presentationStartTime = period.start;\n\n        request = new MediaPlayer.vo.SegmentRequest();\n\n        request.streamType = rslt.getType();\n        request.type = \"Initialization Segment\";\n        request.url = null;\n\n        try {\n            request.data = getInitData.call(this, representation);\n        } catch (e) {\n            deferred.reject(e);\n            return deferred.promise;\n        }\n\n        request.range = representation.range;\n        request.availabilityStartTime = self.timelineConverter.calcAvailabilityStartTimeFromPresentationTime(presentationStartTime, representation.adaptation.period.mpd, rslt.getIsDynamic());\n        request.availabilityEndTime = self.timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationStartTime + period.duration, period.mpd, rslt.getIsDynamic());\n\n        //request.action = \"complete\"; //needed to avoid to execute request\n        request.quality = representation.index;\n        deferred.resolve(request);\n\n        return deferred.promise;\n    };\n\n    rslt.getIFrameRequest = function(request){\n        if (request && request.url && (request.streamType === \"video\" || request.streamType === \"audio\")) {\n            request.url = request.url.replace('Fragments','KeyFrames');\n        }\n\n        return request;\n    };\n\n    rslt.getFragmentInfoRequest = function(request){\n        if (request && request.url) {\n            request.url = request.url.replace('Fragments','FragmentInfo');\n            request.type = \"FragmentInfo Segment\";\n        }\n\n        return request;\n    };\n\n    return rslt;\n};\n\nMss.dependencies.MssHandler.prototype = {\n    constructor: Mss.dependencies.MssHandler\n};","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nMss.dependencies.MssFragmentController = function() {\n    \"use strict\";\n\n    var processTfrf = function(request, tfrf, tfdt, adaptation) {\n            var manifest = this.manifestModel.getValue(),\n                segmentsUpdated = false,\n                // Get adaptation's segment timeline (always a SegmentTimeline in Smooth Streaming use case)\n                segments = adaptation.SegmentTemplate.SegmentTimeline.S,\n                entries = tfrf.entry,\n                segment = null,\n                t = 0,\n                i = 0,\n                // j = 0,\n                // segmentId = -1,\n                availabilityStartTime = null,\n                range;\n\n            // Process tfrf only for live streams\n            if (manifest.type !== 'dynamic') {\n                return;\n            }\n\n            // Go through tfrf entries\n            // !! For tfrf fragment_absolute_time and fragment_duration are returned as goog.math.Long values (see mp4lib)\n            while (i < entries.length) {\n                // Check if time is not greater than Number.MAX_SAFE_INTEGER (2^53-1), see MssParser\n                // => fragment_absolute_timeManifest = original timestamp value as a string (for constructing the fragment request url, see DashHandler)\n                // => fragment_absolute_time = number value of timestamp (maybe rounded value, but only for 0.1 microsecond)\n                if (entries[i].fragment_absolute_time.greaterThan(goog.math.Long.fromNumber(Number.MAX_SAFE_INTEGER))) {\n                    entries[i].fragment_absolute_timeManifest = entries[i].fragment_absolute_time.toString();\n                }\n\n                // Convert goog.math.Long to Number values\n                entries[i].fragment_absolute_time = entries[i].fragment_absolute_time.toNumber();\n                entries[i].fragment_duration = entries[i].fragment_duration.toNumber();\n\n                if (entries[i].fragment_absolute_time > segments[segments.length - 1].t) {\n                    this.debug.log(\"[MssFragmentController] Add new segment - t = \" + (entries[i].fragment_absolute_time / 10000000.0));\n                    segment = {};\n                    segment.t = entries[i].fragment_absolute_time;\n                    segment.d = entries[i].fragment_duration;\n                    if (entries[i].fragment_absolute_timeManifest) {\n                       segment.tManifest = entries[i].fragment_absolute_timeManifest;\n                    }\n                    segments.push(segment);\n                    segmentsUpdated = true;\n                }\n\n                i += 1;\n            }\n\n            // Update segment timeline in case the timestamps from tfrf differ from timestamps in Manifest.\n            // In that case we consider tfrf timing\n            // for (j = segments.length - 1; j >= 0; j -= 1) {\n            //     if (segments[j].t === tfdt.baseMediaDecodeTime) {\n            //         segmentId = j;\n            //         break;\n            //     }\n            // }\n            // if (segmentId >= 0) {\n            //     for (i = 0; i < entries.length; i += 1) {\n            //         if (segmentId + i < segments.length) {\n            //             t = segments[segmentId + i].t;\n            //             if ((t + segments[segmentId + i].d) !== entries[i].fragment_absolute_time) {\n            //                 segments[segmentId + i].t = entries[i].fragment_absolute_time;\n            //                 segments[segmentId + i].d = entries[i].fragment_duration;\n            //                 this.debug.log(\"[MssFragmentController] Correct tfrf time  = \" + entries[i].fragment_absolute_time + \" and duration = \" + entries[i].fragment_duration);\n            //                 segmentsUpdated = true;\n            //             }\n            //         }\n            //     }\n            // }\n\n            // Update segment timeline according to DVR window\n            if (manifest.timeShiftBufferDepth && manifest.timeShiftBufferDepth > 0) {\n                if (segmentsUpdated && manifest.startOver !== true) {\n                    // Get timestamp of the last segment\n                    segment = segments[segments.length - 1];\n                    t = segment.t;\n\n                    // Determine the segments' availability start time\n                    availabilityStartTime = t - (manifest.timeShiftBufferDepth * 10000000);\n\n                    // Remove segments prior to availability start time\n                    segment = segments[0];\n                    while (segment.t < availabilityStartTime) {\n                        this.debug.log(\"[MssFragmentController] Remove segment  - t = \" + (segment.t / 10000000.0));\n                        segments.splice(0, 1);\n                        segment = segments[0];\n                    }\n                }\n\n                // Update DVR window range => set range's end to end time of current segment\n                range = {\n                    start: segments[0].t / adaptation.SegmentTemplate.timescale,\n                    end: (tfdt.baseMediaDecodeTime / adaptation.SegmentTemplate.timescale) + request.duration\n                };\n                var dvrInfos = this.metricsModel.getMetricsFor(adaptation.type).DVRInfo;\n                if (dvrInfos && dvrInfos.length > 0 && range.end > dvrInfos[dvrInfos.length - 1].range.end) {\n                    this.metricsModel.addDVRInfo(adaptation.type, new Date(), range);\n                }\n            }\n\n            return segmentsUpdated;\n        },\n\n        updateSegmentsList = function(bytes, request, adaptation) {\n            var fragment = null,\n                moof = null,\n                traf = null,\n                tfdt = null,\n                tfrf = null,\n                pos,\n                i = 0;\n\n            // Create new fragment\n            fragment = mp4lib.deserialize(bytes);\n            moof = fragment.getBoxByType(\"moof\");\n            traf = moof.getBoxByType(\"traf\");\n            // Create and add tfdt box\n            tfdt = traf.getBoxByType(\"tfdt\");\n            if (tfdt === null) {\n                tfdt = new mp4lib.boxes.TrackFragmentBaseMediaDecodeTimeBox();\n                tfdt.version = 1;\n                tfdt.flags = 0;\n                tfdt.baseMediaDecodeTime = Math.floor(request.startTime * request.timescale);\n                // Insert tfdt box just after the tfhd box (therefore before the trun box)\n                pos = traf.getBoxIndexByType(\"tfhd\");\n                traf.boxes.splice(pos + 1, 0, tfdt);\n            }\n            // Process tfrf box\n            tfrf = traf.getBoxesByType(\"tfrf\");\n            if (tfrf === null || tfrf.length === 0) {\n                throw {\n                    name: MediaPlayer.dependencies.ErrorHandler.prototype.MSS_NO_TFRF,\n                    message: 'Missing tfrf in live FragmentInfo segment',\n                    data: {\n                        url: request.url\n                    }\n                };\n            } else {\n                for (i = 0; i < tfrf.length; i += 1) {\n                    processTfrf.call(this, request, tfrf[i], tfdt, adaptation);\n                }\n            }\n        },\n\n        duplicateSample = function(fragment, segmentDuration) {\n            var moof = null,\n                mdat = null,\n                traf = null,\n                trun = null,\n                tfhd,\n                sepiff = null,\n                saiz = null,\n                i,\n                trunEntries,\n                trunDuration,\n                mdatData;\n\n            // This function duplicates the first sample (from KeyFrame request) to generate a full segment that lasts segmentDuration.\n\n            // Get references on boxes\n            moof = fragment.getBoxByType(\"moof\");\n            mdat = fragment.getBoxByType(\"mdat\");\n            traf = moof.getBoxByType(\"traf\");\n            trun = traf.getBoxByType(\"trun\");\n            tfhd = traf.getBoxByType(\"tfhd\");\n\n            // Set first sample duration (if not set)\n            // (sample duration has to be set for each sample in case we have to modify last sample duration to complete the segment)\n            if (!trun.samples_table[0].sample_duration) {\n                trun.samples_table[0].sample_duration = tfhd.default_sample_duration;\n            }\n\n            // Update trun flags to indicate sample-duration-present flag is set (since we do set sample_duration for each sample)\n            trun.flags |= 0x000100;\n\n            // Update tfhd flags to indicate default-sample-duration-present flag is not set (since we do set sample_duration for each sample)\n            tfhd.flags &= 0xFFFFF7;\n\n            // Determine number of samples according to the segment duration\n            trunEntries = Math.floor(segmentDuration / trun.samples_table[0].sample_duration);\n\n            // Duplicate 1st sample in trun box to complete fragment\n            for (i = 0; i < (trunEntries - 1); i++) {\n                trun.samples_table.push(trun.samples_table[0]);\n            }\n            trun.sample_count = trun.samples_table.length;\n\n            // Patch/lengthen the last sample duration if segment not complete\n            trunDuration = trunEntries * trun.samples_table[0].sample_duration;\n            if (trunDuration < segmentDuration) {\n                trun.samples_table[trun.samples_table.length - 1].sample_duration += segmentDuration - trunDuration;\n            }\n\n            // Update PIFF Sample Encryption box\n            sepiff = traf.getBoxByType(\"sepiff\");\n            if (sepiff !== null) {\n                // sepiff box may have already all original samples encryption data definition\n                // => we keep only first sample entry\n                if (sepiff.sample_count > 1) {\n                    sepiff.entry = sepiff.entry.slice(0, 1);\n                }\n                // Then, we duplicate this first entry\n                for (i = 0; i < (trunEntries - 1); i += 1) {\n                    sepiff.entry.push(sepiff.entry[0]);\n                }\n                sepiff.sample_count = sepiff.entry.length;\n            }\n\n            // Update saiz box\n            saiz = traf.getBoxByType(\"saiz\");\n            if (saiz !== null) {\n                if (saiz.default_sample_info_size === 0) {\n                    // Same process as for sepiff box....\n                    if (saiz.sample_count > 1) {\n                        saiz.sample_info_size = saiz.sample_info_size.slice(0, 1);\n                    }\n                    for (i = 0; i < (trunEntries - 1); i += 1) {\n                        saiz.sample_info_size.push(saiz.sample_info_size[0]);\n                    }\n                }\n                saiz.sample_count = sepiff.entry.length;\n            }\n\n            // Duplicate mdat data\n            mdatData = mdat.data;\n            mdat.data = new Uint8Array(mdatData.length * trun.sample_count);\n            for (i = 0; i < trun.sample_count; i++) {\n                mdat.data.set(mdatData, mdatData.length * i);\n            }\n        },\n\n        convertFragment = function(data, request, adaptation) {\n            var i = 0,\n                // Get track id corresponding to adaptation set\n                manifest = this.manifestModel.getValue(),\n                trackId = manifest ? this.manifestExt.getIndex(adaptation, manifest) + 1 : -1, // +1 since track_id shall start from '1'\n                // Create new fragment\n                fragment = mp4lib.deserialize(data),\n                moof = null,\n                mdat = null,\n                traf = null,\n                trun = null,\n                tfhd = null,\n                saio = null,\n                sepiff = null,\n                saiz = null,\n                tfdt = null,\n                tfrf = null,\n                fragmentDuration,\n                sampleDuration,\n                pos = -1,\n                fragment_size = 0,\n                moofPosInFragment = 0,\n                trafPosInMoof = 0,\n                sencPosInTraf = 0,\n                new_data = null;\n\n            if (!fragment) {\n                return null;\n            }\n\n            // Get references on boxes\n            moof = fragment.getBoxByType(\"moof\");\n            mdat = fragment.getBoxByType(\"mdat\");\n            traf = moof.getBoxByType(\"traf\");\n            trun = traf.getBoxByType(\"trun\");\n            tfhd = traf.getBoxByType(\"tfhd\");\n\n            // Patch trun and mdat boxes to duplicate first sample in order to have a complete fragment\n            // => use case in trick mode where we do request only Key (I) frames, while the <video> element\n            // requires continuous stream to enable playback\n            sampleDuration = trun.samples_table[0].sample_duration !== undefined ? trun.samples_table[0].sample_duration : tfhd.default_sample_duration;\n            fragmentDuration = request.duration * request.timescale;\n            if (trun.samples_table.length === 1 && sampleDuration < fragmentDuration) {\n                duplicateSample(fragment, fragmentDuration);\n            }\n\n            // if (tfhd.default_sample_duration) {\n            //     for (i = 0; i < trun.samples_table.length; i++) {\n            //         trun.samples_table[i].sample_duration = tfhd.default_sample_duration;\n            //     }\n            //     trun.flags |= 0x000100;\n            //     tfhd.flags &= 0xFFFFF7;\n            // }\n\n            // Update tfhd.track_ID field\n            tfhd.track_ID = trackId;\n\n            // Process tfxd boxes\n            // This box provide absolute timestamp but we take the segment start time for tfdt\n            traf.removeBoxByType(\"tfxd\");\n\n            // Create and add tfdt box\n            tfdt = traf.getBoxByType(\"tfdt\");\n            if (tfdt === null) {\n                tfdt = new mp4lib.boxes.TrackFragmentBaseMediaDecodeTimeBox();\n                tfdt.version = 1;\n                tfdt.flags = 0;\n                tfdt.baseMediaDecodeTime = Math.floor(request.startTime * request.timescale);\n                // Insert tfdt box just after the tfhd box (therefore before the trun box)\n                pos = traf.getBoxIndexByType(\"tfhd\");\n                traf.boxes.splice(pos + 1, 0, tfdt);\n            }\n\n            // Process tfrf box\n            if (manifest.type === 'dynamic')  {\n                tfrf = traf.getBoxesByType(\"tfrf\");\n                if (tfrf === null || tfrf.length === 0) {\n                    throw {\n                        name: MediaPlayer.dependencies.ErrorHandler.prototype.MSS_NO_TFRF,\n                        message: 'Missing tfrf in live media segment',\n                        data: {\n                            url: request.url\n                        }\n                    };\n                } else {\n                    for (i = 0; i < tfrf.length; i += 1) {\n                        processTfrf.call(this, request, tfrf[i], tfdt, adaptation);\n                        traf.removeBoxByType(\"tfrf\");\n                    }\n                }\n            }\n\n            // If protected content in PIFF1.1 format (sepiff box = Sample Encryption PIFF)\n            // => convert sepiff box it into a senc box\n            // => create saio and saiz boxes (if not already present)\n            sepiff = traf.getBoxByType(\"sepiff\");\n            if (sepiff !== null) {\n                sepiff.boxtype = \"senc\";\n                sepiff.extended_type = undefined;\n\n                saio = traf.getBoxByType(\"saio\");\n                if (saio === null) {\n                    // Create Sample Auxiliary Information Offsets Box box (saio)\n                    saio = new mp4lib.boxes.SampleAuxiliaryInformationOffsetsBox();\n                    saio.version = 0;\n                    saio.flags = 0;\n                    saio.entry_count = 1;\n                    saio.offset = [];\n\n                    saiz = new mp4lib.boxes.SampleAuxiliaryInformationSizesBox();\n                    saiz.version = 0;\n                    saiz.flags = 0;\n                    saiz.sample_count = sepiff.sample_count;\n                    saiz.default_sample_info_size = 0;\n                    saiz.sample_info_size = [];\n\n                    if (sepiff.flags & 0x02) {\n                        // Sub-sample encryption => set sample_info_size for each sample\n                        for (i = 0; i < sepiff.sample_count; i += 1) {\n                            // 10 = 8 (InitializationVector field size) + 2 (subsample_count field size)\n                            // 6 = 2 (BytesOfClearData field size) + 4 (BytesOfEncryptedData field size)\n                            saiz.sample_info_size[i] = 10 + (6 * sepiff.entry[i].NumberOfEntries);\n                        }\n                    } else {\n                        // No sub-sample encryption => set default sample_info_size = InitializationVector field size (8)\n                        saiz.default_sample_info_size = 8;\n                    }\n\n                    //add saio and saiz box\n                    traf.boxes.push(saiz);\n                    traf.boxes.push(saio);\n                }\n            }\n\n            // Before determining new size of the converted fragment we update some box flags related to data offset\n            tfhd.flags &= 0xFFFFFE; // set tfhd.base-data-offset-present to false\n            tfhd.flags |= 0x020000; // set tfhd.default-base-is-moof to true\n            trun.flags |= 0x000001; // set trun.data-offset-present to true\n            trun.data_offset = 0; // Set a default value for trun.data_offset\n\n            // Determine new size of the converted fragment and allocate new data buffer\n            fragment_size = fragment.getLength();\n\n            // Update trun.data_offset field = offset of first data byte (inside mdat box)\n            trun.data_offset = fragment_size - mdat.size + 8; // 8 = 'size' + 'type' mdat fields length\n\n            // Update saio box offset field according to new senc box offset\n            saio = traf.getBoxByType(\"saio\");\n            if (saio !== null) {\n                moofPosInFragment = fragment.getBoxOffsetByType(\"moof\");\n                trafPosInMoof = moof.getBoxOffsetByType(\"traf\");\n                sencPosInTraf = traf.getBoxOffsetByType(\"senc\");\n                // Set offset from begin fragment to the first IV field in senc box\n                saio.offset[0] = moofPosInFragment + trafPosInMoof + sencPosInTraf + 16; // 16 = box header (12) + sample_count field size (4)\n            }\n\n            new_data = mp4lib.serialize(fragment);\n\n            return new_data;\n        };\n\n    var rslt = MediaPlayer.utils.copyMethods(MediaPlayer.dependencies.FragmentController);\n\n    rslt.manifestModel = undefined;\n    rslt.manifestExt = undefined;\n    rslt.metricsModel = undefined;\n\n    rslt.process = function(bytes, request, representation) {\n        var deferred = Q.defer(),\n            result = null,\n            manifest = this.manifestModel.getValue(),\n            adaptation = null;\n\n        if (bytes !== null && bytes !== undefined && bytes.byteLength > 0) {\n            result = new Uint8Array(bytes);\n        } else {\n            deferred.resolve(null);\n            return deferred.promise;\n        }\n\n        if (manifest && representation) {\n            try {\n                // Get adaptation containing provided representations\n                // (Note: here representations is of type Dash.vo.Representation)\n                adaptation = manifest.Period_asArray[representation.adaptation.period.index].AdaptationSet_asArray[representation.adaptation.index];\n                if (request) {\n                    if (request.type === \"Media Segment\") {\n                        result = convertFragment.call(this, result, request, adaptation);\n                        deferred.resolve(!result ? null : result);\n                    } else if (request.type === \"FragmentInfo Segment\") {\n                        updateSegmentsList.call(this, result, request, adaptation);\n                        deferred.resolve(result);\n                    } else {\n                        deferred.resolve(result);\n                    }\n                }\n            } catch (e) {\n                deferred.reject(e);\n            }\n        } else {\n            deferred.resolve(result);\n        }\n\n        return deferred.promise;\n    };\n\n    return rslt;\n};\n\nMss.dependencies.MssFragmentController.prototype = {\n    constructor: Mss.dependencies.MssFragmentController\n};","/* $Date: 2007-06-12 18:02:31 $ */\n\n// from: http://bannister.us/weblog/2007/06/09/simple-base64-encodedecode-javascript/\n// Handles encode/decode of ASCII and Unicode strings.\n\nvar UTF8 = {};\nUTF8.encode = function(s) {\n    var u = [];\n    for (var i = 0; i < s.length; ++i) {\n        var c = s.charCodeAt(i);\n        if (c < 0x80) {\n            u.push(c);\n        } else if (c < 0x800) {\n            u.push(0xC0 | (c >> 6));\n            u.push(0x80 | (63 & c));\n        } else if (c < 0x10000) {\n            u.push(0xE0 | (c >> 12));\n            u.push(0x80 | (63 & (c >> 6)));\n            u.push(0x80 | (63 & c));\n        } else {\n            u.push(0xF0 | (c >> 18));\n            u.push(0x80 | (63 & (c >> 12)));\n            u.push(0x80 | (63 & (c >> 6)));\n            u.push(0x80 | (63 & c));\n        }\n    }\n    return u;\n};\nUTF8.decode = function(u) {\n    var a = [];\n    var i = 0;\n    while (i < u.length) {\n        var v = u[i++];\n        if (v < 0x80) {\n            // no need to mask byte\n        } else if (v < 0xE0) {\n            v = (31 & v) << 6;\n            v |= (63 & u[i++]);\n        } else if (v < 0xF0) {\n            v = (15 & v) << 12;\n            v |= (63 & u[i++]) << 6;\n            v |= (63 & u[i++]);\n        } else {\n            v = (7 & v) << 18;\n            v |= (63 & u[i++]) << 12;\n            v |= (63 & u[i++]) << 6;\n            v |= (63 & u[i++]);\n        }\n        a.push(String.fromCharCode(v));\n    }\n    return a.join('');\n};\n\nvar BASE64 = {};\n(function(T){\n    var encodeArray = function(u) {\n        var i = 0;\n        var a = [];\n        var n = 0 | (u.length / 3);\n        while (0 < n--) {\n            var v = (u[i] << 16) + (u[i+1] << 8) + u[i+2];\n            i += 3;\n            a.push(T.charAt(63 & (v >> 18)));\n            a.push(T.charAt(63 & (v >> 12)));\n            a.push(T.charAt(63 & (v >> 6)));\n            a.push(T.charAt(63 & v));\n        }\n        if (2 == (u.length - i)) {\n            var v = (u[i] << 16) + (u[i+1] << 8);\n            a.push(T.charAt(63 & (v >> 18)));\n            a.push(T.charAt(63 & (v >> 12)));\n            a.push(T.charAt(63 & (v >> 6)));\n            a.push('=');\n        } else if (1 == (u.length - i)) {\n            var v = (u[i] << 16);\n            a.push(T.charAt(63 & (v >> 18)));\n            a.push(T.charAt(63 & (v >> 12)));\n            a.push('==');\n        }\n        return a.join('');\n    }\n    var R = (function(){\n        var a = [];\n        for (var i=0; i<T.length; ++i) {\n            a[T.charCodeAt(i)] = i;\n        }\n        a['='.charCodeAt(0)] = 0;\n        return a;\n    })();\n    var decodeArray = function(s) {\n        var i = 0;\n        var u = [];\n        var n = 0 | (s.length / 4);\n        while (0 < n--) {\n            var v = (R[s.charCodeAt(i)] << 18) + (R[s.charCodeAt(i+1)] << 12) + (R[s.charCodeAt(i+2)] << 6) + R[s.charCodeAt(i+3)];\n            u.push(255 & (v >> 16));\n            u.push(255 & (v >> 8));\n            u.push(255 & v);\n            i += 4;\n        }\n        if (u) {\n            if ('=' == s.charAt(i-2)) {\n                u.pop();\n                u.pop();\n            } else if ('=' == s.charAt(i-1)) {\n                u.pop();\n            }\n        }\n        return u;\n    }\n    var ASCII = {};\n    ASCII.encode = function(s) {\n        var u = [];\n        for (var i = 0; i<s.length; ++i) {\n            u.push(s.charCodeAt(i));\n        }\n        return u;\n    };\n    ASCII.decode = function(u) {\n        for (var i = 0; i<s.length; ++i) {\n            a[i] = String.fromCharCode(a[i]);\n        }\n        return a.join('');\n    };\n    BASE64.decodeArray = function(s) {\n        var u = decodeArray(s);\n        return new Uint8Array(u);\n    };\n    BASE64.encodeASCII = function(s) {\n        var u = ASCII.encode(s);\n        return encodeArray(u);\n    };\n    BASE64.decodeASCII = function(s) {\n        var a = decodeArray(s);\n        return ASCII.decode(a);\n    };\n    BASE64.encode = function(s) {\n        var u = UTF8.encode(s);\n        return encodeArray(u);\n    };\n    BASE64.decode = function(s) {\n        var u = decodeArray(s);\n        return UTF8.decode(u);\n    };\n})(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\");\n\nif (undefined === btoa) {\n    var btoa = BASE64.encode;\n}\nif (undefined === atob) {\n    var atob = BASE64.decode;\n}\n","/**\n * @author <a href=\"http://www.creynders.be\">Camille Reynders</a>\n */\n( function ( scope ) {\n\n    \"use strict\";\n\n    /**\n     * @namespace\n     */\n    var dijon = {\n        /**\n         * framework version number\n         * @constant\n         * @type String\n         */\n        VERSION:'0.5.3'\n    };//dijon\n\n\n    //======================================//\n    // dijon.System\n    //======================================//\n\n    /**\n     * @class dijon.System\n     * @constructor\n     */\n    dijon.System = function () {\n        /** @private */\n        this._mappings = {};\n\n        /** @private */\n        this._outlets = {};\n\n        /** @private */\n        this._handlers = {};\n\n        /**\n         * When <code>true</code> injections are made only if an object has a property with the mapped outlet name.<br/>\n         * <strong>Set to <code>false</code> at own risk</strong>, may have quite undesired side effects.\n         * @example\n         * system.strictInjections = true\n         * var o = {};\n         * system.mapSingleton( 'userModel', UserModel );\n         * system.mapOutlet( 'userModel' );\n         * system.injectInto( o );\n         *\n         * //o is unchanged\n         *\n         * system.strictInjections = false;\n         * system.injectInto( o );\n         *\n         * //o now has a member 'userModel' which holds a reference to the singleton instance\n         * //of UserModel\n         * @type Boolean\n         * @default true\n         */\n        this.strictInjections = true;\n\n        /**\n         * Enables the automatic mapping of outlets for mapped values, singletons and classes\n         * When this is true any value, singleton or class that is mapped will automatically be mapped as a global outlet\n         * using the value of <code>key</code> as outlet name\n         *\n         * @example\n         * var o = {\n         *     userModel : undefined; //inject\n         * }\n         * system.mapSingleton( 'userModel', UserModel );\n         * system.injectInto( o ):\n         * //o.userModel now holds a reference to the singleton instance of UserModel\n         * @type Boolean\n         * @default false\n         */\n        this.autoMapOutlets = false;\n\n        /**\n         * The name of the method that will be called for all instances, right after injection has occured.\n         * @type String\n         * @default 'setup'\n         */\n        this.postInjectionHook = 'setup';\n\n    };//dijon.System\n\n    dijon.System.prototype = {\n\n        /**\n         * @private\n         * @param {Class} clazz\n         */\n        _createAndSetupInstance:function ( key, Clazz ) {\n            var instance = new Clazz();\n            this.injectInto( instance, key );\n            return instance;\n        },\n\n        /**\n         * @private\n         * @param {String} key\n         * @param {Boolean} overrideRules\n         * @return {Object}\n         */\n        _retrieveFromCacheOrCreate:function ( key, overrideRules ) {\n            if ( typeof overrideRules === 'undefined' ) {\n                overrideRules = false;\n            }\n            var output;\n            if ( this._mappings.hasOwnProperty( key ) ) {\n                var config = this._mappings[ key ];\n                if ( !overrideRules && config.isSingleton ) {\n                    if ( config.object == null ) {\n                        config.object = this._createAndSetupInstance( key, config.clazz );\n                    }\n                    output = config.object;\n                } else {\n                    if ( config.clazz ) {\n                        output = this._createAndSetupInstance( key, config.clazz );\n                    } else {\n                        //TODO shouldn't this be null\n                        output = config.object;\n                    }\n                }\n            } else {\n                throw new Error( 1000 );\n            }\n            return output;\n        },\n\n\n        /**\n         * defines <code>outletName</code> as an injection point in <code>targetKey</code>for the object mapped to <code>sourceKey</code>\n         * @example\n         system.mapSingleton( 'userModel', TestClassA );\n         var o = {\n         user : undefined //inject\n         }\n         system.mapOutlet( 'userModel', 'o', 'user' );\n         system.mapValue( 'o', o );\n\n         var obj = system.getObject( 'o' );\n         * //obj.user holds a reference to the singleton instance of UserModel\n         *\n         * @example\n         system.mapSingleton( 'userModel', TestClassA );\n         var o = {\n         userModel : undefined //inject\n         }\n         system.mapOutlet( 'userModel', 'o' );\n         system.mapValue( 'o', o );\n\n         var obj = system.getObject( 'o' );\n         * //obj.userModel holds a reference to the singleton instance of UserModel\n         *\n         * @example\n         system.mapSingleton( 'userModel', TestClassA );\n         system.mapOutlet( 'userModel' );\n         var o = {\n         userModel : undefined //inject\n         }\n         system.mapValue( 'o', o );\n\n         var obj = system.getObject( 'o' );\n         * //o.userModel holds a reference to the singleton instance of userModel\n         *\n         * @param {String} sourceKey the key mapped to the object that will be injected\n         * @param {String} [targetKey='global'] the key the outlet is assigned to.\n         * @param {String} [outletName=sourceKey] the name of the property used as an outlet.<br/>\n         * @return {dijon.System}\n         * @see dijon.System#unmapOutlet\n         */\n        mapOutlet:function ( sourceKey, targetKey, outletName ) {\n            if ( typeof sourceKey === 'undefined' ) {\n                throw new Error( 1010 );\n            }\n            targetKey = targetKey || \"global\";\n            outletName = outletName || sourceKey;\n\n            if ( !this._outlets.hasOwnProperty( targetKey ) ) {\n                this._outlets[ targetKey ] = {};\n            }\n            this._outlets[ targetKey ][ outletName ] = sourceKey;\n\n            return this;\n        },\n\n        /**\n         * Retrieve (or create) the object mapped to <code>key</code>\n         * @example\n         * system.mapValue( 'foo', 'bar' );\n         * var b = system.getObject( 'foo' ); //now contains 'bar'\n         * @param {Object} key\n         * @return {Object}\n         */\n        getObject:function ( key ) {\n            if ( typeof key === 'undefined' ) {\n                throw new Error( 1020 );\n            }\n            return this._retrieveFromCacheOrCreate( key );\n        },\n\n        /**\n         * Maps <code>useValue</code> to <code>key</code>\n         * @example\n         * system.mapValue( 'foo', 'bar' );\n         * var b = system.getObject( 'foo' ); //now contains 'bar'\n         * @param {String} key\n         * @param {Object} useValue\n         * @return {dijon.System}\n         */\n        mapValue:function ( key, useValue ) {\n            if ( typeof key === 'undefined' ) {\n                throw new Error( 1030 );\n            }\n            this._mappings[ key ] = {\n                clazz:null,\n                object:useValue,\n                isSingleton:true\n            };\n            if ( this.autoMapOutlets ) {\n                this.mapOutlet( key );\n            }\n            if ( this.hasMapping( key )) {\n                this.injectInto( useValue, key );\n            }\n            return this;\n        },\n\n        /**\n         * Returns whether the key is mapped to an object\n         * @example\n         * system.mapValue( 'foo', 'bar' );\n         * var isMapped = system.hasMapping( 'foo' );\n         * @param {String} key\n         * @return {Boolean}\n         */\n        hasMapping:function ( key ) {\n            if ( typeof key === 'undefined' ) {\n                throw new Error( 1040 );\n            }\n            return this._mappings.hasOwnProperty( key );\n        },\n\n        /**\n         * Maps <code>clazz</code> as a factory to <code>key</code>\n         * @example\n         * var SomeClass = function(){\n         * }\n         * system.mapClass( 'o', SomeClass );\n         *\n         * var s1 = system.getObject( 'o' );\n         * var s2 = system.getObject( 'o' );\n         *\n         * //s1 and s2 reference two different instances of SomeClass\n         *\n         * @param {String} key\n         * @param {Function} clazz\n         * @return {dijon.System}\n         */\n        mapClass:function ( key, clazz ) {\n            if ( typeof key === 'undefined' ) {\n                throw new Error( 1050 );\n            }\n            if ( typeof clazz === 'undefined' ) {\n                throw new Error( 1051 );\n            }\n            this._mappings[ key ] = {\n                clazz:clazz,\n                object:null,\n                isSingleton:false\n            };\n            if ( this.autoMapOutlets ) {\n                this.mapOutlet( key );\n            }\n            return this;\n        },\n\n        /**\n         * Maps <code>clazz</code> as a singleton factory to <code>key</code>\n         * @example\n         * var SomeClass = function(){\n         * }\n         * system.mapSingleton( 'o', SomeClass );\n         *\n         * var s1 = system.getObject( 'o' );\n         * var s2 = system.getObject( 'o' );\n         *\n         * //s1 and s2 reference the same instance of SomeClass\n         *\n         * @param {String} key\n         * @param {Function} clazz\n         * @return {dijon.System}\n         */\n        mapSingleton:function ( key, clazz ) {\n            if ( typeof key === 'undefined' ) {\n                throw new Error( 1060 );\n            }\n            if ( typeof clazz === 'undefined' ) {\n                throw new Error( 1061 );\n            }\n            this._mappings[ key ] = {\n                clazz:clazz,\n                object:null,\n                isSingleton:true\n            };\n            if ( this.autoMapOutlets ) {\n                this.mapOutlet( key );\n            }\n            return this;\n        },\n\n        /**\n         * Force instantiation of the class mapped to <code>key</code>, whether it was mapped as a singleton or not.\n         * When a value was mapped, the value will be returned.\n         * TODO: should this last rule be changed?\n         * @example\n         var SomeClass = function(){\n         }\n         system.mapClass( 'o', SomeClass );\n\n         var s1 = system.getObject( 'o' );\n         var s2 = system.getObject( 'o' );\n         * //s1 and s2 reference different instances of SomeClass\n         *\n         * @param {String} key\n         * @return {Object}\n         */\n        instantiate:function ( key ) {\n            if ( typeof key === 'undefined' ) {\n                throw new Error( 1070 );\n            }\n            return this._retrieveFromCacheOrCreate( key, true );\n        },\n\n        /**\n         * Perform an injection into an object's mapped outlets, satisfying all it's dependencies\n         * @example\n         * var UserModel = function(){\n         * }\n         * system.mapSingleton( 'userModel', UserModel );\n         * var SomeClass = function(){\n         *      user = undefined; //inject\n         * }\n         * system.mapSingleton( 'o', SomeClass );\n         * system.mapOutlet( 'userModel', 'o', 'user' );\n         *\n         * var foo = {\n         *      user : undefined //inject\n         * }\n         *\n         * system.injectInto( foo, 'o' );\n         *\n         * //foo.user now holds a reference to the singleton instance of UserModel\n         * @param {Object} instance\n         * @param {String} [key] use the outlet mappings as defined for <code>key</code>, otherwise only the globally\n         * mapped outlets will be used.\n         * @return {dijon.System}\n         */\n        injectInto:function ( instance, key ) {\n            if ( typeof instance === 'undefined' ) {\n                throw new Error( 1080 );\n            }\n\t\t\tif( ( typeof instance === 'object' ) ){\n\t\t\t\tvar o = [];\n\t\t\t\tif ( this._outlets.hasOwnProperty( 'global' ) ) {\n\t\t\t\t\to.push( this._outlets[ 'global' ] );\n\t\t\t\t}\n\t\t\t\tif ( typeof key !== 'undefined' && this._outlets.hasOwnProperty( key ) ) {\n\t\t\t\t\to.push( this._outlets[ key ] );\n\t\t\t\t}\n\t\t\t\tfor ( var i in o ) {\n\t\t\t\t\tvar l = o [ i ];\n\t\t\t\t\tfor ( var outlet in l ) {\n\t\t\t\t\t\tvar source = l[ outlet ];\n\t\t\t\t\t\t//must be \"in\" [!]\n\t\t\t\t\t\tif ( !this.strictInjections || outlet in instance ) {\n\t\t\t\t\t\t\tinstance[ outlet ] = this.getObject( source );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ( \"setup\" in instance ) {\n\t\t\t\t\tinstance.setup.call( instance );\n\t\t\t\t}\n\t\t\t}\n            return this;\n        },\n\n        /**\n         * Remove the mapping of <code>key</code> from the system\n         * @param {String} key\n         * @return {dijon.System}\n         */\n        unmap:function ( key ) {\n            if ( typeof key === 'undefined' ) {\n                throw new Error( 1090 );\n            }\n            delete this._mappings[ key ];\n\n            return this;\n        },\n\n        /**\n         * removes an injection point mapping for a given object mapped to <code>key</code>\n         * @param {String} target\n         * @param {String} outlet\n         * @return {dijon.System}\n         * @see dijon.System#addOutlet\n         */\n        unmapOutlet:function ( target, outlet ) {\n            if ( typeof target === 'undefined' ) {\n                throw new Error( 1100 );\n            }\n            if ( typeof outlet === 'undefined' ) {\n                throw new Error( 1101 );\n            }\n            delete this._outlets[ target ][ outlet ];\n\n            return this;\n        },\n\n        /**\n         * maps a handler for an event/route.<br/>\n         * @example\n         var hasExecuted = false;\n         var userView = {\n         showUserProfile : function(){\n         hasExecuted = true;\n         }\n         }\n         system.mapValue( 'userView', userView );\n         system.mapHandler( 'user/profile', 'userView', 'showUserProfile' );\n         system.notify( 'user/profile' );\n         //hasExecuted is true\n         * @example\n         * var userView = {\n         *      showUserProfile : function(){\n         *          //do stuff\n         *      }\n         * }\n         * system.mapValue( 'userView', userView );\n         * <strong>system.mapHandler( 'showUserProfile', 'userView' );</strong>\n         * system.notify( 'showUserProfile' );\n         *\n         * //userView.showUserProfile is called\n         * @example\n         * var showUserProfile = function(){\n         *          //do stuff\n         * }\n         * <strong>system.mapHandler( 'user/profile', undefined, showUserProfile );</strong>\n         * system.notify( 'user/profile' );\n         *\n         * //showUserProfile is called\n         * @example\n         * var userView = {};\n         * var showUserProfile = function(){\n         *          //do stuff\n         * }\n         * system.mapValue( 'userView', userView );\n         * <strong>system.mapHandler( 'user/profile', 'userView', showUserProfile );</strong>\n         * system.notify( 'user/profile' );\n         *\n         * //showUserProfile is called within the scope of the userView object\n         * @example\n         * var userView = {\n         *      showUserProfile : function(){\n         *          //do stuff\n         *      }\n         * }\n         * system.mapValue( 'userView', userView );\n         * <strong>system.mapHandler( 'user/profile', 'userView', 'showUserProfile', true );</strong>\n         * system.notify( 'user/profile' );\n         * system.notify( 'user/profile' );\n         * system.notify( 'user/profile' );\n         *\n         * //userView.showUserProfile is called exactly once [!]\n         * @example\n         * var userView = {\n         *      showUserProfile : function( route ){\n         *          //do stuff\n         *      }\n         * }\n         * system.mapValue( 'userView', userView );\n         * <strong>system.mapHandler( 'user/profile', 'userView', 'showUserProfile', false, true );</strong>\n         * system.notify( 'user/profile' );\n         *\n         * //userView.showUserProfile is called and the route/eventName is passed to the handler\n         * @param {String} eventName/route\n         * @param {String} [key=undefined] If <code>key</code> is <code>undefined</code> the handler will be called without\n         * scope.\n         * @param {String|Function} [handler=eventName] If <code>handler</code> is <code>undefined</code> the value of\n         * <code>eventName</code> will be used as the name of the member holding the reference to the to-be-called function.\n         * <code>handler</code> accepts either a string, which will be used as the name of the member holding the reference\n         * to the to-be-called function, or a direct function reference.\n         * @param {Boolean} [oneShot=false] Defines whether the handler should be called exactly once and then automatically\n         * unmapped\n         * @param {Boolean} [passEvent=false] Defines whether the event object should be passed to the handler or not.\n         * @return {dijon.System}\n         * @see dijon.System#notify\n         * @see dijon.System#unmapHandler\n         */\n        mapHandler:function ( eventName, key, handler, oneShot, passEvent ) {\n            if ( typeof eventName === 'undefined' ) {\n                throw new Error( 1110 );\n            }\n            key = key || 'global';\n            handler = handler || eventName;\n\n            if ( typeof oneShot === 'undefined' ) {\n                oneShot = false;\n            }\n            if ( typeof passEvent === 'undefined' ) {\n                passEvent = false;\n            }\n            if ( !this._handlers.hasOwnProperty( eventName ) ) {\n                this._handlers[ eventName ] = {};\n            }\n            if ( !this._handlers[eventName].hasOwnProperty( key ) ) {\n                this._handlers[eventName][key] = [];\n            }\n            this._handlers[ eventName ][ key ].push( {\n                handler:handler,\n                oneShot:oneShot,\n                passEvent:passEvent\n            } );\n\n            return this;\n        },\n\n        /**\n         * Unmaps the handler for a specific event/route.\n         * @param {String} eventName Name of the event/route\n         * @param {String} [key=undefined] If <code>key</code> is <code>undefined</code> the handler is removed from the\n         * global mapping space. (If the same event is mapped globally and specifically for an object, then\n         * only the globally mapped one will be removed)\n         * @param {String | Function} [handler=eventName]\n         * @return {dijon.System}\n         * @see dijon.System#mapHandler\n         */\n        unmapHandler:function ( eventName, key, handler ) {\n            if ( typeof eventName === 'undefined' ) {\n                throw new Error( 1120 );\n            }\n            key = key || 'global';\n            //handler = handler || eventName;\n\n            if ( this._handlers.hasOwnProperty( eventName ) && this._handlers[ eventName ].hasOwnProperty( key ) ) {\n                var handlers = this._handlers[ eventName ][ key ];\n                for ( var i in handlers ) {\n                    var config = handlers[ i ];\n                    if ( (!handler) || (config.handler === handler) ) {\n                        handlers.splice( i, 1 );\n                        break;\n                    }\n                }\n            }\n            return this;\n        },\n\n        /**\n         * calls all handlers mapped to <code>eventName/route</code>\n         * @param {String} eventName/route\n         * @return {dijon.System}\n         * @see dijon.System#mapHandler\n         */\n        notify:function ( eventName ) {\n            if ( typeof eventName === 'undefined' ) {\n                throw new Error( 1130 );\n            }\n            var argsWithEvent = Array.prototype.slice.call( arguments );\n            var argsClean = argsWithEvent.slice( 1 );\n            if ( this._handlers.hasOwnProperty( eventName ) ) {\n                var handlers = this._handlers[ eventName ];\n                for ( var key in handlers ) {\n                    var configs = handlers[ key ];\n                    var instance;\n                    if ( key !== 'global' ) {\n                        instance = this.getObject( key );\n                    }\n                    var toBeDeleted = [];\n                    var i, n;\n                    for ( i = 0, n = configs.length ; i < n ; i++ ) {\n                        var handler;\n                        var config = configs[ i ];\n                        if ( instance && typeof config.handler === \"string\" ) {\n                            handler = instance[ config.handler ];\n                        } else {\n                            handler = config.handler;\n                        }\n\n                        //see deletion below\n                        if ( config.oneShot ) {\n                            toBeDeleted.unshift( i );\n                        }\n\n                        if ( config.passEvent ) {\n                            handler.apply( instance, argsWithEvent );\n                        } else {\n                            handler.apply( instance, argsClean );\n                        }\n                    }\n\n                    //items should be deleted in reverse order\n                    //either use push above and decrement here\n                    //or use unshift above and increment here\n                    for ( i = 0, n = toBeDeleted.length ; i < n ; i++ ) {\n                        configs.splice( toBeDeleted[ i ], 1 );\n                    }\n                }\n            }\n\n            return this;\n        }\n\n    };//dijon.System.prototype\n\n    scope.dijon = dijon;\n}( this ));\n\n\n","// Copyright 2009 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\ngoog = {};\ngoog.math = {};\n\n\n\n/**\n * @fileoverview Defines a Long class for representing a 64-bit two's-complement\n * integer value, which faithfully simulates the behavior of a Java \"long\". This\n * implementation is derived from LongLib in GWT.\n *\n */\n\n//goog.provide('goog.math.Long');\n\n\n\n/**\n * Constructs a 64-bit two's-complement integer, given its low and high 32-bit\n * values as *signed* integers.  See the from* functions below for more\n * convenient ways of constructing Longs.\n *\n * The internal representation of a long is the two given signed, 32-bit values.\n * We use 32-bit pieces because these are the size of integers on which\n * Javascript performs bit-operations.  For operations like addition and\n * multiplication, we split each number into 16-bit pieces, which can easily be\n * multiplied within Javascript's floating-point representation without overflow\n * or change in sign.\n *\n * In the algorithms below, we frequently reduce the negative case to the\n * positive case by negating the input(s) and then post-processing the result.\n * Note that we must ALWAYS check specially whether those values are MIN_VALUE\n * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n * a positive number, it overflows back into a negative).  Not handling this\n * case would often result in infinite recursion.\n *\n * @param {number} low  The low (signed) 32 bits of the long.\n * @param {number} high  The high (signed) 32 bits of the long.\n * @constructor\n */\ngoog.math.Long = function(low, high) {\n  /**\n   * @type {number}\n   * @private\n   */\n  this.low_ = low | 0;  // force into 32 signed bits.\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.high_ = high | 0;  // force into 32 signed bits.\n};\n\n\n// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the\n// from* methods on which they depend.\n\n\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object}\n * @private\n */\ngoog.math.Long.IntCache_ = {};\n\n\n/**\n * Returns a Long representing the given (32-bit) integer value.\n * @param {number} value The 32-bit integer in question.\n * @return {!goog.math.Long} The corresponding Long value.\n */\ngoog.math.Long.fromInt = function(value) {\n  if (-128 <= value && value < 128) {\n    var cachedObj = goog.math.Long.IntCache_[value];\n    if (cachedObj) {\n      return cachedObj;\n    }\n  }\n\n  var obj = new goog.math.Long(value | 0, value < 0 ? -1 : 0);\n  if (-128 <= value && value < 128) {\n    goog.math.Long.IntCache_[value] = obj;\n  }\n  return obj;\n};\n\n\n/**\n * Returns a Long representing the given value, provided that it is a finite\n * number.  Otherwise, zero is returned.\n * @param {number} value The number in question.\n * @return {!goog.math.Long} The corresponding Long value.\n */\ngoog.math.Long.fromNumber = function(value) {\n  if (isNaN(value) || !isFinite(value)) {\n    return goog.math.Long.ZERO;\n  } else if (value <= -goog.math.Long.TWO_PWR_63_DBL_) {\n    return goog.math.Long.MIN_VALUE;\n  } else if (value + 1 >= goog.math.Long.TWO_PWR_63_DBL_) {\n    return goog.math.Long.MAX_VALUE;\n  } else if (value < 0) {\n    return goog.math.Long.fromNumber(-value).negate();\n  } else {\n    return new goog.math.Long(\n        (value % goog.math.Long.TWO_PWR_32_DBL_) | 0,\n        (value / goog.math.Long.TWO_PWR_32_DBL_) | 0);\n  }\n};\n\n\n/**\n * Returns a Long representing the 64-bit integer that comes by concatenating\n * the given high and low bits.  Each is assumed to use 32 bits.\n * @param {number} lowBits The low 32-bits.\n * @param {number} highBits The high 32-bits.\n * @return {!goog.math.Long} The corresponding Long value.\n */\ngoog.math.Long.fromBits = function(lowBits, highBits) {\n  return new goog.math.Long(lowBits, highBits);\n};\n\n\n/**\n * Returns a Long representation of the given string, written using the given\n * radix.\n * @param {string} str The textual representation of the Long.\n * @param {number=} opt_radix The radix in which the text is written.\n * @return {!goog.math.Long} The corresponding Long value.\n */\ngoog.math.Long.fromString = function(str, opt_radix) {\n  if (str.length == 0) {\n    throw Error('number format error: empty string');\n  }\n\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (str.charAt(0) == '-') {\n    return goog.math.Long.fromString(str.substring(1), radix).negate();\n  } else if (str.indexOf('-') >= 0) {\n    throw Error('number format error: interior \"-\" character: ' + str);\n  }\n\n  // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = goog.math.Long.fromNumber(Math.pow(radix, 8));\n\n  var result = goog.math.Long.ZERO;\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i);\n    var value = parseInt(str.substring(i, i + size), radix);\n    if (size < 8) {\n      var power = goog.math.Long.fromNumber(Math.pow(radix, size));\n      result = result.multiply(power).add(goog.math.Long.fromNumber(value));\n    } else {\n      result = result.multiply(radixToPower);\n      result = result.add(goog.math.Long.fromNumber(value));\n    }\n  }\n  return result;\n};\n\n\n// NOTE: the compiler should inline these constant values below and then remove\n// these variables, so there should be no runtime penalty for these.\n\n\n/**\n * Number used repeated below in calculations.  This must appear before the\n * first call to any from* function below.\n * @type {number}\n * @private\n */\ngoog.math.Long.TWO_PWR_16_DBL_ = 1 << 16;\n\n\n/**\n * @type {number}\n * @private\n */\ngoog.math.Long.TWO_PWR_24_DBL_ = 1 << 24;\n\n\n/**\n * @type {number}\n * @private\n */\ngoog.math.Long.TWO_PWR_32_DBL_ =\n    goog.math.Long.TWO_PWR_16_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\ngoog.math.Long.TWO_PWR_31_DBL_ =\n    goog.math.Long.TWO_PWR_32_DBL_ / 2;\n\n\n/**\n * @type {number}\n * @private\n */\ngoog.math.Long.TWO_PWR_48_DBL_ =\n    goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_16_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\ngoog.math.Long.TWO_PWR_64_DBL_ =\n    goog.math.Long.TWO_PWR_32_DBL_ * goog.math.Long.TWO_PWR_32_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\ngoog.math.Long.TWO_PWR_63_DBL_ =\n    goog.math.Long.TWO_PWR_64_DBL_ / 2;\n\n\n/** @type {!goog.math.Long} */\ngoog.math.Long.ZERO = goog.math.Long.fromInt(0);\n\n\n/** @type {!goog.math.Long} */\ngoog.math.Long.ONE = goog.math.Long.fromInt(1);\n\n\n/** @type {!goog.math.Long} */\ngoog.math.Long.NEG_ONE = goog.math.Long.fromInt(-1);\n\n\n/** @type {!goog.math.Long} */\ngoog.math.Long.MAX_VALUE =\n    goog.math.Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);\n\n\n/** @type {!goog.math.Long} */\ngoog.math.Long.MIN_VALUE = goog.math.Long.fromBits(0, 0x80000000 | 0);\n\n\n/**\n * @type {!goog.math.Long}\n * @private\n */\ngoog.math.Long.TWO_PWR_24_ = goog.math.Long.fromInt(1 << 24);\n\n\n/** @return {number} The value, assuming it is a 32-bit integer. */\ngoog.math.Long.prototype.toInt = function() {\n  return this.low_;\n};\n\n\n/** @return {number} The closest floating-point representation to this value. */\ngoog.math.Long.prototype.toNumber = function() {\n  return this.high_ * goog.math.Long.TWO_PWR_32_DBL_ +\n         this.getLowBitsUnsigned();\n};\n\n\n/**\n * @param {number=} opt_radix The radix in which the text should be written.\n * @return {string} The textual representation of this value.\n * @override\n */\ngoog.math.Long.prototype.toString = function(opt_radix) {\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (this.isZero()) {\n    return '0';\n  }\n\n  if (this.isNegative()) {\n    if (this.equals(goog.math.Long.MIN_VALUE)) {\n      // We need to change the Long value before it can be negated, so we remove\n      // the bottom-most digit in this base and then recurse to do the rest.\n      var radixLong = goog.math.Long.fromNumber(radix);\n      var div = this.div(radixLong);\n      var rem = div.multiply(radixLong).subtract(this);\n      return div.toString(radix) + rem.toInt().toString(radix);\n    } else {\n      return '-' + this.negate().toString(radix);\n    }\n  }\n\n  // Do several (6) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = goog.math.Long.fromNumber(Math.pow(radix, 6));\n\n  var rem = this;\n  var result = '';\n  while (true) {\n    var remDiv = rem.div(radixToPower);\n    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();\n    var digits = intval.toString(radix);\n\n    rem = remDiv;\n    if (rem.isZero()) {\n      return digits + result;\n    } else {\n      while (digits.length < 6) {\n        digits = '0' + digits;\n      }\n      result = '' + digits + result;\n    }\n  }\n};\n\n\n/** @return {number} The high 32-bits as a signed value. */\ngoog.math.Long.prototype.getHighBits = function() {\n  return this.high_;\n};\n\n\n/** @return {number} The low 32-bits as a signed value. */\ngoog.math.Long.prototype.getLowBits = function() {\n  return this.low_;\n};\n\n\n/** @return {number} The low 32-bits as an unsigned value. */\ngoog.math.Long.prototype.getLowBitsUnsigned = function() {\n  return (this.low_ >= 0) ?\n      this.low_ : goog.math.Long.TWO_PWR_32_DBL_ + this.low_;\n};\n\n\n/**\n * @return {number} Returns the number of bits needed to represent the absolute\n *     value of this Long.\n */\ngoog.math.Long.prototype.getNumBitsAbs = function() {\n  if (this.isNegative()) {\n    if (this.equals(goog.math.Long.MIN_VALUE)) {\n      return 64;\n    } else {\n      return this.negate().getNumBitsAbs();\n    }\n  } else {\n    var val = this.high_ != 0 ? this.high_ : this.low_;\n    for (var bit = 31; bit > 0; bit--) {\n      if ((val & (1 << bit)) != 0) {\n        break;\n      }\n    }\n    return this.high_ != 0 ? bit + 33 : bit + 1;\n  }\n};\n\n\n/** @return {boolean} Whether this value is zero. */\ngoog.math.Long.prototype.isZero = function() {\n  return this.high_ == 0 && this.low_ == 0;\n};\n\n\n/** @return {boolean} Whether this value is negative. */\ngoog.math.Long.prototype.isNegative = function() {\n  return this.high_ < 0;\n};\n\n\n/** @return {boolean} Whether this value is odd. */\ngoog.math.Long.prototype.isOdd = function() {\n  return (this.low_ & 1) == 1;\n};\n\n\n/**\n * @param {goog.math.Long} other Long to compare against.\n * @return {boolean} Whether this Long equals the other.\n */\ngoog.math.Long.prototype.equals = function(other) {\n  return (this.high_ == other.high_) && (this.low_ == other.low_);\n};\n\n\n/**\n * @param {goog.math.Long} other Long to compare against.\n * @return {boolean} Whether this Long does not equal the other.\n */\ngoog.math.Long.prototype.notEquals = function(other) {\n  return (this.high_ != other.high_) || (this.low_ != other.low_);\n};\n\n\n/**\n * @param {goog.math.Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than the other.\n */\ngoog.math.Long.prototype.lessThan = function(other) {\n  return this.compare(other) < 0;\n};\n\n\n/**\n * @param {goog.math.Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than or equal to the other.\n */\ngoog.math.Long.prototype.lessThanOrEqual = function(other) {\n  return this.compare(other) <= 0;\n};\n\n\n/**\n * @param {goog.math.Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than the other.\n */\ngoog.math.Long.prototype.greaterThan = function(other) {\n  return this.compare(other) > 0;\n};\n\n\n/**\n * @param {goog.math.Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than or equal to the other.\n */\ngoog.math.Long.prototype.greaterThanOrEqual = function(other) {\n  return this.compare(other) >= 0;\n};\n\n\n/**\n * Compares this Long with the given one.\n * @param {goog.math.Long} other Long to compare against.\n * @return {number} 0 if they are the same, 1 if the this is greater, and -1\n *     if the given one is greater.\n */\ngoog.math.Long.prototype.compare = function(other) {\n  if (this.equals(other)) {\n    return 0;\n  }\n\n  var thisNeg = this.isNegative();\n  var otherNeg = other.isNegative();\n  if (thisNeg && !otherNeg) {\n    return -1;\n  }\n  if (!thisNeg && otherNeg) {\n    return 1;\n  }\n\n  // at this point, the signs are the same, so subtraction will not overflow\n  if (this.subtract(other).isNegative()) {\n    return -1;\n  } else {\n    return 1;\n  }\n};\n\n\n/** @return {!goog.math.Long} The negation of this value. */\ngoog.math.Long.prototype.negate = function() {\n  if (this.equals(goog.math.Long.MIN_VALUE)) {\n    return goog.math.Long.MIN_VALUE;\n  } else {\n    return this.not().add(goog.math.Long.ONE);\n  }\n};\n\n\n/**\n * Returns the sum of this and the given Long.\n * @param {goog.math.Long} other Long to add to this one.\n * @return {!goog.math.Long} The sum of this and the given Long.\n */\ngoog.math.Long.prototype.add = function(other) {\n  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 + b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 + b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 + b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 + b48;\n  c48 &= 0xFFFF;\n  return goog.math.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n};\n\n\n/**\n * Returns the difference of this and the given Long.\n * @param {goog.math.Long} other Long to subtract from this.\n * @return {!goog.math.Long} The difference of this and the given Long.\n */\ngoog.math.Long.prototype.subtract = function(other) {\n  return this.add(other.negate());\n};\n\n\n/**\n * Returns the product of this and the given long.\n * @param {goog.math.Long} other Long to multiply with this.\n * @return {!goog.math.Long} The product of this and the other.\n */\ngoog.math.Long.prototype.multiply = function(other) {\n  if (this.isZero()) {\n    return goog.math.Long.ZERO;\n  } else if (other.isZero()) {\n    return goog.math.Long.ZERO;\n  }\n\n  if (this.equals(goog.math.Long.MIN_VALUE)) {\n    return other.isOdd() ? goog.math.Long.MIN_VALUE : goog.math.Long.ZERO;\n  } else if (other.equals(goog.math.Long.MIN_VALUE)) {\n    return this.isOdd() ? goog.math.Long.MIN_VALUE : goog.math.Long.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().multiply(other.negate());\n    } else {\n      return this.negate().multiply(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.multiply(other.negate()).negate();\n  }\n\n  // If both longs are small, use float multiplication\n  if (this.lessThan(goog.math.Long.TWO_PWR_24_) &&\n      other.lessThan(goog.math.Long.TWO_PWR_24_)) {\n    return goog.math.Long.fromNumber(this.toNumber() * other.toNumber());\n  }\n\n  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n  // We can skip products that would overflow.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 * b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 * b00;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c16 += a00 * b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 * b00;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a16 * b16;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a00 * b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n  c48 &= 0xFFFF;\n  return goog.math.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n};\n\n\n/**\n * Returns this Long divided by the given one.\n * @param {goog.math.Long} other Long by which to divide.\n * @return {!goog.math.Long} This Long divided by the given one.\n */\ngoog.math.Long.prototype.div = function(other) {\n  if (other.isZero()) {\n    throw Error('division by zero');\n  } else if (this.isZero()) {\n    return goog.math.Long.ZERO;\n  }\n\n  if (this.equals(goog.math.Long.MIN_VALUE)) {\n    if (other.equals(goog.math.Long.ONE) ||\n        other.equals(goog.math.Long.NEG_ONE)) {\n      return goog.math.Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\n    } else if (other.equals(goog.math.Long.MIN_VALUE)) {\n      return goog.math.Long.ONE;\n    } else {\n      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n      var halfThis = this.shiftRight(1);\n      var approx = halfThis.div(other).shiftLeft(1);\n      if (approx.equals(goog.math.Long.ZERO)) {\n        return other.isNegative() ? goog.math.Long.ONE : goog.math.Long.NEG_ONE;\n      } else {\n        var rem = this.subtract(other.multiply(approx));\n        var result = approx.add(rem.div(other));\n        return result;\n      }\n    }\n  } else if (other.equals(goog.math.Long.MIN_VALUE)) {\n    return goog.math.Long.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().div(other.negate());\n    } else {\n      return this.negate().div(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.div(other.negate()).negate();\n  }\n\n  // Repeat the following until the remainder is less than other:  find a\n  // floating-point that approximates remainder / other *from below*, add this\n  // into the result, and subtract it from the remainder.  It is critical that\n  // the approximate value is less than or equal to the real value so that the\n  // remainder never becomes negative.\n  var res = goog.math.Long.ZERO;\n  var rem = this;\n  while (rem.greaterThanOrEqual(other)) {\n    // Approximate the result of division. This may be a little greater or\n    // smaller than the actual value.\n    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));\n\n    // We will tweak the approximate result by changing it in the 48-th digit or\n    // the smallest non-fractional digit, whichever is larger.\n    var log2 = Math.ceil(Math.log(approx) / Math.LN2);\n    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);\n\n    // Decrease the approximation until it is smaller than the remainder.  Note\n    // that if it is too large, the product overflows and is negative.\n    var approxRes = goog.math.Long.fromNumber(approx);\n    var approxRem = approxRes.multiply(other);\n    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {\n      approx -= delta;\n      approxRes = goog.math.Long.fromNumber(approx);\n      approxRem = approxRes.multiply(other);\n    }\n\n    // We know the answer can't be zero... and actually, zero would cause\n    // infinite recursion since we would make no progress.\n    if (approxRes.isZero()) {\n      approxRes = goog.math.Long.ONE;\n    }\n\n    res = res.add(approxRes);\n    rem = rem.subtract(approxRem);\n  }\n  return res;\n};\n\n\n/**\n * Returns this Long modulo the given one.\n * @param {goog.math.Long} other Long by which to mod.\n * @return {!goog.math.Long} This Long modulo the given one.\n */\ngoog.math.Long.prototype.modulo = function(other) {\n  return this.subtract(this.div(other).multiply(other));\n};\n\n\n/** @return {!goog.math.Long} The bitwise-NOT of this value. */\ngoog.math.Long.prototype.not = function() {\n  return goog.math.Long.fromBits(~this.low_, ~this.high_);\n};\n\n\n/**\n * Returns the bitwise-AND of this Long and the given one.\n * @param {goog.math.Long} other The Long with which to AND.\n * @return {!goog.math.Long} The bitwise-AND of this and the other.\n */\ngoog.math.Long.prototype.and = function(other) {\n  return goog.math.Long.fromBits(this.low_ & other.low_,\n                                 this.high_ & other.high_);\n};\n\n\n/**\n * Returns the bitwise-OR of this Long and the given one.\n * @param {goog.math.Long} other The Long with which to OR.\n * @return {!goog.math.Long} The bitwise-OR of this and the other.\n */\ngoog.math.Long.prototype.or = function(other) {\n  return goog.math.Long.fromBits(this.low_ | other.low_,\n                                 this.high_ | other.high_);\n};\n\n\n/**\n * Returns the bitwise-XOR of this Long and the given one.\n * @param {goog.math.Long} other The Long with which to XOR.\n * @return {!goog.math.Long} The bitwise-XOR of this and the other.\n */\ngoog.math.Long.prototype.xor = function(other) {\n  return goog.math.Long.fromBits(this.low_ ^ other.low_,\n                                 this.high_ ^ other.high_);\n};\n\n\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!goog.math.Long} This shifted to the left by the given amount.\n */\ngoog.math.Long.prototype.shiftLeft = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var low = this.low_;\n    if (numBits < 32) {\n      var high = this.high_;\n      return goog.math.Long.fromBits(\n          low << numBits,\n          (high << numBits) | (low >>> (32 - numBits)));\n    } else {\n      return goog.math.Long.fromBits(0, low << (numBits - 32));\n    }\n  }\n};\n\n\n/**\n * Returns this Long with bits shifted to the right by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!goog.math.Long} This shifted to the right by the given amount.\n */\ngoog.math.Long.prototype.shiftRight = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return goog.math.Long.fromBits(\n          (low >>> numBits) | (high << (32 - numBits)),\n          high >> numBits);\n    } else {\n      return goog.math.Long.fromBits(\n          high >> (numBits - 32),\n          high >= 0 ? 0 : -1);\n    }\n  }\n};\n\n\n/**\n * Returns this Long with bits shifted to the right by the given amount, with\n * the new top bits matching the current sign bit.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!goog.math.Long} This shifted to the right by the given amount, with\n *     zeros placed into the new leading bits.\n */\ngoog.math.Long.prototype.shiftRightUnsigned = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return goog.math.Long.fromBits(\n          (low >>> numBits) | (high << (32 - numBits)),\n          high >>> numBits);\n    } else if (numBits == 32) {\n      return goog.math.Long.fromBits(high, 0);\n    } else {\n      return goog.math.Long.fromBits(high >>> (numBits - 32), 0);\n    }\n  }\n};\n","/*\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * author Digital Primates\n * copyright dash-if 2012\n */ \n if(typeof(utils) == \"undefined\"){\n \tvar utils = {};\n }\n \n if(typeof(utils.Math) == \"undefined\"){\n \tutils.Math = {};\n }\n \n utils.Math.to64BitNumber = function(low, high) {\n\tvar highNum, lowNum, expected;\n\n\thighNum = new goog.math.Long(0, high);\n\tlowNum = new goog.math.Long(low, 0);\n\texpected = highNum.add(lowNum);\n\n\treturn expected.toNumber();\n}","/*\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * author Digital Primates\n * copyright dash-if 2012\n */\n\n/*\n * var parent,\n *     child,\n *     properties = [\n                    {\n                        name: 'profiles',\n                        merge: false\n                    }\n                ];\n *\n * parent = {};\n * parent.name = \"ParentNode\";\n * parent.isRoor = false;\n * parent.isArray = false;\n * parent.parent = null;\n * parent.children = [];\n * parent.properties = properties;\n *\n * child = {};\n * child.name = \"ChildNode\";\n * child.isRoor = false;\n * child.isArray = true;\n * child.parent = parent;\n * child.children = null;\n * child.properties = properties;\n * parent.children.push(child);\n *\n */\n\nfunction ObjectIron(map) {\n\n    var lookup;\n\n    // create a list of top level items to search for\n    lookup = [];\n    for (i = 0, len = map.length; i < len; i += 1) {\n        if (map[i].isRoot) {\n            lookup.push(\"root\");\n        } else {\n            lookup.push(map[i].name);\n        }\n    }\n\n    var mergeValues = function (parentItem, childItem) {\n            var name,\n                parentValue,\n                childValue;\n\n            if (parentItem === null || childItem === null) {\n                return;\n            }\n\n            for (name in parentItem) {\n                if (parentItem.hasOwnProperty(name)) {\n                    if (!childItem.hasOwnProperty(name)) {\n                        childItem[name] = parentItem[name];\n                    }\n                }\n            }\n        },\n\n        mapProperties = function (properties, parent, child) {\n            var i,\n                len,\n                property,\n                parentValue,\n                childValue;\n\n            if (properties === null || properties.length === 0) {\n                return;\n            }\n\n            for (i = 0, len = properties.length; i < len; i += 1) {\n                property = properties[i];\n\n                if (parent.hasOwnProperty(property.name)) {\n                    if (child.hasOwnProperty(property.name)) {\n                        // check to see if we should merge\n                        if (property.merge) {\n                           parentValue = parent[property.name];\n                           childValue = child[property.name];\n\n                            // complex objects; merge properties\n                            if (typeof parentValue === 'object' && typeof childValue === 'object') {\n                                mergeValues(parentValue, childValue);\n                            }\n                            // simple objects; merge them together\n                            else {\n                                if (property.mergeFunction != null) {\n                                    child[property.name] = property.mergeFunction(parentValue, childValue);\n                                } else {\n                                    child[property.name] = parentValue + childValue;\n                                }\n                            }\n                        }\n                    } else {\n                        // just add the property\n                        child[property.name] = parent[property.name];\n                    }\n                }\n            }\n        },\n\n        mapItem = function (obj, node) {\n            var item = obj,\n                i,\n                len,\n                v,\n                len2,\n                array,\n                childItem,\n                childNode,\n                property;\n\n            if (item.children === null || item.children.length === 0) {\n                return;\n            }\n\n            for (i = 0, len = item.children.length; i < len; i += 1) {\n                childItem = item.children[i];\n\n                if (node.hasOwnProperty(childItem.name)) {\n                    if (childItem.isArray) {\n                        array = node[childItem.name + \"_asArray\"];\n                        for (v = 0, len2 = array.length; v < len2; v += 1) {\n                            childNode = array[v];\n                            mapProperties(item.properties, node, childNode);\n                            mapItem(childItem, childNode);\n                        }\n                    } else {\n                        childNode = node[childItem.name];\n                        mapProperties(item.properties, node, childNode);\n                        mapItem(childItem, childNode);\n                    }\n                }\n            }\n        },\n\n        performMapping = function (source) {\n            var i,\n                len,\n                pi,\n                pp,\n                item,\n                node,\n                array;\n\n            if (source === null) {\n                return source;\n            }\n\n            if (typeof source !== 'object') {\n                return source;\n            }\n\n            // first look to see if anything cares about the root node\n            for (i = 0, len = lookup.length; i < len; i += 1) {\n                if (lookup[i] === \"root\") {\n                    item = map[i];\n                    node = source;\n                    mapItem(item, node);\n                }\n            }\n\n            // iterate over the objects and look for any of the items we care about\n            for (pp in source) {\n                if (source.hasOwnProperty(pp)) {\n                    pi = lookup.indexOf(pp);\n                    if (pi !== -1) {\n                        item = map[pi];\n\n                        if (item.isArray) {\n                            array = source[pp + \"_asArray\"];\n                            for (i = 0, len = array.length; i < len; i += 1) {\n                                node = array[i];\n                                mapItem(item, node);\n                            }\n                        } else {\n                            node = source[pp];\n                            mapItem(item, node);\n                        }\n                    }\n                    // now check this to see if he has any of the properties we care about\n                    performMapping(source[pp]);\n                }\n            }\n\n            return source;\n        };\n\n    return {\n        run: performMapping\n    };\n}","// vim:ts=4:sts=4:sw=4:\n/*!\n *\n * Copyright 2009-2012 Kris Kowal under the terms of the MIT\n * license found at http://github.com/kriskowal/q/raw/master/LICENSE\n *\n * With parts by Tyler Close\n * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found\n * at http://www.opensource.org/licenses/mit-license.html\n * Forked at ref_send.js version: 2009-05-11\n *\n * With parts by Mark Miller\n * Copyright (C) 2011 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n(function (definition) {\n    // Turn off strict mode for this function so we can assign to global.Q\n    /*jshint strict: false*/\n    Q = definition();\n})(function () {\n\"use strict\";\n\n// All code after this point will be filtered from stack traces reported\n// by Q.\nvar qStartingLine = captureLine();\nvar qFileName;\n\n// shims\n\n// used for fallback in \"allResolved\"\nvar noop = function () {};\n\n// use the fastest possible means to execute a task in a future turn\n// of the event loop.\nvar nextTick;\nif (typeof process !== \"undefined\") {\n    // node\n    nextTick = process.nextTick;\n} else if (typeof setImmediate === \"function\") {\n    // In IE10, or use https://github.com/NobleJS/setImmediate\n    if (typeof window !== \"undefined\") {\n        nextTick = setImmediate.bind(window);\n    } else {\n        nextTick = setImmediate;\n    }\n} else {\n    (function () {\n        // linked list of tasks (single, with head node)\n        var head = {task: void 0, next: null}, tail = head,\n            maxPendingTicks = 2, pendingTicks = 0, queuedTasks = 0, usedTicks = 0,\n            requestTick;\n\n        function onTick() {\n            // In case of multiple tasks ensure at least one subsequent tick\n            // to handle remaining tasks in case one throws.\n            --pendingTicks;\n\n            if (++usedTicks >= maxPendingTicks) {\n                // Amortize latency after thrown exceptions.\n                usedTicks = 0;\n                maxPendingTicks *= 4; // fast grow!\n                var expectedTicks = queuedTasks && Math.min(queuedTasks - 1, maxPendingTicks);\n                while (pendingTicks < expectedTicks) {\n                    ++pendingTicks;\n                    requestTick();\n                }\n            }\n\n            while (queuedTasks) {\n                --queuedTasks; // decrement here to ensure it's never negative\n                head = head.next;\n                var task = head.task;\n                head.task = void 0;\n                task();\n            }\n\n            usedTicks = 0;\n        }\n\n        nextTick = function (task) {\n            tail = tail.next = {task: task, next: null};\n            if (pendingTicks < ++queuedTasks && pendingTicks < maxPendingTicks) {\n                ++pendingTicks;\n                requestTick();\n            }\n        };\n\n        if (typeof MessageChannel !== \"undefined\") {\n            // modern browsers\n            // http://www.nonblocking.io/2011/06/windownexttick.html\n            var channel = new MessageChannel();\n            channel.port1.onmessage = onTick;\n            requestTick = function () {\n                channel.port2.postMessage(0);\n            };\n\n        } else {\n            // old browsers\n            requestTick = function () {\n                setTimeout(onTick, 0);\n            };\n        }\n    })();\n}\n\n// Attempt to make generics safe in the face of downstream\n// modifications.\n// There is no situation where this is necessary.\n// If you need a security guarantee, these primordials need to be\n// deeply frozen anyway, and if you dont need a security guarantee,\n// this is just plain paranoid.\n// However, this does have the nice side-effect of reducing the size\n// of the code by reducing x.call() to merely x(), eliminating many\n// hard-to-minify characters.\n// See Mark Millers explanation of what this does.\n// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming\nfunction uncurryThis(f) {\n    var call = Function.call;\n    return function () {\n        return call.apply(f, arguments);\n    };\n}\n// This is equivalent, but slower:\n// uncurryThis = Function_bind.bind(Function_bind.call);\n// http://jsperf.com/uncurrythis\n\nvar array_slice = uncurryThis(Array.prototype.slice);\n\nvar array_reduce = uncurryThis(\n    Array.prototype.reduce || function (callback, basis) {\n        var index = 0,\n            length = this.length;\n        // concerning the initial value, if one is not provided\n        if (arguments.length === 1) {\n            // seek to the first value in the array, accounting\n            // for the possibility that is is a sparse array\n            do {\n                if (index in this) {\n                    basis = this[index++];\n                    break;\n                }\n                if (++index >= length) {\n                    throw new TypeError();\n                }\n            } while (1);\n        }\n        // reduce\n        for (; index < length; index++) {\n            // account for the possibility that the array is sparse\n            if (index in this) {\n                basis = callback(basis, this[index], index);\n            }\n        }\n        return basis;\n    }\n);\n\nvar array_indexOf = uncurryThis(\n    Array.prototype.indexOf || function (value) {\n        // not a very good shim, but good enough for our one use of it\n        for (var i = 0; i < this.length; i++) {\n            if (this[i] === value) {\n                return i;\n            }\n        }\n        return -1;\n    }\n);\n\nvar array_map = uncurryThis(\n    Array.prototype.map || function (callback, thisp) {\n        var self = this;\n        var collect = [];\n        array_reduce(self, function (undefined, value, index) {\n            collect.push(callback.call(thisp, value, index, self));\n        }, void 0);\n        return collect;\n    }\n);\n\nvar object_create = Object.create || function (prototype) {\n    function Type() { }\n    Type.prototype = prototype;\n    return new Type();\n};\n\nvar object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);\n\nvar object_keys = Object.keys || function (object) {\n    var keys = [];\n    for (var key in object) {\n        if (object_hasOwnProperty(object, key)) {\n            keys.push(key);\n        }\n    }\n    return keys;\n};\n\nvar object_toString = uncurryThis(Object.prototype.toString);\n\n// generator related shims\n\nfunction isStopIteration(exception) {\n    return (\n        object_toString(exception) === \"[object StopIteration]\" ||\n        exception instanceof QReturnValue\n    );\n}\n\nvar QReturnValue;\nif (typeof ReturnValue !== \"undefined\") {\n    QReturnValue = ReturnValue;\n} else {\n    QReturnValue = function (value) {\n        this.value = value;\n    };\n}\n\n// long stack traces\n\nQ.longStackJumpLimit = 1;\n\nvar STACK_JUMP_SEPARATOR = \"From previous event:\";\n\nfunction makeStackTraceLong(error, promise) {\n    // If possible (that is, if in V8), transform the error stack\n    // trace by removing Node and Q cruft, then concatenating with\n    // the stack trace of the promise we are ``done``ing. See #57.\n    if (promise.stack &&\n        typeof error === \"object\" &&\n        error !== null &&\n        error.stack &&\n        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1\n    ) {\n        error.stack = filterStackString(error.stack) +\n            \"\\n\" + STACK_JUMP_SEPARATOR + \"\\n\" +\n            filterStackString(promise.stack);\n    }\n}\n\nfunction filterStackString(stackString) {\n    var lines = stackString.split(\"\\n\");\n    var desiredLines = [];\n    for (var i = 0; i < lines.length; ++i) {\n        var line = lines[i];\n\n        if (!isInternalFrame(line) && !isNodeFrame(line)) {\n            desiredLines.push(line);\n        }\n    }\n    return desiredLines.join(\"\\n\");\n}\n\nfunction isNodeFrame(stackLine) {\n    return stackLine.indexOf(\"(module.js:\") !== -1 ||\n           stackLine.indexOf(\"(node.js:\") !== -1;\n}\n\nfunction isInternalFrame(stackLine) {\n    var pieces = /at .+ \\((.*):(\\d+):\\d+\\)/.exec(stackLine);\n\n    if (!pieces) {\n        return false;\n    }\n\n    var fileName = pieces[1];\n    var lineNumber = pieces[2];\n\n    return fileName === qFileName &&\n        lineNumber >= qStartingLine &&\n        lineNumber <= qEndingLine;\n}\n\n// discover own file name and line number range for filtering stack\n// traces\nfunction captureLine() {\n    if (Error.captureStackTrace) {\n        var fileName, lineNumber;\n\n        var oldPrepareStackTrace = Error.prepareStackTrace;\n\n        Error.prepareStackTrace = function (error, frames) {\n            fileName = frames[1].getFileName();\n            lineNumber = frames[1].getLineNumber();\n        };\n\n        // teases call of temporary prepareStackTrace\n        // JSHint and Closure Compiler generate known warnings here\n        /*jshint expr: true */\n        new Error().stack;\n\n        Error.prepareStackTrace = oldPrepareStackTrace;\n        qFileName = fileName;\n        return lineNumber;\n    }\n}\n\nfunction deprecate(callback, name, alternative) {\n    return function () {\n        if (typeof console !== \"undefined\" && typeof console.warn === \"function\") {\n            console.warn(name + \" is deprecated, use \" + alternative + \" instead.\", new Error(\"\").stack);\n        }\n        return callback.apply(callback, arguments);\n    };\n}\n\n// end of shims\n// beginning of real work\n\n/**\n * Creates fulfilled promises from non-promises,\n * Passes Q promises through,\n * Coerces CommonJS/Promises/A+ promises to Q promises.\n */\nfunction Q(value) {\n    return resolve(value);\n}\n\n/**\n * Performs a task in a future turn of the event loop.\n * @param {Function} task\n */\nQ.nextTick = nextTick;\n\n/**\n * Constructs a {promise, resolve} object.\n *\n * The resolver is a callback to invoke with a more resolved value for the\n * promise. To fulfill the promise, invoke the resolver with any value that is\n * not a function. To reject the promise, invoke the resolver with a rejection\n * object. To put the promise in the same state as another promise, invoke the\n * resolver with that other promise.\n */\nQ.defer = defer;\nfunction defer() {\n    // if \"pending\" is an \"Array\", that indicates that the promise has not yet\n    // been resolved.  If it is \"undefined\", it has been resolved.  Each\n    // element of the pending array is itself an array of complete arguments to\n    // forward to the resolved promise.  We coerce the resolution value to a\n    // promise using the ref promise because it handles both fully\n    // resolved values and other promises gracefully.\n    var pending = [], progressListeners = [], value;\n\n    var deferred = object_create(defer.prototype);\n    var promise = object_create(makePromise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, operands) {\n        var args = array_slice(arguments);\n        if (pending) {\n            pending.push(args);\n            if (op === \"when\" && operands[1]) { // progress operand\n                progressListeners.push(operands[1]);\n            }\n        } else {\n            nextTick(function () {\n                value.promiseDispatch.apply(value, args);\n            });\n        }\n    };\n\n    promise.valueOf = function () {\n        if (pending) {\n            return promise;\n        }\n        value = valueOf(value); // shorten chain\n        return value;\n    };\n\n    if (Error.captureStackTrace && Q.longStackJumpLimit > 0) {\n        Error.captureStackTrace(promise, defer);\n\n        // Reify the stack into a string by using the accessor; this prevents\n        // memory leaks as per GH-111. At the same time, cut off the first line;\n        // it's always just \"[object Promise]\\n\", as per the `toString`.\n        promise.stack = promise.stack.substring(promise.stack.indexOf(\"\\n\") + 1);\n    }\n\n    function become(resolvedValue) {\n        if (!pending) {\n            return;\n        }\n        value = resolve(resolvedValue);\n        array_reduce(pending, function (undefined, pending) {\n            nextTick(function () {\n                value.promiseDispatch.apply(value, pending);\n            });\n        }, void 0);\n        pending = void 0;\n        progressListeners = void 0;\n    }\n\n    deferred.promise = promise;\n    deferred.resolve = become;\n    deferred.fulfill = function (value) {\n        become(fulfill(value));\n    };\n    deferred.reject = function (exception) {\n        become(reject(exception));\n    };\n    deferred.notify = function (progress) {\n        if (pending) {\n            array_reduce(progressListeners, function (undefined, progressListener) {\n                nextTick(function () {\n                    progressListener(progress);\n                });\n            }, void 0);\n        }\n    };\n\n    return deferred;\n}\n\n/**\n * Creates a Node-style callback that will resolve or reject the deferred\n * promise.\n * @returns a nodeback\n */\ndefer.prototype.makeNodeResolver = function () {\n    var self = this;\n    return function (error, value) {\n        if (error) {\n            self.reject(error);\n        } else if (arguments.length > 2) {\n            self.resolve(array_slice(arguments, 1));\n        } else {\n            self.resolve(value);\n        }\n    };\n};\n\n/**\n * @param makePromise {Function} a function that returns nothing and accepts\n * the resolve, reject, and notify functions for a deferred.\n * @returns a promise that may be resolved with the given resolve and reject\n * functions, or rejected by a thrown exception in makePromise\n */\nQ.promise = promise;\nfunction promise(makePromise) {\n    var deferred = defer();\n    fcall(\n        makePromise,\n        deferred.resolve,\n        deferred.reject,\n        deferred.notify\n    ).fail(deferred.reject);\n    return deferred.promise;\n}\n\n/**\n * Constructs a Promise with a promise descriptor object and optional fallback\n * function.  The descriptor contains methods like when(rejected), get(name),\n * put(name, value), post(name, args), and delete(name), which all\n * return either a value, a promise for a value, or a rejection.  The fallback\n * accepts the operation name, a resolver, and any further arguments that would\n * have been forwarded to the appropriate method above had a method been\n * provided with the proper name.  The API makes no guarantees about the nature\n * of the returned object, apart from that it is usable whereever promises are\n * bought and sold.\n */\nQ.makePromise = makePromise;\nfunction makePromise(descriptor, fallback, valueOf, exception, isException) {\n    if (fallback === void 0) {\n        fallback = function (op) {\n            return reject(new Error(\"Promise does not support operation: \" + op));\n        };\n    }\n\n    var promise = object_create(makePromise.prototype);\n\n    promise.promiseDispatch = function (resolve, op, args) {\n        var result;\n        try {\n            if (descriptor[op]) {\n                result = descriptor[op].apply(promise, args);\n            } else {\n                result = fallback.call(promise, op, args);\n            }\n        } catch (exception) {\n            result = reject(exception);\n        }\n        if (resolve) {\n            resolve(result);\n        }\n    };\n\n    if (valueOf) {\n        promise.valueOf = valueOf;\n    }\n\n    if (isException) {\n        promise.exception = exception;\n    }\n\n    return promise;\n}\n\n// provide thenables, CommonJS/Promises/A\nmakePromise.prototype.then = function (fulfilled, rejected, progressed) {\n    return when(this, fulfilled, rejected, progressed);\n};\n\nmakePromise.prototype.thenResolve = function (value) {\n    return when(this, function () { return value; });\n};\n\n// Chainable methods\narray_reduce(\n    [\n        \"isFulfilled\", \"isRejected\", \"isPending\",\n        \"dispatch\",\n        \"when\", \"spread\",\n        \"get\", \"put\", \"set\", \"del\", \"delete\",\n        \"post\", \"send\", \"invoke\",\n        \"keys\",\n        \"fapply\", \"fcall\", \"fbind\",\n        \"all\", \"allResolved\",\n        \"timeout\", \"delay\",\n        \"catch\", \"finally\", \"fail\", \"fin\", \"progress\", \"done\",\n        \"nfcall\", \"nfapply\", \"nfbind\", \"denodeify\", \"nbind\",\n        \"ncall\", \"napply\", \"nbind\",\n        \"npost\", \"nsend\", \"ninvoke\",\n        \"nodeify\"\n    ],\n    function (undefined, name) {\n        makePromise.prototype[name] = function () {\n            return Q[name].apply(\n                Q,\n                [this].concat(array_slice(arguments))\n            );\n        };\n    },\n    void 0\n);\n\nmakePromise.prototype.toSource = function () {\n    return this.toString();\n};\n\nmakePromise.prototype.toString = function () {\n    return \"[object Promise]\";\n};\n\n/**\n * If an object is not a promise, it is as \"near\" as possible.\n * If a promise is rejected, it is as \"near\" as possible too.\n * If its a fulfilled promise, the fulfillment value is nearer.\n * If its a deferred promise and the deferred has been resolved, the\n * resolution is \"nearer\".\n * @param object\n * @returns most resolved (nearest) form of the object\n */\nQ.nearer = valueOf;\nfunction valueOf(value) {\n    if (isPromise(value)) {\n        return value.valueOf();\n    }\n    return value;\n}\n\n/**\n * @returns whether the given object is a promise.\n * Otherwise it is a fulfilled value.\n */\nQ.isPromise = isPromise;\nfunction isPromise(object) {\n    return object && typeof object.promiseDispatch === \"function\";\n}\n\nQ.isPromiseAlike = isPromiseAlike;\nfunction isPromiseAlike(object) {\n    return object && typeof object.then === \"function\";\n}\n\n/**\n * @returns whether the given object is a pending promise, meaning not\n * fulfilled or rejected.\n */\nQ.isPending = isPending;\nfunction isPending(object) {\n    return !isFulfilled(object) && !isRejected(object);\n}\n\n/**\n * @returns whether the given object is a value or fulfilled\n * promise.\n */\nQ.isFulfilled = isFulfilled;\nfunction isFulfilled(object) {\n    return !isPromiseAlike(valueOf(object));\n}\n\n/**\n * @returns whether the given object is a rejected promise.\n */\nQ.isRejected = isRejected;\nfunction isRejected(object) {\n    object = valueOf(object);\n    return isPromise(object) && 'exception' in object;\n}\n\nvar rejections = [];\nvar errors = [];\nvar errorsDisplayed;\nfunction displayErrors() {\n    \n    /* \n      HACK MGA :  remove !window.Touch in the condition\n      because window.Touch is defined in Chrome, so errors are never displayed... \n    */\n\n    if (\n        !errorsDisplayed &&\n        typeof window !== \"undefined\" &&\n        window.console\n    ) {\n        // This promise library consumes exceptions thrown in handlers so\n        // they can be handled by a subsequent promise.  The rejected\n        // promises get added to this array when they are created, and\n        // removed when they are handled.\n\n        //HACK MGA : change log level (log to error)\n        console.error(\"Should be empty:\", errors);\n    }\n    // HACK MGA : remove this affectation to display ALL errors\n    // errorsDisplayed = true;\n}\n\n// Show unhandled rejection if Node exits without handling an outstanding\n// rejection.  (Note that Browserify presently produces a process global\n// without the Emitter on interface)\nif (typeof process !== \"undefined\" && process.on) {\n    process.on(\"exit\", function () {\n        for (var i = 0; i < errors.length; i++) {\n            var error = errors[i];\n            if (error && typeof error.stack !== \"undefined\") {\n                console.warn(\"Unhandled rejected promise:\", error.stack);\n            } else {\n                console.warn(\"Unhandled rejected promise (no stack):\", error);\n            }\n        }\n    });\n}\n\n/**\n * Constructs a rejected promise.\n * @param exception value describing the failure\n */\nQ.reject = reject;\nfunction reject(exception) {\n    var rejection = makePromise({\n        \"when\": function (rejected) {\n            // note that the error has been handled\n            if (rejected) {\n                var at = array_indexOf(rejections, this);\n                if (at !== -1) {\n                    errors.splice(at, 1);\n                    rejections.splice(at, 1);\n                }\n            }\n            return rejected ? rejected(exception) : this;\n        }\n    }, function fallback() {\n        return reject(exception);\n    }, function valueOf() {\n        return this;\n    }, exception, true);\n    rejections.push(rejection);\n    errors.push(exception);\n    // note that the error has not been handled\n    // HACK MGA : change call order because in disaplyErrors, we use errors...\n    //displayErrors();\n    return rejection;\n}\n\n/**\n * Constructs a fulfilled promise for an immediate reference.\n * @param value immediate reference\n */\nQ.fulfill = fulfill;\nfunction fulfill(object) {\n    return makePromise({\n        \"when\": function () {\n            return object;\n        },\n        \"get\": function (name) {\n            return object[name];\n        },\n        \"set\": function (name, value) {\n            object[name] = value;\n        },\n        \"delete\": function (name) {\n            delete object[name];\n        },\n        \"post\": function (name, args) {\n            // Mark Miller proposes that post with no name should apply a\n            // promised function.\n            if (name == null) { // iff name is null or undefined\n                return object.apply(void 0, args);\n            } else {\n                return object[name].apply(object, args);\n            }\n        },\n        \"apply\": function (thisP, args) {\n            return object.apply(thisP, args);\n        },\n        \"keys\": function () {\n            return object_keys(object);\n        }\n    }, void 0, function valueOf() {\n        return object;\n    });\n}\n\n/**\n * Constructs a promise for an immediate reference, passes promises through, or\n * coerces promises from different systems.\n * @param value immediate reference or promise\n */\nQ.resolve = resolve;\nfunction resolve(value) {\n    // If the object is already a Promise, return it directly.  This enables\n    // the resolve function to both be used to created references from objects,\n    // but to tolerably coerce non-promises to promises.\n    if (isPromise(value)) {\n        return value;\n    }\n    // In order to break infinite recursion or loops between `then` and\n    // `resolve`, it is necessary to attempt to extract fulfilled values\n    // out of foreign promise implementations before attempting to wrap\n    // them as unresolved promises.  It is my hope that other\n    // implementations will implement `valueOf` to synchronously extract\n    // the fulfillment value from their fulfilled promises.  If the\n    // other promise library does not implement `valueOf`, the\n    // implementations on primordial prototypes are harmless.\n    value = valueOf(value);\n    // assimilate thenables, CommonJS/Promises/A+\n    if (isPromiseAlike(value)) {\n        return coerce(value);\n    } else {\n        return fulfill(value);\n    }\n}\n\n/**\n * Converts thenables to Q promises.\n * @param promise thenable promise\n * @returns a Q promise\n */\nfunction coerce(promise) {\n    var deferred = defer();\n    nextTick(function () {\n        try {\n            promise.then(deferred.resolve, deferred.reject, deferred.notify);\n        } catch (exception) {\n            deferred.reject(exception);\n        }\n    });\n    return deferred.promise;\n}\n\n/**\n * Annotates an object such that it will never be\n * transferred away from this process over any promise\n * communication channel.\n * @param object\n * @returns promise a wrapping of that object that\n * additionally responds to the \"isDef\" message\n * without a rejection.\n */\nQ.master = master;\nfunction master(object) {\n    return makePromise({\n        \"isDef\": function () {}\n    }, function fallback(op, args) {\n        return dispatch(object, op, args);\n    }, function () {\n        return valueOf(object);\n    });\n}\n\n/**\n * Registers an observer on a promise.\n *\n * Guarantees:\n *\n * 1. that fulfilled and rejected will be called only once.\n * 2. that either the fulfilled callback or the rejected callback will be\n *    called, but not both.\n * 3. that fulfilled and rejected will not be called in this turn.\n *\n * @param value      promise or immediate reference to observe\n * @param fulfilled  function to be called with the fulfilled value\n * @param rejected   function to be called with the rejection exception\n * @param progressed function to be called on any progress notifications\n * @return promise for the return value from the invoked callback\n */\nQ.when = when;\nfunction when(value, fulfilled, rejected, progressed) {\n    var deferred = defer();\n    var done = false;   // ensure the untrusted promise makes at most a\n                        // single call to one of the callbacks\n\n    function _fulfilled(value) {\n        try {\n            return typeof fulfilled === \"function\" ? fulfilled(value) : value;\n        } catch (exception) {\n            return reject(exception);\n        }\n    }\n\n    function _rejected(exception) {\n        if (typeof rejected === \"function\") {\n            makeStackTraceLong(exception, resolvedValue);\n            try {\n                return rejected(exception);\n            } catch (newException) {\n                return reject(newException);\n            }\n        }\n        return reject(exception);\n    }\n\n    function _progressed(value) {\n        return typeof progressed === \"function\" ? progressed(value) : value;\n    }\n\n    var resolvedValue = resolve(value);\n    nextTick(function () {\n        resolvedValue.promiseDispatch(function (value) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_fulfilled(value));\n        }, \"when\", [function (exception) {\n            if (done) {\n                return;\n            }\n            done = true;\n\n            deferred.resolve(_rejected(exception));\n        }]);\n    });\n\n    // Progress propagator need to be attached in the current tick.\n    resolvedValue.promiseDispatch(void 0, \"when\", [void 0, function (value) {\n        var newValue;\n        var threw = false;\n        try {\n            newValue = _progressed(value);\n        } catch (e) {\n            threw = true;\n            if (Q.onerror) {\n                Q.onerror(e);\n            } else {\n                throw e;\n            }\n        }\n\n        if (!threw) {\n            deferred.notify(newValue);\n        }\n    }]);\n\n    return deferred.promise;\n}\n\n/**\n * Spreads the values of a promised array of arguments into the\n * fulfillment callback.\n * @param fulfilled callback that receives variadic arguments from the\n * promised array\n * @param rejected callback that receives the exception if the promise\n * is rejected.\n * @returns a promise for the return value or thrown exception of\n * either callback.\n */\nQ.spread = spread;\nfunction spread(promise, fulfilled, rejected) {\n    return when(promise, function (valuesOrPromises) {\n        return all(valuesOrPromises).then(function (values) {\n            return fulfilled.apply(void 0, values);\n        }, rejected);\n    }, rejected);\n}\n\n/**\n * The async function is a decorator for generator functions, turning\n * them into asynchronous generators.  This presently only works in\n * Firefox/Spidermonkey, however, this code does not cause syntax\n * errors in older engines.  This code should continue to work and\n * will in fact improve over time as the language improves.\n *\n * Decorates a generator function such that:\n *  - it may yield promises\n *  - execution will continue when that promise is fulfilled\n *  - the value of the yield expression will be the fulfilled value\n *  - it returns a promise for the return value (when the generator\n *    stops iterating)\n *  - the decorated function returns a promise for the return value\n *    of the generator or the first rejected promise among those\n *    yielded.\n *  - if an error is thrown in the generator, it propagates through\n *    every following yield until it is caught, or until it escapes\n *    the generator function altogether, and is translated into a\n *    rejection for the promise returned by the decorated generator.\n *  - in present implementations of generators, when a generator\n *    function is complete, it throws ``StopIteration``, ``return`` is\n *    a syntax error in the presence of ``yield``, so there is no\n *    observable return value. There is a proposal[1] to add support\n *    for ``return``, which would permit the value to be carried by a\n *    ``StopIteration`` instance, in which case it would fulfill the\n *    promise returned by the asynchronous generator.  This can be\n *    emulated today by throwing StopIteration explicitly with a value\n *    property.\n *\n *  [1]: http://wiki.ecmascript.org/doku.php?id=strawman:async_functions#reference_implementation\n *\n */\nQ.async = async;\nfunction async(makeGenerator) {\n    return function () {\n        // when verb is \"send\", arg is a value\n        // when verb is \"throw\", arg is an exception\n        function continuer(verb, arg) {\n            var result;\n            try {\n                result = generator[verb](arg);\n            } catch (exception) {\n                if (isStopIteration(exception)) {\n                    return exception.value;\n                } else {\n                    return reject(exception);\n                }\n            }\n            return when(result, callback, errback);\n        }\n        var generator = makeGenerator.apply(this, arguments);\n        var callback = continuer.bind(continuer, \"send\");\n        var errback = continuer.bind(continuer, \"throw\");\n        return callback();\n    };\n}\n\n/**\n * Throws a ReturnValue exception to stop an asynchronous generator.\n * Only useful presently in Firefox/SpiderMonkey since generators are\n * implemented.\n * @param value the return value for the surrounding generator\n * @throws ReturnValue exception with the value.\n * @example\n * Q.async(function () {\n *      var foo = yield getFooPromise();\n *      var bar = yield getBarPromise();\n *      Q.return(foo + bar);\n * })\n */\nQ['return'] = _return;\nfunction _return(value) {\n    throw new QReturnValue(value);\n}\n\n/**\n * The promised function decorator ensures that any promise arguments\n * are resolved and passed as values (`this` is also resolved and passed\n * as a value).  It will also ensure that the result of a function is\n * always a promise.\n *\n * @example\n * var add = Q.promised(function (a, b) {\n *     return a + b;\n * });\n * add(Q.resolve(a), Q.resolve(B));\n *\n * @param {function} callback The function to decorate\n * @returns {function} a function that has been decorated.\n */\nQ.promised = promised;\nfunction promised(callback) {\n    return function () {\n        return spread([this, all(arguments)], function (self, args) {\n            return callback.apply(self, args);\n        });\n    };\n}\n\n/**\n * sends a message to a value in a future turn\n * @param object* the recipient\n * @param op the name of the message operation, e.g., \"when\",\n * @param args further arguments to be forwarded to the operation\n * @returns result {Promise} a promise for the result of the operation\n */\nQ.dispatch = dispatch;\nfunction dispatch(object, op, args) {\n    var deferred = defer();\n    nextTick(function () {\n        resolve(object).promiseDispatch(deferred.resolve, op, args);\n    });\n    return deferred.promise;\n}\n\n/**\n * Constructs a promise method that can be used to safely observe resolution of\n * a promise for an arbitrarily named method like \"propfind\" in a future turn.\n *\n * \"dispatcher\" constructs methods like \"get(promise, name)\" and \"put(promise)\".\n */\nQ.dispatcher = dispatcher;\nfunction dispatcher(op) {\n    return function (object) {\n        var args = array_slice(arguments, 1);\n        return dispatch(object, op, args);\n    };\n}\n\n/**\n * Gets the value of a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to get\n * @return promise for the property value\n */\nQ.get = dispatcher(\"get\");\n\n/**\n * Sets the value of a property in a future turn.\n * @param object    promise or immediate reference for object object\n * @param name      name of property to set\n * @param value     new value of property\n * @return promise for the return value\n */\nQ.set = dispatcher(\"set\");\n\n/**\n * Deletes a property in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of property to delete\n * @return promise for the return value\n */\nQ[\"delete\"] = // XXX experimental\nQ.del = dispatcher(\"delete\");\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param value     a value to post, typically an array of\n *                  invocation arguments for promises that\n *                  are ultimately backed with `resolve` values,\n *                  as opposed to those backed with URLs\n *                  wherein the posted value can be any\n *                  JSON serializable object.\n * @return promise for the return value\n */\n// bound locally because it is used by other methods\nvar post = Q.post = dispatcher(\"post\");\n\n/**\n * Invokes a method in a future turn.\n * @param object    promise or immediate reference for target object\n * @param name      name of method to invoke\n * @param ...args   array of invocation arguments\n * @return promise for the return value\n */\nQ.send = send;\nQ.invoke = send; // synonyms\nfunction send(value, name) {\n    var args = array_slice(arguments, 2);\n    return post(value, name, args);\n}\n\n/**\n * Applies the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param args      array of application arguments\n */\nQ.fapply = fapply;\nfunction fapply(value, args) {\n    return dispatch(value, \"apply\", [void 0, args]);\n}\n\n/**\n * Calls the promised function in a future turn.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ[\"try\"] = fcall; // XXX experimental\nQ.fcall = fcall;\nfunction fcall(value) {\n    var args = array_slice(arguments, 1);\n    return fapply(value, args);\n}\n\n/**\n * Binds the promised function, transforming return values into a fulfilled\n * promise and thrown errors into a rejected one.\n * @param object    promise or immediate reference for target function\n * @param ...args   array of application arguments\n */\nQ.fbind = fbind;\nfunction fbind(value) {\n    var args = array_slice(arguments, 1);\n    return function fbound() {\n        var allArgs = args.concat(array_slice(arguments));\n        return dispatch(value, \"apply\", [this, allArgs]);\n    };\n}\n\n/**\n * Requests the names of the owned properties of a promised\n * object in a future turn.\n * @param object    promise or immediate reference for target object\n * @return promise for the keys of the eventually resolved object\n */\nQ.keys = dispatcher(\"keys\");\n\n/**\n * Turns an array of promises into a promise for an array.  If any of\n * the promises gets rejected, the whole array is rejected immediately.\n * @param {Array*} an array (or promise for an array) of values (or\n * promises for values)\n * @returns a promise for an array of the corresponding values\n */\n// By Mark Miller\n// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled\nQ.all = all;\nfunction all(promises) {\n    return when(promises, function (promises) {\n        var countDown = promises.length;\n        if (countDown === 0) {\n            return resolve(promises);\n        }\n        var deferred = defer();\n        array_reduce(promises, function (undefined, promise, index) {\n            if (isFulfilled(promise)) {\n                promises[index] = valueOf(promise);\n                if (--countDown === 0) {\n                    deferred.resolve(promises);\n                }\n            } else {\n                when(promise, function (value) {\n                    promises[index] = value;\n                    if (--countDown === 0) {\n                        deferred.resolve(promises);\n                    }\n                })\n                .fail(deferred.reject);\n            }\n        }, void 0);\n        return deferred.promise;\n    });\n}\n\n/**\n * Waits for all promises to be resolved, either fulfilled or\n * rejected.  This is distinct from `all` since that would stop\n * waiting at the first rejection.  The promise returned by\n * `allResolved` will never be rejected.\n * @param promises a promise for an array (or an array) of promises\n * (or values)\n * @return a promise for an array of promises\n */\nQ.allResolved = allResolved;\nfunction allResolved(promises) {\n    return when(promises, function (promises) {\n        promises = array_map(promises, resolve);\n        return when(all(array_map(promises, function (promise) {\n            return when(promise, noop, noop);\n        })), function () {\n            return promises;\n        });\n    });\n}\n\n/**\n * Captures the failure of a promise, giving an oportunity to recover\n * with a callback.  If the given promise is fulfilled, the returned\n * promise is fulfilled.\n * @param {Any*} promise for something\n * @param {Function} callback to fulfill the returned promise if the\n * given promise is rejected\n * @returns a promise for the return value of the callback\n */\nQ[\"catch\"] = // XXX experimental\nQ.fail = fail;\nfunction fail(promise, rejected) {\n    return when(promise, void 0, rejected);\n}\n\n/**\n * Attaches a listener that can respond to progress notifications from a\n * promise's originating deferred. This listener receives the exact arguments\n * passed to ``deferred.notify``.\n * @param {Any*} promise for something\n * @param {Function} callback to receive any progress notifications\n * @returns the given promise, unchanged\n */\nQ.progress = progress;\nfunction progress(promise, progressed) {\n    return when(promise, void 0, void 0, progressed);\n}\n\n/**\n * Provides an opportunity to observe the rejection of a promise,\n * regardless of whether the promise is fulfilled or rejected.  Forwards\n * the resolution to the returned promise when the callback is done.\n * The callback can return a promise to defer completion.\n * @param {Any*} promise\n * @param {Function} callback to observe the resolution of the given\n * promise, takes no arguments.\n * @returns a promise for the resolution of the given promise when\n * ``fin`` is done.\n */\nQ[\"finally\"] = // XXX experimental\nQ.fin = fin;\nfunction fin(promise, callback) {\n    return when(promise, function (value) {\n        return when(callback(), function () {\n            return value;\n        });\n    }, function (exception) {\n        return when(callback(), function () {\n            return reject(exception);\n        });\n    });\n}\n\n/**\n * Terminates a chain of promises, forcing rejections to be\n * thrown as exceptions.\n * @param {Any*} promise at the end of a chain of promises\n * @returns nothing\n */\nQ.done = done;\nfunction done(promise, fulfilled, rejected, progress) {\n    var onUnhandledError = function (error) {\n        // forward to a future turn so that ``when``\n        // does not catch it and turn it into a rejection.\n        nextTick(function () {\n            makeStackTraceLong(error, promise);\n\n            if (Q.onerror) {\n                Q.onerror(error);\n            } else {\n                throw error;\n            }\n        });\n    };\n\n    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.\n    var promiseToHandle = fulfilled || rejected || progress ?\n        when(promise, fulfilled, rejected, progress) :\n        promise;\n\n    if (typeof process === \"object\" && process && process.domain) {\n        onUnhandledError = process.domain.bind(onUnhandledError);\n    }\n    fail(promiseToHandle, onUnhandledError);\n}\n\n/**\n * Causes a promise to be rejected if it does not get fulfilled before\n * some milliseconds time out.\n * @param {Any*} promise\n * @param {Number} milliseconds timeout\n * @returns a promise for the resolution of the given promise if it is\n * fulfilled before the timeout, otherwise rejected.\n */\nQ.timeout = timeout;\nfunction timeout(promise, ms) {\n    var deferred = defer();\n    var timeoutId = setTimeout(function () {\n        deferred.reject(new Error(\"Timed out after \" + ms + \" ms\"));\n    }, ms);\n\n    when(promise, function (value) {\n        clearTimeout(timeoutId);\n        deferred.resolve(value);\n    }, function (exception) {\n        clearTimeout(timeoutId);\n        deferred.reject(exception);\n    });\n\n    return deferred.promise;\n}\n\n/**\n * Returns a promise for the given value (or promised value) after some\n * milliseconds.\n * @param {Any*} promise\n * @param {Number} milliseconds\n * @returns a promise for the resolution of the given promise after some\n * time has elapsed.\n */\nQ.delay = delay;\nfunction delay(promise, timeout) {\n    if (timeout === void 0) {\n        timeout = promise;\n        promise = void 0;\n    }\n    var deferred = defer();\n    setTimeout(function () {\n        deferred.resolve(promise);\n    }, timeout);\n    return deferred.promise;\n}\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided as an array, and returns a promise.\n *\n *      Q.nfapply(FS.readFile, [__filename])\n *      .then(function (content) {\n *      })\n *\n */\nQ.nfapply = nfapply;\nfunction nfapply(callback, args) {\n    var nodeArgs = array_slice(args);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n\n    fapply(callback, nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n}\n\n/**\n * Passes a continuation to a Node function, which is called with the given\n * arguments provided individually, and returns a promise.\n *\n *      Q.nfcall(FS.readFile, __filename)\n *      .then(function (content) {\n *      })\n *\n */\nQ.nfcall = nfcall;\nfunction nfcall(callback/*, ...args */) {\n    var nodeArgs = array_slice(arguments, 1);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n\n    fapply(callback, nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n}\n\n/**\n * Wraps a NodeJS continuation passing function and returns an equivalent\n * version that returns a promise.\n *\n *      Q.nfbind(FS.readFile, __filename)(\"utf-8\")\n *      .then(console.log)\n *      .done()\n *\n */\nQ.nfbind = nfbind;\nQ.denodeify = Q.nfbind; // synonyms\nfunction nfbind(callback/*, ...args */) {\n    var baseArgs = array_slice(arguments, 1);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n\n        fapply(callback, nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n}\n\nQ.nbind = nbind;\nfunction nbind(callback/*, ... args*/) {\n    var baseArgs = array_slice(arguments, 1);\n    return function () {\n        var nodeArgs = baseArgs.concat(array_slice(arguments));\n        var deferred = defer();\n        nodeArgs.push(deferred.makeNodeResolver());\n\n        var thisArg = this;\n        function bound() {\n            return callback.apply(thisArg, arguments);\n        }\n\n        fapply(bound, nodeArgs).fail(deferred.reject);\n        return deferred.promise;\n    };\n}\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback with a given array of arguments, plus a provided callback.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param {Array} args arguments to pass to the method; the callback\n * will be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.npost = npost;\nfunction npost(object, name, args) {\n    var nodeArgs = array_slice(args || []);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n\n    post(object, name, nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n}\n\n/**\n * Calls a method of a Node-style object that accepts a Node-style\n * callback, forwarding the given variadic arguments, plus a provided\n * callback argument.\n * @param object an object that has the named method\n * @param {String} name name of the method of object\n * @param ...args arguments to pass to the method; the callback will\n * be provided by Q and appended to these arguments.\n * @returns a promise for the value or error\n */\nQ.nsend = nsend;\nQ.ninvoke = Q.nsend; // synonyms\nfunction nsend(object, name /*, ...args*/) {\n    var nodeArgs = array_slice(arguments, 2);\n    var deferred = defer();\n    nodeArgs.push(deferred.makeNodeResolver());\n    post(object, name, nodeArgs).fail(deferred.reject);\n    return deferred.promise;\n}\n\nQ.nodeify = nodeify;\nfunction nodeify(promise, nodeback) {\n    if (nodeback) {\n        promise.then(function (value) {\n            nextTick(function () {\n                nodeback(null, value);\n            });\n        }, function (error) {\n            nextTick(function () {\n                nodeback(error);\n            });\n        });\n    } else {\n        return promise;\n    }\n}\n\n// All code before this point will be filtered from stack traces.\nvar qEndingLine = captureLine();\n\nreturn Q;\n\n});\n","/*\n Copyright 2011 Abdulla Abdurakhmanov\n Original sources are available at https://code.google.com/p/x2js/\n\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n */\n\nfunction X2JS(matchers, attrPrefix, ignoreRoot) {\n    if (attrPrefix === null || attrPrefix === undefined) {\n        attrPrefix = \"_\";\n    }\n    \n    if (ignoreRoot === null || ignoreRoot === undefined) {\n        ignoreRoot = false;\n    }\n    \n\tvar VERSION = \"1.0.11\";\n\tvar escapeMode = false;\n\n\tvar DOMNodeTypes = {\n\t\tELEMENT_NODE \t   : 1,\n\t\tTEXT_NODE    \t   : 3,\n\t\tCDATA_SECTION_NODE : 4,\n\t\tCOMMENT_NODE       : 8,\n\t\tDOCUMENT_NODE \t   : 9\n\t};\n\t\n\tfunction getNodeLocalName( node ) {\n\t\tvar nodeLocalName = node.localName;\t\t\t\n\t\tif(nodeLocalName == null) // Yeah, this is IE!! \n\t\t\tnodeLocalName = node.baseName;\n\t\tif(nodeLocalName == null || nodeLocalName==\"\") // ==\"\" is IE too\n\t\t\tnodeLocalName = node.nodeName;\n\t\treturn nodeLocalName;\n\t}\n\t\n\tfunction getNodePrefix(node) {\n\t\treturn node.prefix;\n\t}\n\t\t\n\tfunction escapeXmlChars(str) {\n\t\tif(typeof(str) == \"string\")\n\t\t\treturn str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\\//g, '&#x2F;');\n\t\telse\n\t\t\treturn str;\n\t}\n\n\tfunction unescapeXmlChars(str) {\n\t\treturn str.replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '\"').replace(/&#x27;/g, \"'\").replace(/&#x2F;/g, '\\/')\n\t}\t\n\n\tfunction parseDOMChildren( node ) {\n\t\tif(node.nodeType == DOMNodeTypes.DOCUMENT_NODE) {\n\t\t\tvar result,\n\t\t\t    child = node.firstChild,\n\t\t\t    i,\n\t\t\t    len; \n\t\t\t\n\t\t\t// get the first node that isn't a comment\n\t\t\tfor(i = 0, len = node.childNodes.length; i < len; i += 1) {\n\t\t\t   if (node.childNodes[i].nodeType !== DOMNodeTypes.COMMENT_NODE) {\n\t\t\t       child = node.childNodes[i];\n\t\t\t       break;\n\t\t\t   } \n\t\t\t}\n\t\t\t\n\t\t\tif ( ignoreRoot ) {\n\t\t\t    result = parseDOMChildren(child);\n\t\t\t} else {\n\t\t\t    result = {};\n\t\t\t    var childName = getNodeLocalName(child);\n                result[childName] = parseDOMChildren(child);\n\t\t\t}\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\t\telse\n\t\tif(node.nodeType == DOMNodeTypes.ELEMENT_NODE) {\n\t\t\tvar result = new Object;\n\t\t\tresult.__cnt=0;\n\t\t\t\n\t\t\tvar nodeChildren = node.childNodes;\n\t\t\t\n\t\t\t// Children nodes\n\t\t\tfor(var cidx=0; cidx <nodeChildren.length; cidx++) {\n\t\t\t\tvar child = nodeChildren.item(cidx); // nodeChildren[cidx];\n\t\t\t\tvar childName = getNodeLocalName(child);\n\t\t\t\t\n\t\t\t\tresult.__cnt++;\n\t\t\t\tif(result[childName] == null) {\n\t\t\t\t\tresult[childName] = parseDOMChildren(child);\n\t\t\t\t\tresult[childName+\"_asArray\"] = new Array(1);\n\t\t\t\t\tresult[childName+\"_asArray\"][0] = result[childName];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(result[childName] != null) {\n\t\t\t\t\t\tif( !(result[childName] instanceof Array)) {\n\t\t\t\t\t\t\tvar tmpObj = result[childName];\n\t\t\t\t\t\t\tresult[childName] = new Array();\n\t\t\t\t\t\t\tresult[childName][0] = tmpObj;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tresult[childName+\"_asArray\"] = result[childName];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar aridx = 0;\n\t\t\t\t\twhile(result[childName][aridx]!=null) aridx++;\n\t\t\t\t\t(result[childName])[aridx] = parseDOMChildren(child);\n\t\t\t\t}\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// Attributes\n\t\t\tfor(var aidx=0; aidx <node.attributes.length; aidx++) {\n\t\t\t\tvar attr = node.attributes.item(aidx); // [aidx];\n\t\t\t\tresult.__cnt++;\n\t\t\t\t\n\t\t\t\tvar value2 = attr.value;\n\t\t\t\tfor(var m=0, ml=matchers.length; m < ml; m++) {\n\t\t\t\t    var matchobj = matchers[m];\n\t\t\t\t    if (matchobj.test.call(this, attr.value))\n\t\t\t\t        value2 = matchobj.converter.call(this, attr.value);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tresult[attrPrefix+attr.name]=value2;\n\t\t\t}\n\t\t\t\n\t\t\t// Node namespace prefix\n\t\t\tvar nodePrefix = getNodePrefix(node);\n\t\t\tif(nodePrefix!=null && nodePrefix!=\"\") {\n\t\t\t\tresult.__cnt++;\n\t\t\t\tresult.__prefix=nodePrefix;\n\t\t\t}\n\t\t\t\n\t\t\tif( result.__cnt == 1 && result[\"#text\"]!=null  ) {\n\t\t\t\tresult = result[\"#text\"];\n\t\t\t} \n\t\t\t\n\t\t\tif(result[\"#text\"]!=null) {\n\t\t\t\tresult.__text = result[\"#text\"];\n\t\t\t\tif(escapeMode)\n\t\t\t\t\tresult.__text = unescapeXmlChars(result.__text)\n\t\t\t\tdelete result[\"#text\"];\n\t\t\t\tdelete result[\"#text_asArray\"];\n\t\t\t}\n\t\t\tif(result[\"#cdata-section\"]!=null) {\n\t\t\t\tresult.__cdata = result[\"#cdata-section\"];\n\t\t\t\tdelete result[\"#cdata-section\"];\n\t\t\t\tdelete result[\"#cdata-section_asArray\"];\n\t\t\t}\n\t\t\t\n\t\t\tif(result.__text!=null || result.__cdata!=null) {\n\t\t\t\tresult.toString = function() {\n\t\t\t\t\treturn (this.__text!=null? this.__text:'')+( this.__cdata!=null ? this.__cdata:'');\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\telse\n\t\tif(node.nodeType == DOMNodeTypes.TEXT_NODE || node.nodeType == DOMNodeTypes.CDATA_SECTION_NODE) {\n\t\t\treturn node.nodeValue;\n\t\t}\t\n\t\telse\n\t\tif(node.nodeType == DOMNodeTypes.COMMENT_NODE) {\n\t\t    return null;\n\t\t}\n\t}\n\t\n\tfunction startTag(jsonObj, element, attrList, closed) {\n\t\tvar resultStr = \"<\"+ ( (jsonObj!=null && jsonObj.__prefix!=null)? (jsonObj.__prefix+\":\"):\"\") + element;\n\t\tif(attrList!=null) {\n\t\t\tfor(var aidx = 0; aidx < attrList.length; aidx++) {\n\t\t\t\tvar attrName = attrList[aidx];\n\t\t\t\tvar attrVal = jsonObj[attrName];\n\t\t\t\tresultStr+=\" \"+attrName.substr(1)+\"='\"+attrVal+\"'\";\n\t\t\t}\n\t\t}\n\t\tif(!closed)\n\t\t\tresultStr+=\">\";\n\t\telse\n\t\t\tresultStr+=\"/>\";\n\t\treturn resultStr;\n\t}\n\t\n\tfunction endTag(jsonObj,elementName) {\n\t\treturn \"</\"+ (jsonObj.__prefix!=null? (jsonObj.__prefix+\":\"):\"\")+elementName+\">\";\n\t}\n\t\n\tfunction endsWith(str, suffix) {\n\t    return str.indexOf(suffix, str.length - suffix.length) !== -1;\n\t}\n\t\n\tfunction jsonXmlSpecialElem ( jsonObj, jsonObjField ) {\n\t\tif(endsWith(jsonObjField.toString(),(\"_asArray\")) \n\t\t\t\t|| jsonObjField.toString().indexOf(\"_\")==0 \n\t\t\t\t|| (jsonObj[jsonObjField] instanceof Function) )\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\t\n\tfunction jsonXmlElemCount ( jsonObj ) {\n\t\tvar elementsCnt = 0;\n\t\tif(jsonObj instanceof Object ) {\n\t\t\tfor( var it in jsonObj  ) {\n\t\t\t\tif(jsonXmlSpecialElem ( jsonObj, it) )\n\t\t\t\t\tcontinue;\t\t\t\n\t\t\t\telementsCnt++;\n\t\t\t}\n\t\t}\n\t\treturn elementsCnt;\n\t}\n\t\n\tfunction parseJSONAttributes ( jsonObj ) {\n\t\tvar attrList = [];\n\t\tif(jsonObj instanceof Object ) {\n\t\t\tfor( var ait in jsonObj  ) {\n\t\t\t\tif(ait.toString().indexOf(\"__\")== -1 && ait.toString().indexOf(\"_\")==0) {\n\t\t\t\t\tattrList.push(ait);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn attrList;\n\t}\n\t\n\tfunction parseJSONTextAttrs ( jsonTxtObj ) {\n\t\tvar result =\"\";\n\t\t\n\t\tif(jsonTxtObj.__cdata!=null) {\t\t\t\t\t\t\t\t\t\t\n\t\t\tresult+=\"<![CDATA[\"+jsonTxtObj.__cdata+\"]]>\";\t\t\t\t\t\n\t\t}\n\t\t\n\t\tif(jsonTxtObj.__text!=null) {\t\t\t\n\t\t\tif(escapeMode)\n\t\t\t\tresult+=escapeXmlChars(jsonTxtObj.__text);\n\t\t\telse\n\t\t\t\tresult+=jsonTxtObj.__text;\n\t\t}\n\t\treturn result\n\t}\n\t\n\tfunction parseJSONTextObject ( jsonTxtObj ) {\n\t\tvar result =\"\";\n\n\t\tif( jsonTxtObj instanceof Object ) {\n\t\t\tresult+=parseJSONTextAttrs ( jsonTxtObj )\n\t\t}\n\t\telse\n\t\t\tif(jsonTxtObj!=null) {\n\t\t\t\tif(escapeMode)\n\t\t\t\t\tresult+=escapeXmlChars(jsonTxtObj);\n\t\t\t\telse\n\t\t\t\t\tresult+=jsonTxtObj;\n\t\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\tfunction parseJSONArray ( jsonArrRoot, jsonArrObj, attrList ) {\n\t\tvar result = \"\"; \n\t\tif(jsonArrRoot.length == 0) {\n\t\t\tresult+=startTag(jsonArrRoot, jsonArrObj, attrList, true);\n\t\t}\n\t\telse {\n\t\t\tfor(var arIdx = 0; arIdx < jsonArrRoot.length; arIdx++) {\n\t\t\t\tresult+=startTag(jsonArrRoot[arIdx], jsonArrObj, parseJSONAttributes(jsonArrRoot[arIdx]), false);\n\t\t\t\tresult+=parseJSONObject(jsonArrRoot[arIdx]);\n\t\t\t\tresult+=endTag(jsonArrRoot[arIdx],jsonArrObj);\t\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tfunction parseJSONObject ( jsonObj ) {\n\t\tvar result = \"\";\t\n\n\t\tvar elementsCnt = jsonXmlElemCount ( jsonObj );\n\t\t\n\t\tif(elementsCnt > 0) {\n\t\t\tfor( var it in jsonObj ) {\n\t\t\t\t\n\t\t\t\tif(jsonXmlSpecialElem ( jsonObj, it) )\n\t\t\t\t\tcontinue;\t\t\t\n\t\t\t\t\n\t\t\t\tvar subObj = jsonObj[it];\t\t\t\t\t\t\n\t\t\t\t\n\t\t\t\tvar attrList = parseJSONAttributes( subObj )\n\t\t\t\t\n\t\t\t\tif(subObj == null || subObj == undefined) {\n\t\t\t\t\tresult+=startTag(subObj, it, attrList, true)\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\tif(subObj instanceof Object) {\n\t\t\t\t\t\n\t\t\t\t\tif(subObj instanceof Array) {\t\t\t\t\t\n\t\t\t\t\t\tresult+=parseJSONArray( subObj, it, attrList )\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvar subObjElementsCnt = jsonXmlElemCount ( subObj );\n\t\t\t\t\t\tif(subObjElementsCnt > 0 || subObj.__text!=null || subObj.__cdata!=null) {\n\t\t\t\t\t\t\tresult+=startTag(subObj, it, attrList, false);\n\t\t\t\t\t\t\tresult+=parseJSONObject(subObj);\n\t\t\t\t\t\t\tresult+=endTag(subObj,it);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tresult+=startTag(subObj, it, attrList, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresult+=startTag(subObj, it, attrList, false);\n\t\t\t\t\tresult+=parseJSONTextObject(subObj);\n\t\t\t\t\tresult+=endTag(subObj,it);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult+=parseJSONTextObject(jsonObj);\n\t\t\n\t\treturn result;\n\t}\n\t\n\tthis.parseXmlString = function(xmlDocStr) {\n\t\tvar xmlDoc;\n\t\tif (window.DOMParser) {\n\t\t\t// ORANGE: XML parsing management\n\t\t\ttry\n\t\t\t{\n\t\t\t\tvar parser=new window.DOMParser();\n\t\t\t\txmlDoc = parser.parseFromString( xmlDocStr, \"text/xml\" );\n\t\t\t\tif(xmlDoc.getElementsByTagName('parsererror').length > 0) {\n\t\t\t\t\t  throw new Error('Error parsing XML');\n\t\t\t\t}\n\t\t\t\t//var parsererrorNS = parser.parseFromString('INVALID', 'text/xml').childNodes[0].namespaceURI;\n\t\t\t    //if(xmlDoc.getElementsByTagNameNS(parsererrorNS, 'parsererror').length > 0) {\n\t\t\t    //    throw new Error('Error parsing XML');\n\t\t\t    //}\t\t\n\t\t\t}\n\t\t\tcatch (e)\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn xmlDoc;\n\t}\n\n\tthis.xml2json = function (xmlDoc) {\n\t\treturn parseDOMChildren ( xmlDoc );\n\t}\n\t\n\tthis.xml_str2json = function (xmlDocStr) {\n\t\tvar xmlDoc = this.parseXmlString(xmlDocStr);\t\n\t\treturn xmlDoc === null ? xmlDoc : this.xml2json(xmlDoc);\n\t}\n\n\tthis.json2xml_str = function (jsonObj) {\n\t\treturn parseJSONObject ( jsonObj );\n\t}\n\n\tthis.json2xml = function (jsonObj) {\n\t\tvar xmlDocStr = this.json2xml_str (jsonObj);\n\t\treturn this.parseXmlString(xmlDocStr);\n\t}\n\t\n\tthis.getVersion = function () {\n\t\treturn VERSION;\n\t}\t\t\n\t\n\tthis.escapeMode = function(enabled) {\n\t\tescapeMode = enabled;\n\t}\n}","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nvar mp4lib = (function() {\n    var mp4lib = {\n        boxes:{},\n        fields:{},\n\n        // In debug mode, source data buffer is kept for each of deserialized box so any\n        // structural deserialization problems can be traced by serializing each box\n        // and comparing the resulting buffer with the source buffer.\n        // This greatly increases memory consumption, so it is turned off by default.\n        debug:false,\n\n        // A handler function may be hooked up to display warnings.\n        // A warning is typically non-critical issue, like unknown box in data buffer.\n        warningHandler:function(message){\n            //console.log(message);\n        }\n    };\n\n    var boxTypeArray = {};\n\n    mp4lib.registerTypeBoxes = function() {\n        boxTypeArray[\"moov\"] = mp4lib.boxes.MovieBox;\n        boxTypeArray[\"moof\"] = mp4lib.boxes.MovieFragmentBox;\n        boxTypeArray[\"ftyp\"] = mp4lib.boxes.FileTypeBox;\n        boxTypeArray[\"mfhd\"] = mp4lib.boxes.MovieFragmentHeaderBox;\n        boxTypeArray[\"mfra\"] = mp4lib.boxes.MovieFragmentRandomAccessBox;\n        boxTypeArray[\"udta\"] = mp4lib.boxes.UserDataBox;\n        boxTypeArray[\"trak\"] = mp4lib.boxes.TrackBox;\n        boxTypeArray[\"edts\"] = mp4lib.boxes.EditBox;\n        boxTypeArray[\"mdia\"] = mp4lib.boxes.MediaBox;\n        boxTypeArray[\"minf\"] = mp4lib.boxes.MediaInformationBox;\n        boxTypeArray[\"dinf\"] = mp4lib.boxes.DataInformationBox;\n        boxTypeArray[\"stbl\"] = mp4lib.boxes.SampleTableBox;\n        boxTypeArray[\"mvex\"] = mp4lib.boxes.MovieExtendsBox;\n        boxTypeArray[\"traf\"] = mp4lib.boxes.TrackFragmentBox;\n        boxTypeArray[\"meta\"] = mp4lib.boxes.MetaBox;\n        boxTypeArray[\"mvhd\"] = mp4lib.boxes.MovieHeaderBox;\n        boxTypeArray[\"mdat\"] = mp4lib.boxes.MediaDataBox;\n        boxTypeArray[\"free\"] = mp4lib.boxes.FreeSpaceBox;\n        boxTypeArray[\"sidx\"] = mp4lib.boxes.SegmentIndexBox;\n        boxTypeArray[\"tkhd\"] = mp4lib.boxes.TrackHeaderBox;\n        boxTypeArray[\"mdhd\"] = mp4lib.boxes.MediaHeaderBox;\n        boxTypeArray[\"mehd\"] = mp4lib.boxes.MovieExtendsHeaderBox;\n        boxTypeArray[\"hdlr\"] = mp4lib.boxes.HandlerBox;\n        boxTypeArray[\"stts\"] = mp4lib.boxes.TimeToSampleBox;\n        boxTypeArray[\"stsc\"] = mp4lib.boxes.SampleToChunkBox;\n        boxTypeArray[\"stco\"] = mp4lib.boxes.ChunkOffsetBox;\n        boxTypeArray[\"trex\"] = mp4lib.boxes.TrackExtendsBox;\n        boxTypeArray[\"vmhd\"] = mp4lib.boxes.VideoMediaHeaderBox;\n        boxTypeArray[\"smhd\"] = mp4lib.boxes.SoundMediaHeaderBox;\n        boxTypeArray[\"dref\"] = mp4lib.boxes.DataReferenceBox;\n        boxTypeArray[\"url \"] = mp4lib.boxes.DataEntryUrlBox;\n        boxTypeArray[\"urn \"] = mp4lib.boxes.DataEntryUrnBox;\n        boxTypeArray[\"tfhd\"] = mp4lib.boxes.TrackFragmentHeaderBox;\n        boxTypeArray[\"tfdt\"] = mp4lib.boxes.TrackFragmentBaseMediaDecodeTimeBox;\n        boxTypeArray[\"trun\"] = mp4lib.boxes.TrackFragmentRunBox;\n        boxTypeArray[\"stsd\"] = mp4lib.boxes.SampleDescriptionBox;\n        boxTypeArray[\"sdtp\"] = mp4lib.boxes.SampleDependencyTableBox;\n        boxTypeArray[\"avc1\"] = mp4lib.boxes.AVC1VisualSampleEntryBox;\n        boxTypeArray[\"encv\"] = mp4lib.boxes.EncryptedVideoBox;\n        boxTypeArray[\"avcC\"] = mp4lib.boxes.AVCConfigurationBox;\n        boxTypeArray[\"pasp\"] = mp4lib.boxes.PixelAspectRatioBox;\n        boxTypeArray[\"mp4a\"] = mp4lib.boxes.MP4AudioSampleEntryBox;\n        boxTypeArray[\"enca\"] = mp4lib.boxes.EncryptedAudioBox;\n        boxTypeArray[\"esds\"] = mp4lib.boxes.ESDBox;\n        boxTypeArray[\"stsz\"] = mp4lib.boxes.SampleSizeBox;\n        boxTypeArray[\"pssh\"] = mp4lib.boxes.ProtectionSystemSpecificHeaderBox;\n        boxTypeArray[\"senc\"] = mp4lib.boxes.SampleEncryptionBox;\n        boxTypeArray[\"saiz\"] = mp4lib.boxes.SampleAuxiliaryInformationSizesBox;\n        boxTypeArray[\"saio\"] = mp4lib.boxes.SampleAuxiliaryInformationOffsetsBox;\n        boxTypeArray[\"sinf\"] = mp4lib.boxes.ProtectionSchemeInformationBox;\n        boxTypeArray[\"schi\"] = mp4lib.boxes.SchemeInformationBox;\n        boxTypeArray[\"tenc\"] = mp4lib.boxes.TrackEncryptionBox;\n        boxTypeArray[\"schm\"] = mp4lib.boxes.SchemeTypeBox;\n        boxTypeArray[\"elst\"] = mp4lib.boxes.EditListBox;\n        boxTypeArray[\"hmhd\"] = mp4lib.boxes.HintMediaHeaderBox;\n        boxTypeArray[\"nmhd\"] = mp4lib.boxes.NullMediaHeaderBox;\n        boxTypeArray[\"ctts\"] = mp4lib.boxes.CompositionOffsetBox;\n        boxTypeArray[\"cslg\"] = mp4lib.boxes.CompositionToDecodeBox;\n        boxTypeArray[\"stss\"] = mp4lib.boxes.SyncSampleBox;\n        boxTypeArray[\"tref\"] = mp4lib.boxes.TrackReferenceBox;\n        boxTypeArray[\"frma\"] = mp4lib.boxes.OriginalFormatBox;\n        boxTypeArray[\"subs\"] = mp4lib.boxes.SubSampleInformationBox;\n        //extended types\n        boxTypeArray[JSON.stringify([0x6D, 0x1D, 0x9B, 0x05, 0x42, 0xD5, 0x44, 0xE6, 0x80, 0xE2, 0x14, 0x1D, 0xAF, 0xF7, 0x57, 0xB2])] = mp4lib.boxes.TfxdBox;\n        boxTypeArray[JSON.stringify([0xD4, 0x80, 0x7E, 0xF2, 0xCA, 0x39, 0x46, 0x95, 0x8E, 0x54, 0x26, 0xCB, 0x9E, 0x46, 0xA7, 0x9F])] = mp4lib.boxes.TfrfBox;\n        boxTypeArray[JSON.stringify([0xD0, 0x8A, 0x4F, 0x18, 0x10, 0xF3, 0x4A, 0x82, 0xB6, 0xC8, 0x32, 0xD8, 0xAB, 0xA1, 0x83, 0xD3])] = mp4lib.boxes.PiffProtectionSystemSpecificHeaderBox;\n        boxTypeArray[JSON.stringify([0x89, 0x74, 0xDB, 0xCE, 0x7B, 0xE7, 0x4C, 0x51, 0x84, 0xF9, 0x71, 0x48, 0xF9, 0x88, 0x25, 0x54])] = mp4lib.boxes.PiffTrackEncryptionBox;\n        boxTypeArray[JSON.stringify([0xA2, 0x39, 0x4F, 0x52, 0x5A, 0x9B, 0x4F, 0x14, 0xA2, 0x44, 0x6C, 0x42, 0x7C, 0x64, 0x8D, 0xF4])] = mp4lib.boxes.PiffSampleEncryptionBox;\n    };\n\n\n    mp4lib.constructorTypeBox = function (type) {\n        var obj, args;\n        obj = Object.create(type.prototype);\n        args = Array.prototype.slice.call(arguments, 1);\n        type.apply(obj, args);\n        return obj;\n    };\n\n    mp4lib.searchBox = function ( boxtype, uuid ){\n        var boxType;\n\n        if (uuid) {\n            boxType = boxTypeArray[uuid];\n        }\n        else {\n            boxType = boxTypeArray[boxtype];\n        }\n\n        if (!boxType){\n            boxType = mp4lib.boxes.UnknownBox;\n        }\n\n        return boxType;\n    };\n\n    mp4lib.createBox = function( boxtype,size, uuid) {\n        return mp4lib.constructorTypeBox.apply(null, [mp4lib.searchBox(boxtype, uuid),size]);\n    };\n\n    /**\n    deserialize binary data (uint8array) into mp4lib.File object\n    */\n    mp4lib.deserialize = function(uint8array) {\n        var f = new mp4lib.boxes.File();\n        try{\n            f.read(uint8array);\n        }catch(e){\n            mp4lib.warningHandler(e.message);\n            return null;\n        }\n        return f;\n    };\n\n    /**\n    serialize box (or mp4lib.File) into binary data (uint8array)\n    */\n    mp4lib.serialize = function(f) {\n        var file_size = f.getLength(),\n            uint8array = new Uint8Array(file_size);\n        f.write(uint8array);\n        return uint8array;\n    };\n\n    /**\n    exception thrown when binary data is malformed\n    it is thrown typically during deserialization\n    */\n    mp4lib.ParseException = function(message) {\n        this.message = message;\n        this.name = \"ParseException\";\n    };\n\n    /**\n    exception thrown when box objects contains invalid data,\n    ex. flag field is are not coherent with fields etc.\n    it is thrown typically during object manipulation or serialization\n    */\n    mp4lib.DataIntegrityException = function(message) {\n        this.message = message;\n        this.name = \"DataIntegrityException\";\n    };\n\n    return mp4lib;\n})();\n\n// This module is intended to work both on node.js and inside browser.\n// Since these environments differ in a way modules are stored/accessed,\n// we need to export the module in the environment-dependant way\n\nif (typeof module !== 'undefined' && typeof module.exports !== 'undefined')\n    module.exports = mp4lib; // node.js\nelse\n    window.mp4lib = mp4lib;  // browser\n\n","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nmp4lib.fields.readBytes = function(buf, pos, nbBytes) {\n    var value = 0,\n        i = 0;\n    for (i = 0; i < nbBytes; i++) {\n        value = value << 8;\n        value = value + buf[pos];\n        pos++;\n    }\n    return value;\n};\n\nmp4lib.fields.writeBytes = function(buf, pos, nbBytes, value) {\n    var i = 0;\n    for (i = 0; i < nbBytes; i++) {\n        buf[pos + nbBytes - i - 1] = value & 0xFF;\n        value = value >> 8;\n    }\n};\n\nmp4lib.fields.readString = function(buf, pos, count) {\n    var res = \"\",\n        i;\n    for (i = pos; i < pos + count; i++) {\n        res += String.fromCharCode(buf[i]);\n    }\n    return res;\n};\n\n//------------------------------- NumberField -------------------------------\n\nmp4lib.fields.NumberField = function(bits, signed) {\n    this.bits = bits;\n    this.signed = signed;\n};\n\nmp4lib.fields.NumberField.prototype.read = function(buf, pos) {\n    return mp4lib.fields.readBytes(buf, pos, this.bits / 8);\n};\n\nmp4lib.fields.NumberField.prototype.write = function(buf, pos, val) {\n    mp4lib.fields.writeBytes(buf, pos, this.bits / 8, val);\n};\n\nmp4lib.fields.NumberField.prototype.getLength = function() {\n    return this.bits / 8;\n};\n\n//------------------------------- 64BitsNumberField -------------------------------\n\nmp4lib.fields.LongNumberField = function() {};\n\nmp4lib.fields.LongNumberField.prototype.read = function(buf, pos) {\n    var high = mp4lib.fields.readBytes(buf, pos, 4),\n        low = mp4lib.fields.readBytes(buf, pos + 4, 4);\n    return goog.math.Long.fromBits(low, high);\n};\n\nmp4lib.fields.LongNumberField.prototype.write = function(buf, pos, val) {\n    var longNumber = (typeof val.getLowBits === 'function') ? val : goog.math.Long.fromNumber(val),\n        low = longNumber.getLowBits(),\n        high = longNumber.getHighBits();\n    mp4lib.fields.writeBytes(buf, pos, 4, high);\n    mp4lib.fields.writeBytes(buf, pos + 4, 4, low);\n};\n\nmp4lib.fields.LongNumberField.prototype.getLength = function() {\n    return 8;\n};\n\n//------------------------------- FixedLenStringField -------------------------------\n\nmp4lib.fields.FixedLenStringField = function(size) {\n    this.size = size;\n};\n\nmp4lib.fields.FixedLenStringField.prototype.read = function(buf, pos) {\n    var res = \"\",\n        i = 0;\n    for (i = 0; i < this.size; i++) {\n        res = res + String.fromCharCode(buf[pos + i]);\n    }\n    return res;\n};\n\nmp4lib.fields.FixedLenStringField.prototype.write = function(buf, pos, val) {\n    var i = 0;\n    for (i = 0; i < this.size; i++) {\n        buf[pos + i] = val.charCodeAt(i);\n    }\n};\n\nmp4lib.fields.FixedLenStringField.prototype.getLength = function() {\n    return this.size;\n};\n\n//------------------------------- BoxTypeField -------------------------------\n\nmp4lib.fields.BoxTypeField = function() {};\n\nmp4lib.fields.BoxTypeField.prototype.read = function(buf, pos) {\n    var res = \"\",\n        i = 0;\n    for (i = 0; i < 4; i++) {\n        res = res + String.fromCharCode(buf[pos + i]);\n    }\n    return res;\n};\n\nmp4lib.fields.BoxTypeField.prototype.write = function(buf, pos, val) {\n    var i = 0;\n    for (i = 0; i < 4; i++) {\n        buf[pos + i] = val.charCodeAt(i);\n    }\n};\n\nmp4lib.fields.BoxTypeField.prototype.getLength = function() {\n    return 4;\n};\n\n\n//------------------------------- StringField -------------------------------\n\nmp4lib.fields.StringField = function() {};\n\n\nmp4lib.fields.StringField.prototype.read = function(buf, pos, end) {\n    var res = \"\",\n        i = 0;\n\n    for (i = pos; i < end; i++) {\n        res = res + String.fromCharCode(buf[i]);\n        if (buf[i] === 0) {\n            return res;\n        }\n    }\n\n    if ((end - pos < 255) && (buf[0] == String.fromCharCode(end - pos))) {\n        res = res.substr(1, end - pos);\n        mp4lib.warningHandler('null-terminated string expected, ' +\n            'but found a string \"' + res + '\", which seems to be ' +\n            'length-prefixed instead. Conversion done.');\n        return res;\n    }\n\n    throw new mp4lib.ParseException('expected null-terminated string, ' +\n        'but end of field reached without termination. ' +\n        'Read so far:\"' + res + '\"');\n};\n\nmp4lib.fields.StringField.prototype.write = function(buf, pos, val) {\n    var i = 0;\n\n    for (i = 0; i < val.length; i++) {\n        buf[pos + i] = val.charCodeAt(i);\n    }\n    buf[pos + val.length] = 0;\n};\n\nmp4lib.fields.StringField.prototype.getLength = function(val) {\n    return val.length;\n};\n\n//------------------------------- ArrayField -------------------------------\n\nmp4lib.fields.ArrayField = function(innerField, size) {\n    this.innerField = innerField;\n    this.size = size;\n};\n\nmp4lib.fields.ArrayField.prototype.read = function(buf, pos) {\n    var innerFieldLength = -1,\n        res = [],\n        i = 0;\n    for (i = 0; i < this.size; i++) {\n\n        res.push(this.innerField.read(buf, pos));\n\n        if (innerFieldLength == -1) {\n            innerFieldLength = this.innerField.getLength(res[i]);\n        }\n        // it may happen that the size of field depends on the box flags, \n        // we need to count is having box and first structure constructed\n\n        pos += innerFieldLength;\n    }\n    return res;\n};\n\n// pre-defined shortcuts for common fields \n// ( it is recommended to use these shortcuts to avoid constructors \n//   being called for every field processing action )\nmp4lib.fields.FIELD_INT8 = new mp4lib.fields.NumberField(8, true);\nmp4lib.fields.FIELD_INT16 = new mp4lib.fields.NumberField(16, true);\nmp4lib.fields.FIELD_INT32 = new mp4lib.fields.NumberField(32, true);\nmp4lib.fields.FIELD_INT64 = new mp4lib.fields.LongNumberField();\nmp4lib.fields.FIELD_UINT8 = new mp4lib.fields.NumberField(8, false);\nmp4lib.fields.FIELD_UINT16 = new mp4lib.fields.NumberField(16, false);\nmp4lib.fields.FIELD_UINT32 = new mp4lib.fields.NumberField(32, false);\nmp4lib.fields.FIELD_UINT64 = new mp4lib.fields.LongNumberField();\nmp4lib.fields.FIELD_BIT8 = new mp4lib.fields.NumberField(8, false);\nmp4lib.fields.FIELD_BIT16 = new mp4lib.fields.NumberField(16, false);\nmp4lib.fields.FIELD_BIT24 = new mp4lib.fields.NumberField(24, false);\nmp4lib.fields.FIELD_BIT32 = new mp4lib.fields.NumberField(32, false);\nmp4lib.fields.FIELD_ID = new mp4lib.fields.BoxTypeField(4);\nmp4lib.fields.FIELD_STRING = new mp4lib.fields.StringField();","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// ---------- File (treated similarly to box in terms of processing) ----------\nmp4lib.boxes.File = function() {\n    this.boxes = [];\n};\n\nmp4lib.boxes.File.prototype.getBoxByType = function(boxType) {\n    var i = 0;\n\n    for (i = 0; i < this.boxes.length; i++) {\n        if (this.boxes[i].boxtype === boxType) {\n            return this.boxes[i];\n        }\n    }\n    return null;\n};\n\nmp4lib.boxes.File.prototype.getLength = function() {\n    var length = 0,\n        i = 0;\n\n    for (i = 0; i < this.boxes.length; i++) {\n        this.boxes[i].computeLength();\n        length += this.boxes[i].size;\n    }\n\n    return length;\n};\n\nmp4lib.boxes.File.prototype.write = function(data) {\n    var pos = 0,\n        i = 0;\n\n    for (i = 0; i < this.boxes.length; i++) {\n        pos = this.boxes[i].write(data, pos);\n    }\n};\n\nmp4lib.boxes.File.prototype.read = function(data) {\n    var size = 0,\n        boxtype = null,\n        uuidFieldPos = 0,\n        uuid = null,\n        pos = 0,\n        end = data.length,\n        box;\n\n    while (pos < end) {\n        // Read box size\n        size = mp4lib.fields.FIELD_UINT32.read(data, pos);\n\n        // Read boxtype\n        boxtype = mp4lib.fields.readString(data, pos + 4, 4);\n\n        // Extented type?\n        if (boxtype == \"uuid\") {\n            uuidFieldPos = (size == 1) ? 16 : 8;\n            uuid = new mp4lib.fields.ArrayField(mp4lib.fields.FIELD_INT8, 16).read(data, pos + uuidFieldPos, pos + uuidFieldPos + 16);\n            uuid = JSON.stringify(uuid);\n        }\n\n        box = mp4lib.createBox(boxtype, size, uuid);\n        if (boxtype === \"uuid\") {\n            pos = box.read(data, pos + mp4lib.fields.FIELD_INT8.getLength() * 16 + 8, pos + size);\n            uuid = null;\n        } else {\n            pos = box.read(data, pos + 8, pos + size);\n        }\n\n        // in debug mode, sourcebuffer is copied to each box,\n        // so any invalid deserializations may be found by comparing\n        // source buffer with serialized box\n        if (mp4lib.debug) {\n            box.__sourceBuffer = data.subarray(pos - box.size, pos);\n        }\n\n        //if boxtype is unknown, don't add it to the list box\n        if (box.boxtype) {\n            this.boxes.push(box);\n        }\n\n        if (box.size <= 0 || box.size === null) {\n            throw new mp4lib.ParseException('Problem on size of box ' + box.boxtype +\n                ', parsing stopped to avoid infinite loop');\n        }\n    }\n};\n\n/**\nfind child position\n*/\nmp4lib.boxes.File.prototype.getBoxOffsetByType = function(boxType) {\n    var offset = 0,\n        i = 0;\n\n    for (i = 0; i < this.boxes.length; i++) {\n        if (this.boxes[i].boxtype === boxType) {\n            return offset;\n        }\n        offset += this.boxes[i].size;\n    }\n    return -1;\n};\n\nmp4lib.boxes.File.prototype.getBoxIndexByType = function(boxType) {\n    var index = 0,\n        i = 0;\n\n    for (i = 0; i < this.boxes.length; i++) {\n        if (this.boxes[i].boxtype === boxType) {\n            return index;\n        }\n        index++;\n    }\n    return -1;\n};\n\n\n// ---------- Generic Box -------------------------------\nmp4lib.boxes.Box = function(boxType, size, uuid, largesize) {\n    this.size = size || null;\n    this.boxtype = boxType;\n    //large size management to do...\n    if (this.size === 1 && largesize) {\n        this.largesize = largesize;\n    }\n\n    if (uuid) {\n        this.extended_type = uuid;\n    }\n\n    this.localPos = 0;\n    this.localEnd = 0;\n};\n\nmp4lib.boxes.Box.prototype.write = function(data, pos) {\n    this.localPos = pos;\n    var i = 0;\n\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.size);\n    //if extended_type is not defined, boxtype must have this.boxtype value\n    if (!this.extended_type) {\n        this._writeData(data, mp4lib.fields.FIELD_ID, this.boxtype);\n    } else { //if extended_type is defined, boxtype must have 'uuid' value\n        this._writeData(data, mp4lib.fields.FIELD_ID, 'uuid');\n    }\n\n    if (this.size === 1) {\n        this._writeData(data, mp4lib.fields.FIELD_INT64, this.largesize);\n    }\n\n    if (this.extended_type) {\n        for (i = 0; i < 16; i++) {\n            this._writeData(data, mp4lib.fields.FIELD_INT8, this.extended_type[i]);\n        }\n    }\n};\n\nmp4lib.boxes.Box.prototype.getBoxByType = function(boxType) {\n    var i = 0;\n    if (this.hasOwnProperty('boxes')) {\n        for (i = 0; i < this.boxes.length; i++) {\n            if (this.boxes[i].boxtype === boxType) {\n                return this.boxes[i];\n            }\n        }\n    }\n    return null;\n};\n\n\nmp4lib.boxes.Box.prototype.getBoxesByType = function(boxType) {\n    var resu = [],\n        i = 0;\n    if (this.hasOwnProperty('boxes')) {\n        for (i = 0; i < this.boxes.length; i++) {\n            if (this.boxes[i].boxtype === boxType) {\n                resu.push(this.boxes[i]);\n            }\n        }\n    }\n    return resu;\n};\n\n/**\nremove child from a box\n*/\nmp4lib.boxes.Box.prototype.removeBoxByType = function(boxType) {\n    var i = 0;\n\n    if (this.hasOwnProperty('boxes')) {\n        for (i = 0; i < this.boxes.length; i++) {\n            if (this.boxes[i].boxtype === boxType) {\n                this.boxes.splice(i, 1);\n            }\n        }\n    } else {\n        mp4lib.warningHandler('' + this.boxtype + 'does not have ' + boxType + ' box, impossible to remove it');\n    }\n};\n\n/**\nfind child position\n*/\nmp4lib.boxes.Box.prototype.getBoxOffsetByType = function(boxType) {\n    var offset = 8,\n        i = 0;\n\n    if (this.hasOwnProperty('boxes')) {\n        for (i = 0; i < this.boxes.length; i++) {\n            if (this.boxes[i].boxtype === boxType) {\n                return offset;\n            }\n            offset += this.boxes[i].size;\n        }\n    }\n    return null;\n};\n\nmp4lib.boxes.Box.prototype.getBoxIndexByType = function(boxType) {\n    var index = 0,\n        i = 0;\n\n    if (this.hasOwnProperty('boxes')) {\n        for (i = 0; i < this.boxes.length; i++) {\n            if (this.boxes[i].boxtype === boxType) {\n                return index;\n            }\n            index++;\n        }\n    }\n    return null;\n};\n\nmp4lib.boxes.Box.prototype.computeLength = function() {\n    this.size = mp4lib.fields.FIELD_UINT32.getLength() + mp4lib.fields.FIELD_ID.getLength(); //size and boxtype length\n\n    /*if (this.size === 1) {\n        this.size += mp4lib.fields.FIELD_INT64.getLength(); //add large_size length\n    }*/\n    if (this.extended_type) {\n        this.size += mp4lib.fields.FIELD_INT8.getLength() * 16; //add extended_type length.\n    }\n};\n\nmp4lib.boxes.Box.prototype._readData = function(data, dataType) {\n    var resu = dataType.read(data, this.localPos, this.localEnd);\n    this.localPos += dataType.getLength(resu);\n    return resu;\n};\n\nmp4lib.boxes.Box.prototype._writeData = function(data, dataType, dataField) {\n    if (dataField === undefined || dataField === null) {\n        throw new mp4lib.ParseException('a field to write is null or undefined for box : ' + this.boxtype);\n    } else {\n        dataType.write(data, this.localPos, dataField);\n        this.localPos += dataType.getLength(dataField);\n    }\n};\n\nmp4lib.boxes.Box.prototype._writeBuffer = function(data, dataField, size) {\n    data.set(dataField, this.localPos);\n    this.localPos += size;\n};\n\nmp4lib.boxes.Box.prototype._writeArrayData = function(data, dataArrayType, array) {\n    var i = 0;\n\n    if (array === undefined || array === null || array.length === 0) {\n        throw new mp4lib.ParseException('an array to write is null, undefined or length = 0 for box : ' + this.boxtype);\n    }\n\n    for (i = 0; i < array.length; i++) {\n        this._writeData(data, dataArrayType, array[i]);\n    }\n};\n\nmp4lib.boxes.Box.prototype._readArrayData = function(data, dataArrayType) {\n    var array = [],\n        dataArrayTypeLength = dataArrayType.getLength(),\n        size = (this.localEnd - this.localPos) / dataArrayTypeLength,\n        i = 0;\n\n    for (i = 0; i < size; i++) {\n        array.push(dataArrayType.read(data, this.localPos));\n        this.localPos += dataArrayTypeLength;\n    }\n    return array;\n};\n\nmp4lib.boxes.Box.prototype._readArrayFieldData = function(data, dataArrayType, arraySize) {\n    var innerFieldLength = -1,\n        array = [],\n        i = 0;\n\n    for (i = 0; i < arraySize; i++) {\n\n        array.push(dataArrayType.read(data, this.localPos));\n\n        if (innerFieldLength === -1) {\n            innerFieldLength = dataArrayType.getLength(array[i]);\n        }\n        // it may happen that the size of field depends on the box flags,\n        // we need to count is having box and first structure constructed\n\n        this.localPos += innerFieldLength;\n    }\n    return array;\n};\n\n// ---------- Abstract Container Box -------------------------------\nmp4lib.boxes.ContainerBox = function(boxType, size) {\n    mp4lib.boxes.Box.call(this, boxType, size);\n    this.boxes = [];\n};\n\nmp4lib.boxes.ContainerBox.prototype = Object.create(mp4lib.boxes.Box.prototype);\nmp4lib.boxes.ContainerBox.prototype.constructor = mp4lib.boxes.ContainerBox;\n\nmp4lib.boxes.ContainerBox.prototype.computeLength = function() {\n    mp4lib.boxes.Box.prototype.computeLength.call(this);\n    var i = 0;\n    for (i = 0; i < this.boxes.length; i++) {\n        this.boxes[i].computeLength();\n        this.size += this.boxes[i].size;\n    }\n};\n\nmp4lib.boxes.ContainerBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.Box.prototype.write.call(this, data, pos);\n    var i = 0;\n\n    for (i = 0; i < this.boxes.length; i++) {\n        this.localPos = this.boxes[i].write(data, this.localPos);\n    }\n\n    return this.localPos;\n};\n\nmp4lib.boxes.ContainerBox.prototype.read = function(data, pos, end) {\n    var size = 0,\n        uuidFieldPos = 0,\n        uuid = null,\n        boxtype,\n        box;\n\n    while (pos < end) {\n        // Read box size\n        size = mp4lib.fields.FIELD_UINT32.read(data, pos);\n\n        // Read boxtype\n        boxtype = mp4lib.fields.readString(data, pos + 4, 4);\n\n        // Extented type?\n        if (boxtype === \"uuid\") {\n            uuidFieldPos = (size == 1) ? 16 : 8;\n            uuid = new mp4lib.fields.ArrayField(mp4lib.fields.FIELD_INT8, 16).read(data, pos + uuidFieldPos, pos + uuidFieldPos + 16);\n            uuid = JSON.stringify(uuid);\n        }\n\n        box = mp4lib.createBox(boxtype, size, uuid);\n        if (boxtype === \"uuid\") {\n            pos = box.read(data, pos + mp4lib.fields.FIELD_INT8.getLength() * 16 + 8, pos + size);\n            uuid = null;\n        } else {\n            pos = box.read(data, pos + 8, pos + size);\n        }\n\n        // in debug mode, sourcebuffer is copied to each box,\n        // so any invalid deserializations may be found by comparing\n        // source buffer with serialized box\n        if (mp4lib.debug) {\n            box.__sourceBuffer = data.subarray(pos - box.size, pos);\n        }\n        \n        //if boxtype is unknown, don't add it to the list box\n        if (box.boxtype) {\n            this.boxes.push(box);\n        }\n\n        if (box.size <= 0 || box.size === null) {\n            throw new mp4lib.ParseException('Problem on size of box ' + box.boxtype +\n                ', parsing stopped to avoid infinite loop');\n        }\n    }\n\n    return pos;\n};\n\n// ---------- Full Box -------------------------------\nmp4lib.boxes.FullBox = function(boxType, size, uuid) {\n    mp4lib.boxes.Box.call(this, boxType, size, uuid);\n    this.version = null;\n    this.flags = null;\n};\n\nmp4lib.boxes.FullBox.prototype = Object.create(mp4lib.boxes.Box.prototype);\nmp4lib.boxes.FullBox.prototype.constructor = mp4lib.boxes.FullBox;\n\nmp4lib.boxes.FullBox.prototype.read = function(data, pos, end) {\n    this.localPos = pos;\n    this.localEnd = end;\n    this.version = this._readData(data, mp4lib.fields.FIELD_INT8);\n    this.flags = this._readData(data, mp4lib.fields.FIELD_BIT24);\n};\n\nmp4lib.boxes.FullBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.Box.prototype.write.call(this, data, pos);\n\n    this._writeData(data, mp4lib.fields.FIELD_INT8, this.version);\n    this._writeData(data, mp4lib.fields.FIELD_BIT24, this.flags);\n};\n\nmp4lib.boxes.FullBox.prototype.getFullBoxAttributesLength = function() {\n    this.size += mp4lib.fields.FIELD_INT8.getLength() + mp4lib.fields.FIELD_BIT24.getLength(); //version and flags size\n};\n\nmp4lib.boxes.FullBox.prototype.computeLength = function() {\n    mp4lib.boxes.Box.prototype.computeLength.call(this);\n    mp4lib.boxes.FullBox.prototype.getFullBoxAttributesLength.call(this);\n};\n\n// ---------- Abstract Container FullBox -------------------------------\nmp4lib.boxes.ContainerFullBox = function(boxType, size) {\n    mp4lib.boxes.FullBox.call(this, boxType, size);\n    this.boxes = [];\n};\n\nmp4lib.boxes.ContainerFullBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.ContainerFullBox.prototype.constructor = mp4lib.boxes.ContainerFullBox;\n\nmp4lib.boxes.ContainerFullBox.prototype.computeLength = function(isEntryCount) {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    var i = 0;\n\n    if (isEntryCount) {\n        this.size += mp4lib.fields.FIELD_UINT32.getLength();\n    }\n\n    for (i = 0; i < this.boxes.length; i++) {\n        this.boxes[i].computeLength();\n        this.size += this.boxes[i].size;\n    }\n};\n\nmp4lib.boxes.ContainerFullBox.prototype.read = function(data, pos, end, isEntryCount) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n    var size = 0,\n        uuidFieldPos = 0,\n        uuid = null,\n        boxtype, box;\n\n    if (isEntryCount) {\n        this.entry_count = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    }\n\n    while (this.localPos < this.localEnd) {\n        // Read box size\n        size = mp4lib.fields.FIELD_UINT32.read(data, this.localPos);\n\n        // Read boxtype\n        boxtype = mp4lib.fields.readString(data, this.localPos + 4, 4);\n\n        // Extented type?\n        if (boxtype == \"uuid\") {\n            uuidFieldPos = (size == 1) ? 16 : 8;\n            uuid = new mp4lib.fields.ArrayField(mp4lib.fields.FIELD_INT8, 16).read(data, this.localPos + uuidFieldPos, this.localPos + uuidFieldPos + 16);\n            uuid = JSON.stringify(uuid);\n        }\n\n        box = mp4lib.createBox(boxtype, size, uuid);\n        if (boxtype === \"uuid\") {\n            this.localPos = box.read(data, this.localPos + mp4lib.fields.FIELD_INT8.getLength() * 16 + 8, this.localPos + size);\n            uuid = null;\n        } else {\n            this.localPos = box.read(data, this.localPos + 8, this.localPos + size);\n        }\n\n        // in debug mode, sourcebuffer is copied to each box,\n        // so any invalid deserializations may be found by comparing\n        // source buffer with serialized box\n        if (mp4lib.debug) {\n            box.__sourceBuffer = data.subarray(this.localPos - box.size, this.localPos);\n        }\n\n        if (box.boxtype) {\n            this.boxes.push(box);\n        }\n\n        if (box.size <= 0 || box.size === null) {\n            throw new mp4lib.ParseException('Problem on size of box ' + box.boxtype +\n                ', parsing stopped to avoid infinite loop');\n        }\n    }\n\n    return this.localPos;\n};\n\nmp4lib.boxes.ContainerFullBox.prototype.write = function(data, pos, isEntryCount) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n    var i = 0;\n\n    if (isEntryCount === true) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry_count);\n    }\n\n    for (i = 0; i < this.boxes.length; i++) {\n        this.localPos = this.boxes[i].write(data, this.localPos);\n    }\n\n    return this.localPos;\n};\n\n// ----------- Unknown Box -----------------------------\n\nmp4lib.boxes.UnknownBox = function(size) {\n    mp4lib.boxes.Box.call(this, null, size);\n};\n\nmp4lib.boxes.UnknownBox.prototype = Object.create(mp4lib.boxes.Box.prototype);\nmp4lib.boxes.UnknownBox.prototype.constructor = mp4lib.boxes.UnknownBox;\n\nmp4lib.boxes.UnknownBox.prototype.read = function(data, pos, end) {\n    this.localPos = pos;\n    this.localEnd = end;\n\n    this.unrecognized_data = data.subarray(this.localPos, this.localEnd);\n\n    return this.localEnd;\n};\n\nmp4lib.boxes.UnknownBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.Box.prototype.write.call(this, data, pos);\n\n    this._writeBuffer(data, this.unrecognized_data, this.unrecognized_data.length);\n\n    return this.localPos;\n};\n\nmp4lib.boxes.UnknownBox.prototype.computeLength = function() {\n    mp4lib.boxes.Box.prototype.computeLength.call(this);\n    this.size += this.unrecognized_data.length;\n};\n\n// --------------------------- ftyp ----------------------------------\n\nmp4lib.boxes.FileTypeBox = function(size) {\n    mp4lib.boxes.Box.call(this, 'ftyp', size);\n};\n\nmp4lib.boxes.FileTypeBox.prototype = Object.create(mp4lib.boxes.Box.prototype);\nmp4lib.boxes.FileTypeBox.prototype.constructor = mp4lib.boxes.FileTypeBox;\n\nmp4lib.boxes.FileTypeBox.prototype.computeLength = function() {\n    mp4lib.boxes.Box.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_INT32.getLength() * 2 + mp4lib.fields.FIELD_INT32.getLength() * this.compatible_brands.length;\n};\n\nmp4lib.boxes.FileTypeBox.prototype.read = function(data, pos, end) {\n    this.localPos = pos;\n    this.localEnd = end;\n\n    this.major_brand = this._readData(data, mp4lib.fields.FIELD_INT32);\n    this.minor_brand = this._readData(data, mp4lib.fields.FIELD_INT32);\n    this.compatible_brands = this._readArrayData(data, mp4lib.fields.FIELD_INT32);\n\n    return this.localPos;\n};\n\nmp4lib.boxes.FileTypeBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.Box.prototype.write.call(this, data, pos);\n\n    this._writeData(data, mp4lib.fields.FIELD_INT32, this.major_brand);\n    this._writeData(data, mp4lib.fields.FIELD_INT32, this.minor_brand);\n    this._writeArrayData(data, mp4lib.fields.FIELD_INT32, this.compatible_brands);\n\n    return this.localPos;\n};\n// --------------------------- moov ----------------------------------\n\nmp4lib.boxes.MovieBox = function(size) {\n    mp4lib.boxes.ContainerBox.call(this, 'moov', size);\n};\n\nmp4lib.boxes.MovieBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);\nmp4lib.boxes.MovieBox.prototype.constructor = mp4lib.boxes.MovieBox;\n\n// --------------------------- moof ----------------------------------\nmp4lib.boxes.MovieFragmentBox = function(size) {\n    mp4lib.boxes.ContainerBox.call(this, 'moof', size);\n};\n\nmp4lib.boxes.MovieFragmentBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);\nmp4lib.boxes.MovieFragmentBox.prototype.constructor = mp4lib.boxes.MovieFragmentBox;\n\n// --------------------------- mfra ----------------------------------\nmp4lib.boxes.MovieFragmentRandomAccessBox = function(size) {\n    mp4lib.boxes.ContainerBox.call(this, 'mfra', size);\n};\n\nmp4lib.boxes.MovieFragmentRandomAccessBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);\nmp4lib.boxes.MovieFragmentRandomAccessBox.prototype.constructor = mp4lib.boxes.MovieFragmentRandomAccessBox;\n\n// --------------------------- udta ----------------------------------\nmp4lib.boxes.UserDataBox = function(size) {\n    mp4lib.boxes.ContainerBox.call(this, 'udta', size);\n};\n\nmp4lib.boxes.UserDataBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);\nmp4lib.boxes.UserDataBox.prototype.constructor = mp4lib.boxes.UserDataBox;\n\n// --------------------------- trak ----------------------------------\nmp4lib.boxes.TrackBox = function(size) {\n    mp4lib.boxes.ContainerBox.call(this, 'trak', size);\n};\n\nmp4lib.boxes.TrackBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);\nmp4lib.boxes.TrackBox.prototype.constructor = mp4lib.boxes.TrackBox;\n\n// --------------------------- edts ----------------------------------\nmp4lib.boxes.EditBox = function(size) {\n    mp4lib.boxes.ContainerBox.call(this, 'edts', size);\n};\n\nmp4lib.boxes.EditBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);\nmp4lib.boxes.EditBox.prototype.constructor = mp4lib.boxes.EditBox;\n\n// --------------------------- mdia ----------------------------------\nmp4lib.boxes.MediaBox = function(size) {\n    mp4lib.boxes.ContainerBox.call(this, 'mdia', size);\n};\n\nmp4lib.boxes.MediaBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);\nmp4lib.boxes.MediaBox.prototype.constructor = mp4lib.boxes.MediaBox;\n\n// --------------------------- minf ----------------------------------\nmp4lib.boxes.MediaInformationBox = function(size) {\n    mp4lib.boxes.ContainerBox.call(this, 'minf', size);\n};\n\nmp4lib.boxes.MediaInformationBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);\nmp4lib.boxes.MediaInformationBox.prototype.constructor = mp4lib.boxes.MediaInformationBox;\n\n// --------------------------- dinf ----------------------------------\nmp4lib.boxes.DataInformationBox = function(size) {\n    mp4lib.boxes.ContainerBox.call(this, 'dinf', size);\n};\n\nmp4lib.boxes.DataInformationBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);\nmp4lib.boxes.DataInformationBox.prototype.constructor = mp4lib.boxes.DataInformationBox;\n\n// --------------------------- stbl ----------------------------------\nmp4lib.boxes.SampleTableBox = function(size) {\n    mp4lib.boxes.ContainerBox.call(this, 'stbl', size);\n};\n\nmp4lib.boxes.SampleTableBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);\nmp4lib.boxes.SampleTableBox.prototype.constructor = mp4lib.boxes.SampleTableBox;\n\n// --------------------------- mvex ----------------------------------\nmp4lib.boxes.MovieExtendsBox = function(size) {\n    mp4lib.boxes.ContainerBox.call(this, 'mvex', size);\n};\n\nmp4lib.boxes.MovieExtendsBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);\nmp4lib.boxes.MovieExtendsBox.prototype.constructor = mp4lib.boxes.MovieExtendsBox;\n\n// --------------------------- traf ----------------------------------\nmp4lib.boxes.TrackFragmentBox = function(size) {\n    mp4lib.boxes.ContainerBox.call(this, 'traf', size);\n};\n\nmp4lib.boxes.TrackFragmentBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);\nmp4lib.boxes.TrackFragmentBox.prototype.constructor = mp4lib.boxes.TrackFragmentBox;\n\n// --------------------------- meta -----------------------------\nmp4lib.boxes.MetaBox = function(size) {\n    mp4lib.boxes.ContainerFullBox.call(this, 'meta', size);\n};\n\nmp4lib.boxes.MetaBox.prototype = Object.create(mp4lib.boxes.ContainerFullBox.prototype);\nmp4lib.boxes.MetaBox.prototype.constructor = mp4lib.boxes.MetaBox;\n\nmp4lib.boxes.MetaBox.prototype.computeLength = function() {\n    mp4lib.boxes.ContainerFullBox.prototype.computeLength.call(this, false);\n};\n\nmp4lib.boxes.MetaBox.prototype.read = function(data, pos, end) {\n    return mp4lib.boxes.ContainerFullBox.prototype.read.call(this, data, pos, end, false);\n};\n\nmp4lib.boxes.MetaBox.prototype.write = function(data, pos) {\n    return mp4lib.boxes.ContainerFullBox.prototype.write.call(this, data, pos, false);\n};\n\n// --------------------------- mvhd ----------------------------------\nmp4lib.boxes.MovieHeaderBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'mvhd', size);\n};\n\nmp4lib.boxes.MovieHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.MovieHeaderBox.prototype.constructor = mp4lib.boxes.MovieHeaderBox;\n\nmp4lib.boxes.MovieHeaderBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n\n    this.size += mp4lib.fields.FIELD_INT32.getLength() /*rate size*/ + mp4lib.fields.FIELD_INT16.getLength() * 2 /*volume size and reserved size*/ ;\n    this.size += mp4lib.fields.FIELD_INT32.getLength() * 2 /*reserved_2 size*/ + mp4lib.fields.FIELD_INT32.getLength() * 9 /*matrix size*/ ;\n    this.size += mp4lib.fields.FIELD_BIT32.getLength() * 6 /*pre_defined size*/ + mp4lib.fields.FIELD_UINT32.getLength() /*next_track_ID size*/ ;\n    if (this.version === 1) {\n        this.size += mp4lib.fields.FIELD_UINT64.getLength() * 3 + mp4lib.fields.FIELD_UINT32.getLength();\n    } else {\n        this.size += mp4lib.fields.FIELD_UINT32.getLength() * 4;\n    }\n};\n\nmp4lib.boxes.MovieHeaderBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n\n    if (this.version === 1) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.creation_time);\n        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.modification_time);\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.timescale);\n        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.duration);\n    } else {\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.creation_time);\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.modification_time);\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.timescale);\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.duration);\n    }\n\n    this._writeData(data, mp4lib.fields.FIELD_INT32, this.rate);\n    this._writeData(data, mp4lib.fields.FIELD_INT16, this.volume);\n    this._writeData(data, mp4lib.fields.FIELD_INT16, this.reserved);\n    this._writeArrayData(data, mp4lib.fields.FIELD_INT32, this.reserved_2);\n    this._writeArrayData(data, mp4lib.fields.FIELD_INT32, this.matrix);\n    this._writeArrayData(data, mp4lib.fields.FIELD_BIT32, this.pre_defined);\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.next_track_ID);\n\n    return this.localPos;\n};\n\nmp4lib.boxes.MovieHeaderBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    if (this.version == 1) {\n        this.creation_time = this._readData(data, mp4lib.fields.FIELD_UINT64);\n        this.modification_time = this._readData(data, mp4lib.fields.FIELD_UINT64);\n        this.timescale = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        this.duration = this._readData(data, mp4lib.fields.FIELD_UINT64);\n    } else {\n        this.creation_time = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        this.modification_time = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        this.timescale = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        this.duration = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    }\n\n    this.rate = this._readData(data, mp4lib.fields.FIELD_INT32);\n    this.volume = this._readData(data, mp4lib.fields.FIELD_INT16);\n    this.reserved = this._readData(data, mp4lib.fields.FIELD_INT16);\n    this.reserved_2 = this._readArrayFieldData(data, mp4lib.fields.FIELD_INT32, 2);\n    this.matrix = this._readArrayFieldData(data, mp4lib.fields.FIELD_INT32, 9);\n    this.pre_defined = this._readArrayFieldData(data, mp4lib.fields.FIELD_BIT32, 6);\n    this.next_track_ID = this._readData(data, mp4lib.fields.FIELD_UINT32);\n\n    return this.localPos;\n};\n\n// --------------------------- mdat ----------------------------------\nmp4lib.boxes.MediaDataBox = function(size) {\n    mp4lib.boxes.Box.call(this, 'mdat', size);\n};\n\nmp4lib.boxes.MediaDataBox.prototype = Object.create(mp4lib.boxes.Box.prototype);\nmp4lib.boxes.MediaDataBox.prototype.constructor = mp4lib.boxes.MediaDataBox;\n\nmp4lib.boxes.MediaDataBox.prototype.computeLength = function() {\n    mp4lib.boxes.Box.prototype.computeLength.call(this);\n    this.size += this.data.length;\n};\n\nmp4lib.boxes.MediaDataBox.prototype.read = function(data, pos, end) {\n    this.data = data.subarray(pos, end);\n\n    return end;\n};\n\nmp4lib.boxes.MediaDataBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.Box.prototype.write.call(this, data, pos);\n\n    this._writeBuffer(data, this.data, this.data.length);\n\n    return this.localPos;\n};\n\n// --------------------------- free ----------------------------------\nmp4lib.boxes.FreeSpaceBox = function(size) {\n    mp4lib.boxes.Box.call(this, 'free', size);\n};\n\nmp4lib.boxes.FreeSpaceBox.prototype = Object.create(mp4lib.boxes.Box.prototype);\nmp4lib.boxes.FreeSpaceBox.prototype.constructor = mp4lib.boxes.FreeSpaceBox;\n\nmp4lib.boxes.FreeSpaceBox.prototype.computeLength = function() {\n    mp4lib.boxes.Box.prototype.computeLength.call(this);\n    this.size += this.data.length;\n};\n\nmp4lib.boxes.FreeSpaceBox.prototype.read = function(data, pos, end) {\n    this.localPos = pos;\n    this.localEnd = end;\n    this.data = data.subarray(this.localPos, this.localEnd);\n    return this.localEnd;\n};\n\nmp4lib.boxes.FreeSpaceBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.Box.prototype.write.call(this, data, pos);\n\n    this._writeBuffer(data, this.data, this.data.length);\n\n    return this.localPos;\n};\n\n// --------------------------- sidx ----------------------------------\nmp4lib.boxes.SegmentIndexBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'sidx', size);\n};\n\nmp4lib.boxes.SegmentIndexBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.SegmentIndexBox.prototype.constructor = mp4lib.boxes.SegmentIndexBox;\n\nmp4lib.boxes.SegmentIndexBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n\n    this.size += mp4lib.fields.FIELD_UINT32.getLength() * 2; /* reference_ID and timescale size*/\n    if (this.version === 1) {\n        this.size += mp4lib.fields.FIELD_UINT64.getLength() * 2; /* earliest_presentation_time and first_offset size*/\n    } else {\n        this.size += mp4lib.fields.FIELD_UINT32.getLength() * 2; /* earliest_presentation_time and first_offset size*/\n    }\n    this.size += mp4lib.fields.FIELD_UINT16.getLength(); /* reserved size*/\n    this.size += mp4lib.fields.FIELD_UINT16.getLength(); /* reference_count size*/\n    this.size += (mp4lib.fields.FIELD_UINT64.getLength() /* reference_info size*/ + mp4lib.fields.FIELD_UINT32.getLength() /* SAP size*/ ) * this.reference_count;\n};\n\n\nmp4lib.boxes.SegmentIndexBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    var i = 0,\n        struct = {};\n\n    this.reference_ID = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    this.timescale = this._readData(data, mp4lib.fields.FIELD_UINT32);\n\n    if (this.version === 1) {\n        this.earliest_presentation_time = this._readData(data, mp4lib.fields.FIELD_UINT64);\n        this.first_offset = this._readData(data, mp4lib.fields.FIELD_UINT64);\n    } else {\n        this.earliest_presentation_time = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        this.first_offset = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    }\n    this.reserved = this._readData(data, mp4lib.fields.FIELD_UINT16);\n    this.reference_count = this._readData(data, mp4lib.fields.FIELD_UINT16);\n\n    this.references = [];\n\n    for (i = 0; i < this.reference_count; i++) {\n        struct = {};\n\n        struct.reference_info = this._readData(data, mp4lib.fields.FIELD_UINT64);\n        struct.SAP = this._readData(data, mp4lib.fields.FIELD_UINT32);\n\n        this.references.push(struct);\n    }\n\n    return this.localPos;\n};\n\nmp4lib.boxes.SegmentIndexBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n    var i = 0;\n\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.reference_ID);\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.timescale);\n\n    if (this.version === 1) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.earliest_presentation_time);\n        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.first_offset);\n    } else {\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.earliest_presentation_time);\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.first_offset);\n    }\n\n    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.reserved);\n    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.reference_count);\n\n    for (i = 0; i < this.reference_count; i++) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.references[i].reference_info);\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.references[i].SAP);\n    }\n    return this.localPos;\n};\n\n// --------------------------- tkhd ----------------------------------\nmp4lib.boxes.TrackHeaderBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'tkhd', size);\n};\n\nmp4lib.boxes.TrackHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.TrackHeaderBox.prototype.constructor = mp4lib.boxes.TrackHeaderBox;\n\nmp4lib.boxes.TrackHeaderBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_INT16.getLength() * 4 + mp4lib.fields.FIELD_INT32.getLength() * 2 + mp4lib.fields.FIELD_UINT32.getLength() * 2 + mp4lib.fields.FIELD_INT32.getLength() * 9;\n    if (this.version == 1) {\n        this.size += mp4lib.fields.FIELD_UINT64.getLength() * 3 + mp4lib.fields.FIELD_UINT32.getLength() * 2;\n    } else {\n        this.size += mp4lib.fields.FIELD_UINT32.getLength() * 5;\n    }\n};\n\nmp4lib.boxes.TrackHeaderBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    if (this.version === 1) {\n        this.creation_time = this._readData(data, mp4lib.fields.FIELD_UINT64);\n        this.modification_time = this._readData(data, mp4lib.fields.FIELD_UINT64);\n        this.track_id = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        this.reserved = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        this.duration = this._readData(data, mp4lib.fields.FIELD_UINT64);\n    } else {\n        this.creation_time = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        this.modification_time = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        this.track_id = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        this.reserved = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        this.duration = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    }\n\n    this.reserved_2 = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT32, 2);\n    this.layer = this._readData(data, mp4lib.fields.FIELD_INT16);\n    this.alternate_group = this._readData(data, mp4lib.fields.FIELD_INT16);\n    this.volume = this._readData(data, mp4lib.fields.FIELD_INT16);\n    this.reserved_3 = this._readData(data, mp4lib.fields.FIELD_INT16);\n    this.matrix = this._readArrayFieldData(data, mp4lib.fields.FIELD_INT32, 9);\n    this.width = this._readData(data, mp4lib.fields.FIELD_INT32);\n    this.height = this._readData(data, mp4lib.fields.FIELD_INT32);\n    return this.localPos;\n};\n\nmp4lib.boxes.TrackHeaderBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n\n    if (this.version === 1) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.creation_time);\n        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.modification_time);\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.track_id);\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.reserved);\n        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.duration);\n    } else {\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.creation_time);\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.modification_time);\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.track_id);\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.reserved);\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.duration);\n    }\n\n    this._writeArrayData(data, mp4lib.fields.FIELD_UINT32, this.reserved_2);\n    this._writeData(data, mp4lib.fields.FIELD_INT16, this.layer);\n    this._writeData(data, mp4lib.fields.FIELD_INT16, this.alternate_group);\n    this._writeData(data, mp4lib.fields.FIELD_INT16, this.volume);\n    this._writeData(data, mp4lib.fields.FIELD_INT16, this.reserved_3);\n    this._writeArrayData(data, mp4lib.fields.FIELD_INT32, this.matrix);\n    this._writeData(data, mp4lib.fields.FIELD_INT32, this.width);\n    this._writeData(data, mp4lib.fields.FIELD_INT32, this.height);\n    return this.localPos;\n};\n\n// --------------------------- mdhd ----------------------------------\nmp4lib.boxes.MediaHeaderBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'mdhd', size);\n};\n\nmp4lib.boxes.MediaHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.MediaHeaderBox.prototype.constructor = mp4lib.boxes.MediaHeaderBox;\n\nmp4lib.boxes.MediaHeaderBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_UINT16.getLength() * 2;\n    if (this.version == 1) {\n        this.size += mp4lib.fields.FIELD_UINT64.getLength() * 3 + mp4lib.fields.FIELD_UINT32.getLength();\n    } else {\n        this.size += mp4lib.fields.FIELD_UINT32.getLength() * 4;\n    }\n};\n\nmp4lib.boxes.MediaHeaderBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    if (this.version === 1) {\n        this.creation_time = this._readData(data, mp4lib.fields.FIELD_UINT64);\n        this.modification_time = this._readData(data, mp4lib.fields.FIELD_UINT64);\n        this.timescale = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        this.duration = this._readData(data, mp4lib.fields.FIELD_UINT64);\n    } else {\n        this.creation_time = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        this.modification_time = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        this.timescale = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        this.duration = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    }\n\n    this.language = this._readData(data, mp4lib.fields.FIELD_UINT16);\n    this.pre_defined = this._readData(data, mp4lib.fields.FIELD_UINT16);\n    return this.localPos;\n};\n\nmp4lib.boxes.MediaHeaderBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n\n    if (this.version === 1) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.creation_time);\n        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.modification_time);\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.timescale);\n        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.duration);\n    } else {\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.creation_time);\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.modification_time);\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.timescale);\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.duration);\n    }\n\n    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.language);\n    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.pre_defined);\n    return this.localPos;\n};\n\n// --------------------------- mehd ----------------------------------\nmp4lib.boxes.MovieExtendsHeaderBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'mehd', size);\n};\n\nmp4lib.boxes.MovieExtendsHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.MovieExtendsHeaderBox.prototype.constructor = mp4lib.boxes.MovieExtendsHeaderBox;\n\nmp4lib.boxes.MovieExtendsHeaderBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    if (this.version == 1) {\n        this.size += mp4lib.fields.FIELD_UINT64.getLength();\n    } else {\n        this.size += mp4lib.fields.FIELD_UINT32.getLength();\n    }\n};\n\nmp4lib.boxes.MovieExtendsHeaderBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    if (this.version === 1) {\n        this.fragment_duration = this._readData(data, mp4lib.fields.FIELD_UINT64);\n    } else {\n        this.fragment_duration = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    }\n    return this.localPos;\n};\n\nmp4lib.boxes.MovieExtendsHeaderBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n\n    if (this.version === 1) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.fragment_duration);\n    } else {\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.fragment_duration);\n    }\n    return this.localPos;\n};\n\n// --------------------------- hdlr --------------------------------\nmp4lib.boxes.HandlerBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'hdlr', size);\n};\n\nmp4lib.boxes.HandlerBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.HandlerBox.prototype.constructor = mp4lib.boxes.HandlerBox;\n\n//add NAN\nmp4lib.boxes.HandlerBox.prototype.HANDLERTYPEVIDEO = \"vide\";\nmp4lib.boxes.HandlerBox.prototype.HANDLERTYPEAUDIO = \"soun\";\nmp4lib.boxes.HandlerBox.prototype.HANDLERTYPETEXT = \"meta\";\nmp4lib.boxes.HandlerBox.prototype.HANDLERVIDEONAME = \"Video Track\";\nmp4lib.boxes.HandlerBox.prototype.HANDLERAUDIONAME = \"Audio Track\";\nmp4lib.boxes.HandlerBox.prototype.HANDLERTEXTNAME = \"Text Track\";\n\nmp4lib.boxes.HandlerBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_UINT32.getLength() * 2 + mp4lib.fields.FIELD_UINT32.getLength() * 3 +\n        mp4lib.fields.FIELD_STRING.getLength(this.name);\n};\n\nmp4lib.boxes.HandlerBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    this.pre_defined = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    this.handler_type = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    this.reserved = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT32, 3);\n    this.name = this._readData(data, mp4lib.fields.FIELD_STRING);\n    return this.localPos;\n};\n\nmp4lib.boxes.HandlerBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.pre_defined);\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.handler_type);\n    this._writeArrayData(data, mp4lib.fields.FIELD_UINT32, this.reserved);\n    this._writeData(data, mp4lib.fields.FIELD_STRING, this.name);\n    return this.localPos;\n};\n\n// --------------------------- stts ----------------------------------\nmp4lib.boxes.TimeToSampleBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'stts', size);\n};\n\nmp4lib.boxes.TimeToSampleBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.TimeToSampleBox.prototype.constructor = mp4lib.boxes.TimeToSampleBox;\n\nmp4lib.boxes.TimeToSampleBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_UINT32.getLength();\n    this.size += this.entry_count * (mp4lib.fields.FIELD_UINT32.getLength() * 2);\n};\n\nmp4lib.boxes.TimeToSampleBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n    var i = 0,\n        struct = {};\n\n    this.entry_count = this._readData(data, mp4lib.fields.FIELD_UINT32);\n\n    this.entry = [];\n\n    for (i = 0; i < this.entry_count; i++) {\n        struct = {};\n\n        struct.sample_count = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        struct.sample_delta = this._readData(data, mp4lib.fields.FIELD_UINT32);\n\n        this.entry.push(struct);\n    }\n    return this.localPos;\n};\n\nmp4lib.boxes.TimeToSampleBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n    var i = 0;\n\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry_count);\n\n    for (i = 0; i < this.entry_count; i++) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry[i].sample_count);\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry[i].sample_delta);\n    }\n    return this.localPos;\n};\n\n// --------------------------- stsc ----------------------------------\nmp4lib.boxes.SampleToChunkBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'stsc', size);\n};\n\nmp4lib.boxes.SampleToChunkBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.SampleToChunkBox.prototype.constructor = mp4lib.boxes.SampleToChunkBox;\n\nmp4lib.boxes.SampleToChunkBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_UINT32.getLength();\n    this.size += this.entry_count * (mp4lib.fields.FIELD_UINT32.getLength() * 3);\n};\n\nmp4lib.boxes.SampleToChunkBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n    var i = 0,\n        struct = {};\n\n    this.entry_count = this._readData(data, mp4lib.fields.FIELD_UINT32);\n\n    this.entry = [];\n\n    for (i = 0; i < this.entry_count; i++) {\n        struct = {};\n\n        struct.first_chunk = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        struct.samples_per_chunk = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        struct.samples_description_index = this._readData(data, mp4lib.fields.FIELD_UINT32);\n\n        this.entry.push(struct);\n    }\n    return this.localPos;\n};\n\nmp4lib.boxes.SampleToChunkBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n    var i = 0;\n\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry_count);\n    for (i = 0; i < this.entry_count; i++) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry[i].first_chunk);\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry[i].samples_per_chunk);\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry[i].samples_description_index);\n    }\n    return this.localPos;\n};\n\n// --------------------------- stco ----------------------------------\nmp4lib.boxes.ChunkOffsetBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'stco', size);\n};\n\nmp4lib.boxes.ChunkOffsetBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.ChunkOffsetBox.prototype.constructor = mp4lib.boxes.ChunkOffsetBox;\n\nmp4lib.boxes.ChunkOffsetBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_UINT32.getLength() + this.entry_count * mp4lib.fields.FIELD_UINT32.getLength();\n};\n\nmp4lib.boxes.ChunkOffsetBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    this.entry_count = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    this.chunk_offset = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT32, this.entry_count);\n    return this.localPos;\n};\n\nmp4lib.boxes.ChunkOffsetBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n    var i = 0;\n\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry_count);\n\n    for (i = 0; i < this.entry_count; i++) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.chunk_offset[i]);\n    }\n    return this.localPos;\n};\n\n// --------------------------- trex ----------------------------------\nmp4lib.boxes.TrackExtendsBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'trex', size);\n};\n\nmp4lib.boxes.TrackExtendsBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.TrackExtendsBox.prototype.constructor = mp4lib.boxes.TrackExtendsBox;\n\nmp4lib.boxes.TrackExtendsBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_UINT32.getLength() * 5;\n};\n\nmp4lib.boxes.TrackExtendsBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    this.track_ID = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    this.default_sample_description_index = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    this.default_sample_duration = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    this.default_sample_size = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    this.default_sample_flags = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    return this.localPos;\n};\n\nmp4lib.boxes.TrackExtendsBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.track_ID);\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.default_sample_description_index);\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.default_sample_duration);\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.default_sample_size);\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.default_sample_flags);\n    return this.localPos;\n};\n\n// --------------------------- vmhd ----------------------------------\nmp4lib.boxes.VideoMediaHeaderBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'vmhd', size);\n};\n\nmp4lib.boxes.VideoMediaHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.VideoMediaHeaderBox.prototype.constructor = mp4lib.boxes.VideoMediaHeaderBox;\n\nmp4lib.boxes.VideoMediaHeaderBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_INT16.getLength() + mp4lib.fields.FIELD_UINT16.getLength() * 3;\n};\n\nmp4lib.boxes.VideoMediaHeaderBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    this.graphicsmode = this._readData(data, mp4lib.fields.FIELD_INT16);\n    this.opcolor = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT16, 3);\n    return this.localPos;\n};\n\nmp4lib.boxes.VideoMediaHeaderBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n\n    this._writeData(data, mp4lib.fields.FIELD_INT16, this.graphicsmode);\n    this._writeArrayData(data, mp4lib.fields.FIELD_UINT16, this.opcolor);\n    return this.localPos;\n};\n\n// --------------------------- smhd ----------------------------------\nmp4lib.boxes.SoundMediaHeaderBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'smhd', size);\n};\n\nmp4lib.boxes.SoundMediaHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.SoundMediaHeaderBox.prototype.constructor = mp4lib.boxes.SoundMediaHeaderBox;\n\nmp4lib.boxes.SoundMediaHeaderBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_INT16.getLength() + mp4lib.fields.FIELD_UINT16.getLength();\n};\n\nmp4lib.boxes.SoundMediaHeaderBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    this.balance = this._readData(data, mp4lib.fields.FIELD_INT16);\n    this.reserved = this._readData(data, mp4lib.fields.FIELD_UINT16);\n    return this.localPos;\n};\n\nmp4lib.boxes.SoundMediaHeaderBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n\n    this._writeData(data, mp4lib.fields.FIELD_INT16, this.balance);\n    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.reserved);\n    return this.localPos;\n};\n\n// --------------------------- dref ----------------------------------\nmp4lib.boxes.DataReferenceBox = function(size) {\n    mp4lib.boxes.ContainerFullBox.call(this, 'dref', size);\n};\n\nmp4lib.boxes.DataReferenceBox.prototype = Object.create(mp4lib.boxes.ContainerFullBox.prototype);\nmp4lib.boxes.DataReferenceBox.prototype.constructor = mp4lib.boxes.DataReferenceBox;\n\nmp4lib.boxes.DataReferenceBox.prototype.computeLength = function() {\n    mp4lib.boxes.ContainerFullBox.prototype.computeLength.call(this, true);\n};\n\nmp4lib.boxes.DataReferenceBox.prototype.read = function(data, pos, end) {\n    return mp4lib.boxes.ContainerFullBox.prototype.read.call(this, data, pos, end, true);\n};\n\nmp4lib.boxes.DataReferenceBox.prototype.write = function(data, pos) {\n    if (!this.entry_count) {\n        //if entry_count has not been set, set it to boxes array length\n        this.entry_count = this.boxes.length;\n    }\n    return mp4lib.boxes.ContainerFullBox.prototype.write.call(this, data, pos, true);\n};\n\n// --------------------------- url  ----------------------------------\nmp4lib.boxes.DataEntryUrlBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'url ', size);\n};\n\nmp4lib.boxes.DataEntryUrlBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.DataEntryUrlBox.prototype.constructor = mp4lib.boxes.DataEntryUrlBox;\n\nmp4lib.boxes.DataEntryUrlBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    //NAN : test on location value, not definition, probleme in IE\n    if (this.location !== undefined /*&& this.location !==\"\"*/ ) {\n        //this.flags = this.flags | 1;\n        this.size += mp4lib.fields.FIELD_STRING.getLength(this.location);\n    }\n};\n\nmp4lib.boxes.DataEntryUrlBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    if (this.flags & '0x000001' === 0) {\n        this.location = this._readData(data, mp4lib.fields.FIELD_STRING);\n    }\n\n    return this.localPos;\n};\n\nmp4lib.boxes.DataEntryUrlBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n\n    if (this.location !== undefined /* && this.location !== \"\"*/ ) {\n        this._writeData(data, mp4lib.fields.FIELD_STRING, this.location);\n    }\n    return this.localPos;\n};\n\n// --------------------------- urn  ----------------------------------\nmp4lib.boxes.DataEntryUrnBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'urn ', size);\n};\n\nmp4lib.boxes.DataEntryUrnBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.DataEntryUrnBox.prototype.constructor = mp4lib.boxes.DataEntryUrnBox;\n\nmp4lib.boxes.DataEntryUrnBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    if (this.flags & '0x000001' === 0) {\n        this.size += mp4lib.fields.FIELD_STRING.getLength(this.name) + mp4lib.fields.FIELD_STRING.getLength(this.location);\n    }\n};\n\nmp4lib.boxes.DataEntryUrnBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    if (this.flags & '0x000001' === 0) {\n        this.name = this._readData(data, mp4lib.fields.FIELD_STRING);\n        this.location = this._readData(data, mp4lib.fields.FIELD_STRING);\n    }\n    return this.localPos;\n};\n\nmp4lib.boxes.DataEntryUrnBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n\n    if (this.flags & '0x000001' === 0) {\n        this._writeData(data, mp4lib.fields.FIELD_STRING, this.name);\n        this._writeData(data, mp4lib.fields.FIELD_STRING, this.location);\n    }\n    return this.localPos;\n};\n\n// --------------------------- mfhd ----------------------------------\nmp4lib.boxes.MovieFragmentHeaderBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'mfhd', size);\n};\n\nmp4lib.boxes.MovieFragmentHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.MovieFragmentHeaderBox.prototype.constructor = mp4lib.boxes.MovieFragmentHeaderBox;\n\nmp4lib.boxes.MovieFragmentHeaderBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_UINT32.getLength();\n};\n\nmp4lib.boxes.MovieFragmentHeaderBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n    this.sequence_number = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    return this.localPos;\n};\n\nmp4lib.boxes.MovieFragmentHeaderBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.sequence_number);\n    return this.localPos;\n};\n\n// --------------------------- tfhd ----------------------------------\nmp4lib.boxes.TrackFragmentHeaderBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'tfhd', size);\n};\n\nmp4lib.boxes.TrackFragmentHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.TrackFragmentHeaderBox.prototype.constructor = mp4lib.boxes.TrackFragmentHeaderBox;\n\nmp4lib.boxes.TrackFragmentHeaderBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_UINT32.getLength();\n    //even if, for example base_data_offset is defined, test the flags value\n    //to know if base_data_offset size should be added to global size.\n    if ((this.flags & 0x000001) !== 0 && this.base_data_offset !== undefined) {\n        this.size += mp4lib.fields.FIELD_UINT64.getLength();\n    }\n    if ((this.flags & 0x000002) !== 0 && this.sample_description_index !== undefined) {\n        this.size += mp4lib.fields.FIELD_UINT32.getLength();\n    }\n    if ((this.flags & 0x000008) !== 0 && this.default_sample_duration !== undefined) {\n        this.size += mp4lib.fields.FIELD_UINT32.getLength();\n    }\n    if ((this.flags & 0x000010) !== 0 && this.default_sample_size !== undefined) {\n        this.size += mp4lib.fields.FIELD_UINT32.getLength();\n    }\n    if ((this.flags & 0x000020) !== 0 && this.default_sample_flags !== undefined) {\n        this.size += mp4lib.fields.FIELD_UINT32.getLength();\n    }\n};\n\nmp4lib.boxes.TrackFragmentHeaderBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    this.track_ID = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    if ((this.flags & 0x000001) !== 0) {\n        this.base_data_offset = this._readData(data, mp4lib.fields.FIELD_UINT64);\n    }\n    if ((this.flags & 0x000002) !== 0) {\n        this.sample_description_index = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    }\n    if ((this.flags & 0x000008) !== 0) {\n        this.default_sample_duration = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    }\n    if ((this.flags & 0x000010) !== 0) {\n        this.default_sample_size = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    }\n    if ((this.flags & 0x000020) !== 0) {\n        this.default_sample_flags = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    }\n    return this.localPos;\n};\n\nmp4lib.boxes.TrackFragmentHeaderBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.track_ID);\n\n    if ((this.flags & 0x000001) !== 0) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.base_data_offset);\n    }\n    if ((this.flags & 0x000002) !== 0) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.sample_description_index);\n    }\n    if ((this.flags & 0x000008) !== 0) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.default_sample_duration);\n    }\n    if ((this.flags & 0x000010) !== 0) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.default_sample_size);\n    }\n    if ((this.flags & 0x000020) !== 0) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.default_sample_flags);\n    }\n    return this.localPos;\n};\n\n// --------------------------- tfdt ----------------------------------\nmp4lib.boxes.TrackFragmentBaseMediaDecodeTimeBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'tfdt', size);\n};\n\nmp4lib.boxes.TrackFragmentBaseMediaDecodeTimeBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.TrackFragmentBaseMediaDecodeTimeBox.prototype.constructor = mp4lib.boxes.TrackFragmentBaseMediaDecodeTimeBox;\n\nmp4lib.boxes.TrackFragmentBaseMediaDecodeTimeBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    if (this.version === 1) {\n        this.size += mp4lib.fields.FIELD_UINT64.getLength();\n    } else {\n        this.size += mp4lib.fields.FIELD_UINT32.getLength();\n    }\n};\n\nmp4lib.boxes.TrackFragmentBaseMediaDecodeTimeBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    if (this.version === 1) {\n        this.baseMediaDecodeTime = this._readData(data, mp4lib.fields.FIELD_UINT64);\n    } else {\n        this.baseMediaDecodeTime = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    }\n    return this.localPos;\n};\n\nmp4lib.boxes.TrackFragmentBaseMediaDecodeTimeBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n\n    if (this.version === 1) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.baseMediaDecodeTime);\n    } else {\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.baseMediaDecodeTime);\n    }\n    return this.localPos;\n};\n\n// --------------------------- trun ----------------------------------\nmp4lib.boxes.TrackFragmentRunBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'trun', size);\n};\n\nmp4lib.boxes.TrackFragmentRunBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.TrackFragmentRunBox.prototype.constructor = mp4lib.boxes.TrackFragmentRunBox;\n\nmp4lib.boxes.TrackFragmentRunBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    var i = 0;\n    this.size += mp4lib.fields.FIELD_UINT32.getLength(); //sample_count size\n    if ((this.flags & 0x000001) !== 0 && this.data_offset !== undefined) {\n        this.size += mp4lib.fields.FIELD_INT32.getLength();\n    }\n    if ((this.flags & 0x000004) !== 0 && this.first_sample_flags !== undefined) {\n        this.size += mp4lib.fields.FIELD_UINT32.getLength();\n    }\n\n    for (i = 0; i < this.sample_count; i++) {\n        if ((this.flags & 0x000100) !== 0 && this.samples_table[i].sample_duration !== undefined) {\n            this.size += mp4lib.fields.FIELD_UINT32.getLength();\n        }\n        if ((this.flags & 0x000200) !== 0 && this.samples_table[i].sample_size !== undefined) {\n            this.size += mp4lib.fields.FIELD_UINT32.getLength();\n        }\n        if ((this.flags & 0x000400) !== 0 && this.samples_table[i].sample_flags !== undefined) {\n            this.size += mp4lib.fields.FIELD_UINT32.getLength();\n        }\n\n        if (this.version === 1) {\n            if ((this.flags & 0x000800) !== 0 && this.samples_table[i].sample_composition_time_offset !== undefined) {\n                this.size += mp4lib.fields.FIELD_INT32.getLength();\n            }\n        } else {\n            if ((this.flags & 0x000800) !== 0 && this.samples_table[i].sample_composition_time_offset !== undefined) {\n                this.size += mp4lib.fields.FIELD_UINT32.getLength();\n            }\n        }\n    }\n};\n\nmp4lib.boxes.TrackFragmentRunBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n    var i = 0,\n        struct = {};\n\n    this.sample_count = this._readData(data, mp4lib.fields.FIELD_UINT32);\n\n    if ((this.flags & 0x000001) !== 0) {\n        this.data_offset = this._readData(data, mp4lib.fields.FIELD_INT32);\n    }\n    if ((this.flags & 0x000004) !== 0) {\n        this.first_sample_flags = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    }\n\n    this.samples_table = [];\n\n    for (i = 0; i < this.sample_count; i++) {\n        struct = {};\n        if ((this.flags & 0x000100) !== 0) {\n            struct.sample_duration = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        }\n        if ((this.flags & 0x000200) !== 0) {\n            struct.sample_size = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        }\n        if ((this.flags & 0x000400) !== 0) {\n            struct.sample_flags = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        }\n\n        if (this.version === 1) {\n            if ((this.flags & 0x000800) !== 0) {\n                struct.sample_composition_time_offset = this._readData(data, mp4lib.fields.FIELD_INT32);\n            }\n        } else {\n            if ((this.flags & 0x000800) !== 0) {\n                struct.sample_composition_time_offset = this._readData(data, mp4lib.fields.FIELD_UINT32);\n            }\n        }\n        this.samples_table.push(struct);\n    }\n    return this.localPos;\n};\n\nmp4lib.boxes.TrackFragmentRunBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n    var i = 0;\n\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.sample_count);\n\n    if ((this.flags & 0x000001) !== 0) {\n        this._writeData(data, mp4lib.fields.FIELD_INT32, this.data_offset);\n    }\n    if ((this.flags & 0x000004) !== 0) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.first_sample_flags);\n    }\n\n    for (i = 0; i < this.sample_count; i++) {\n\n        if ((this.flags & 0x000100) !== 0) {\n            this._writeData(data, mp4lib.fields.FIELD_UINT32, this.samples_table[i].sample_duration);\n        }\n        if ((this.flags & 0x000200) !== 0) {\n            this._writeData(data, mp4lib.fields.FIELD_UINT32, this.samples_table[i].sample_size);\n        }\n        if ((this.flags & 0x000400) !== 0) {\n            this._writeData(data, mp4lib.fields.FIELD_UINT32, this.samples_table[i].sample_flags);\n        }\n\n        if (this.version === 1) {\n            if ((this.flags & 0x000800) !== 0) {\n                this._writeData(data, mp4lib.fields.FIELD_INT32, this.samples_table[i].sample_composition_time_offset);\n            }\n        } else {\n            if ((this.flags & 0x000800) !== 0) {\n                this._writeData(data, mp4lib.fields.FIELD_UINT32, this.samples_table[i].sample_composition_time_offset);\n            }\n        }\n    }\n    return this.localPos;\n};\n\n// --------------------------- stsd ----------------------------------\nmp4lib.boxes.SampleDescriptionBox = function(size) {\n    mp4lib.boxes.ContainerFullBox.call(this, 'stsd', size);\n};\n\nmp4lib.boxes.SampleDescriptionBox.prototype = Object.create(mp4lib.boxes.ContainerFullBox.prototype);\nmp4lib.boxes.SampleDescriptionBox.prototype.constructor = mp4lib.boxes.SampleDescriptionBox;\n\nmp4lib.boxes.SampleDescriptionBox.prototype.computeLength = function() {\n    mp4lib.boxes.ContainerFullBox.prototype.computeLength.call(this, true);\n};\n\nmp4lib.boxes.SampleDescriptionBox.prototype.read = function(data, pos, end) {\n    return mp4lib.boxes.ContainerFullBox.prototype.read.call(this, data, pos, end, true);\n};\n\nmp4lib.boxes.SampleDescriptionBox.prototype.write = function(data, pos) {\n    this.entry_count = this.boxes.length;\n    return mp4lib.boxes.ContainerFullBox.prototype.write.call(this, data, pos, true);\n};\n\n// --------------------------- sdtp ----------------------------------\nmp4lib.boxes.SampleDependencyTableBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'sdtp', size);\n};\n\nmp4lib.boxes.SampleDependencyTableBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.SampleDependencyTableBox.prototype.constructor = mp4lib.boxes.SampleDependencyTableBox;\n\nmp4lib.boxes.SampleDependencyTableBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_UINT8.getLength() * this.sample_dependency_table.length;\n};\n\nmp4lib.boxes.SampleDependencyTableBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n    this.sample_dependency_table = this._readArrayData(data, mp4lib.fields.FIELD_UINT8);\n    return this.localPos;\n};\n\nmp4lib.boxes.SampleDependencyTableBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n\n    this._writeArrayData(data, mp4lib.fields.FIELD_UINT8, this.sample_dependency_table);\n    return this.localPos;\n};\n\n// --------------------------- abstract SampleEntry ----------------------------------\nmp4lib.boxes.SampleEntryBox = function(boxType, size) {\n    mp4lib.boxes.Box.call(this, boxType, size);\n};\n\nmp4lib.boxes.SampleEntryBox.prototype = Object.create(mp4lib.boxes.Box.prototype);\nmp4lib.boxes.SampleEntryBox.prototype.constructor = mp4lib.boxes.SampleEntryBox;\n\nmp4lib.boxes.SampleEntryBox.prototype.computeLength = function() {\n    mp4lib.boxes.Box.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_UINT16.getLength() + mp4lib.fields.FIELD_UINT8.getLength() * 6;\n};\n\nmp4lib.boxes.SampleEntryBox.prototype.read = function(data, pos, end) {\n    this.localPos = pos;\n    this.localEnd = end;\n\n    this.reserved = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT8, 6);\n    this.data_reference_index = this._readData(data, mp4lib.fields.FIELD_UINT16);\n    return this.localPos;\n};\n\nmp4lib.boxes.SampleEntryBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.Box.prototype.write.call(this, data, pos);\n\n    this._writeArrayData(data, mp4lib.fields.FIELD_UINT8, this.reserved);\n    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.data_reference_index);\n    return this.localPos;\n};\n\n// --------------------------- abstract VisualSampleEntry ----------------------------------\nmp4lib.boxes.VisualSampleEntryBox = function(boxType, size) {\n    mp4lib.boxes.SampleEntryBox.call(this, boxType, size);\n};\n\nmp4lib.boxes.VisualSampleEntryBox.prototype = Object.create(mp4lib.boxes.SampleEntryBox.prototype);\nmp4lib.boxes.VisualSampleEntryBox.prototype.constructor = mp4lib.boxes.VisualSampleEntryBox;\n\nmp4lib.boxes.VisualSampleEntryBox.prototype.computeLength = function() {\n    mp4lib.boxes.SampleEntryBox.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_UINT16.getLength() * 7 + mp4lib.fields.FIELD_UINT32.getLength() * 3;\n    this.size += mp4lib.fields.FIELD_UINT32.getLength() * 3;\n    this.size += 32; //compressorname size\n};\n\nmp4lib.boxes.VisualSampleEntryBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.SampleEntryBox.prototype.read.call(this, data, pos, end);\n    this.pre_defined = this._readData(data, mp4lib.fields.FIELD_UINT16);\n    this.reserved_2 = this._readData(data, mp4lib.fields.FIELD_UINT16);\n    // there is already field called reserved from SampleEntry, so we need to call it reserved_2\n    this.pre_defined_2 = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT32, 3);\n    this.width = this._readData(data, mp4lib.fields.FIELD_UINT16);\n    this.height = this._readData(data, mp4lib.fields.FIELD_UINT16);\n    this.horizresolution = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    this.vertresolution = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    this.reserved_3 = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    this.frame_count = this._readData(data, mp4lib.fields.FIELD_UINT16);\n    this.compressorname = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT8, 32);\n    this.depth = this._readData(data, mp4lib.fields.FIELD_UINT16);\n    this.pre_defined_3 = this._readData(data, mp4lib.fields.FIELD_INT16);\n    return this.localPos;\n};\n\nmp4lib.boxes.VisualSampleEntryBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.SampleEntryBox.prototype.write.call(this, data, pos);\n\n    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.pre_defined);\n    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.reserved_2);\n    // there is already field called reserved from SampleEntry, so we need to call it reserved_2\n    this._writeArrayData(data, mp4lib.fields.FIELD_UINT32, this.pre_defined_2);\n    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.width);\n    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.height);\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.horizresolution);\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.vertresolution);\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.reserved_3);\n    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.frame_count);\n    this._writeArrayData(data, mp4lib.fields.FIELD_UINT8, this.compressorname);\n    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.depth);\n    this._writeData(data, mp4lib.fields.FIELD_INT16, this.pre_defined_3);\n    return this.localPos;\n};\n\n// --------------------------- abstract VisualSampleEntryContainer ----------------------------------\nmp4lib.boxes.VisualSampleEntryContainerBox = function(boxType, size) {\n    mp4lib.boxes.VisualSampleEntryBox.call(this, boxType, size);\n    this.boxes = [];\n};\n\nmp4lib.boxes.VisualSampleEntryContainerBox.prototype = Object.create(mp4lib.boxes.VisualSampleEntryBox.prototype);\nmp4lib.boxes.VisualSampleEntryContainerBox.prototype.constructor = mp4lib.boxes.VisualSampleEntryContainerBox;\n\nmp4lib.boxes.VisualSampleEntryContainerBox.prototype.computeLength = function() {\n    mp4lib.boxes.VisualSampleEntryBox.prototype.computeLength.call(this);\n    var i = 0;\n    for (i = 0; i < this.boxes.length; i++) {\n        this.boxes[i].computeLength();\n        this.size += this.boxes[i].size;\n    }\n};\n\nmp4lib.boxes.VisualSampleEntryContainerBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.VisualSampleEntryBox.prototype.read.call(this, data, pos, end);\n\n    var size = 0,\n        uuidFieldPos = 0,\n        uuid = null,\n        boxtype,\n        box;\n\n    while (this.localPos < this.localEnd) {\n        // Read box size\n        size = mp4lib.fields.FIELD_UINT32.read(data, this.localPos);\n\n        // Read boxtype\n        boxtype = mp4lib.fields.readString(data, this.localPos + 4, 4);\n\n        // Extented type?\n        if (boxtype == \"uuid\") {\n            uuidFieldPos = (size == 1) ? 16 : 8;\n            uuid = new mp4lib.fields.ArrayField(mp4lib.fields.FIELD_INT8, 16).read(data, this.localPos + uuidFieldPos, this.localPos + uuidFieldPos + 16);\n            uuid = JSON.stringify(uuid);\n        }\n\n        box = mp4lib.createBox(boxtype, size, uuid);\n        if (boxtype === \"uuid\") {\n            this.localPos = box.read(data, this.localPos + mp4lib.fields.FIELD_INT8.getLength() * 16 + 8, this.localPos + size);\n        } else {\n            this.localPos = box.read(data, this.localPos + 8, this.localPos + size);\n        }\n\n        // in debug mode, sourcebuffer is copied to each box,\n        // so any invalid deserializations may be found by comparing\n        // source buffer with serialized box\n        if (mp4lib.debug) {\n            box.__sourceBuffer = data.subarray(this.localPos - box.size, this.localPos);\n        }\n\n        this.boxes.push(box);\n\n        if (box.size <= 0 || box.size === null) {\n            throw new mp4lib.ParseException('Problem on size of box ' + box.boxtype +\n                ', parsing stopped to avoid infinite loop');\n        }\n\n        if (!box.boxtype) {\n            throw new mp4lib.ParseException('Problem on unknown box, parsing stopped to avoid infinite loop');\n        }\n    }\n    return this.localPos;\n};\n\nmp4lib.boxes.VisualSampleEntryContainerBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.VisualSampleEntryBox.prototype.write.call(this, data, pos);\n    var i = 0;\n\n    for (i = 0; i < this.boxes.length; i++) {\n        this.localPos = this.boxes[i].write(data, this.localPos);\n    }\n    return this.localPos;\n};\n\n// --------------------------- avc1 ----------------------------------\nmp4lib.boxes.AVC1VisualSampleEntryBox = function(size) {\n    mp4lib.boxes.VisualSampleEntryContainerBox.call(this, 'avc1', size);\n};\n\nmp4lib.boxes.AVC1VisualSampleEntryBox.prototype = Object.create(mp4lib.boxes.VisualSampleEntryContainerBox.prototype);\nmp4lib.boxes.AVC1VisualSampleEntryBox.prototype.constructor = mp4lib.boxes.AVC1VisualSampleEntryBox;\n\n//-------------------------- encv ------------------------------------\nmp4lib.boxes.EncryptedVideoBox = function(size) {\n    mp4lib.boxes.VisualSampleEntryContainerBox.call(this, 'encv', size);\n};\n\nmp4lib.boxes.EncryptedVideoBox.prototype = Object.create(mp4lib.boxes.VisualSampleEntryContainerBox.prototype);\nmp4lib.boxes.EncryptedVideoBox.prototype.constructor = mp4lib.boxes.EncryptedVideoBox;\n\n// --------------------------- avcc ----------------------------------\nmp4lib.boxes.AVCConfigurationBox = function(size) {\n    mp4lib.boxes.Box.call(this, 'avcC', size);\n};\n\nmp4lib.boxes.AVCConfigurationBox.prototype = Object.create(mp4lib.boxes.Box.prototype);\nmp4lib.boxes.AVCConfigurationBox.prototype.constructor = mp4lib.boxes.AVCConfigurationBox;\n\nmp4lib.boxes.AVCConfigurationBox.prototype.computeLength = function() {\n    mp4lib.boxes.Box.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_UINT8.getLength() * 4 + mp4lib.fields.FIELD_UINT8.getLength() * 3;\n    this.size += this._getNALLength(this.numOfSequenceParameterSets, this.SPS_NAL);\n    this.size += this._getNALLength(this.numOfPictureParameterSets, this.PPS_NAL);\n};\n\nmp4lib.boxes.AVCConfigurationBox.prototype._getNALLength = function(nbElements, nalArray) {\n    var size_NAL = 0,\n        i = 0;\n\n    for (i = 0; i < nbElements; i++) {\n        size_NAL += mp4lib.fields.FIELD_UINT16.getLength() + nalArray[i].NAL_length;\n    }\n\n    return size_NAL;\n};\n\nmp4lib.boxes.AVCConfigurationBox.prototype.read = function(data, pos, end) {\n    this.localPos = pos;\n    this.localEnd = end;\n    this.configurationVersion = this._readData(data, mp4lib.fields.FIELD_UINT8);\n    this.AVCProfileIndication = this._readData(data, mp4lib.fields.FIELD_UINT8);\n    this.profile_compatibility = this._readData(data, mp4lib.fields.FIELD_UINT8);\n    this.AVCLevelIndication = this._readData(data, mp4lib.fields.FIELD_UINT8);\n\n    this.temp = this._readData(data, mp4lib.fields.FIELD_UINT8);\n    // 6 bits for reserved =63 and two bits for NAL length = 2-bit length byte size type\n    this.lengthSizeMinusOne = this.temp & 3;\n    this.numOfSequenceParameterSets_tmp = this._readData(data, mp4lib.fields.FIELD_UINT8);\n    this.numOfSequenceParameterSets = this.numOfSequenceParameterSets_tmp & 31;\n\n    this.SPS_NAL = this._readNAL(data, this.numOfSequenceParameterSets);\n\n    this.numOfPictureParameterSets = this._readData(data, mp4lib.fields.FIELD_UINT8);\n\n    this.PPS_NAL = this._readNAL(data, this.numOfPictureParameterSets);\n    return this.localPos;\n};\n\nmp4lib.boxes.AVCConfigurationBox.prototype._readNAL = function(data, nbElements) {\n    var nalArray = [],\n        i = 0,\n        struct = {};\n\n    for (i = 0; i < nbElements; i++) {\n        struct = {};\n\n        struct.NAL_length = this._readData(data, mp4lib.fields.FIELD_UINT16);\n        struct.NAL = data.subarray(this.localPos, this.localPos + struct.NAL_length);\n        this.localPos += struct.NAL_length;\n        nalArray.push(struct);\n    }\n    return nalArray;\n};\n\nmp4lib.boxes.AVCConfigurationBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.Box.prototype.write.call(this, data, pos);\n\n    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.configurationVersion);\n    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.AVCProfileIndication);\n    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.profile_compatibility);\n    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.AVCLevelIndication);\n\n    this.temp = this.lengthSizeMinusOne | 252;\n    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.temp);\n    this.numOfSequenceParameterSets = this.SPS_NAL.length;\n    this.numOfSequenceParameterSets_tmp = this.numOfSequenceParameterSets | 224;\n    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.numOfSequenceParameterSets_tmp);\n    this._writeNAL(data, this.numOfSequenceParameterSets, this.SPS_NAL);\n    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.numOfPictureParameterSets);\n    this._writeNAL(data, this.numOfPictureParameterSets, this.PPS_NAL);\n    return this.localPos;\n};\n\nmp4lib.boxes.AVCConfigurationBox.prototype._writeNAL = function(data, nbElements, nalArray) {\n    var i = 0;\n\n    for (i = 0; i < nbElements; i++) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT16, nalArray[i].NAL_length);\n        this._writeBuffer(data, nalArray[i].NAL, nalArray[i].NAL_length);\n    }\n};\n\n// --------------------------- pasp ----------------------------------\nmp4lib.boxes.PixelAspectRatioBox = function(size) {\n    mp4lib.boxes.Box.call(this, 'pasp', size);\n};\n\nmp4lib.boxes.PixelAspectRatioBox.prototype = Object.create(mp4lib.boxes.Box.prototype);\nmp4lib.boxes.PixelAspectRatioBox.prototype.constructor = mp4lib.boxes.PixelAspectRatioBox;\n\nmp4lib.boxes.PixelAspectRatioBox.prototype.computeLength = function() {\n    mp4lib.boxes.Box.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_INT32.getLength() * 2;\n};\n\nmp4lib.boxes.PixelAspectRatioBox.prototype.read = function(data, pos, end) {\n    this.localPos = pos;\n    this.localEnd = end;\n\n    this.hSpacing = this._readData(data, mp4lib.fields.FIELD_INT32);\n    this.vSpacing = this._readData(data, mp4lib.fields.FIELD_INT32);\n    return this.localPos;\n};\n\nmp4lib.boxes.PixelAspectRatioBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.Box.prototype.write.call(this, data, pos);\n\n    this._writeData(data, mp4lib.fields.FIELD_INT32, this.hSpacing);\n    this._writeData(data, mp4lib.fields.FIELD_INT32, this.vSpacing);\n    return this.localPos;\n};\n\n// --------------------------- abstract VisualSampleEntry ----------------------------------\nmp4lib.boxes.AudioSampleEntryBox = function(boxType, size) {\n    mp4lib.boxes.SampleEntryBox.call(this, boxType, size);\n};\n\nmp4lib.boxes.AudioSampleEntryBox.prototype = Object.create(mp4lib.boxes.SampleEntryBox.prototype);\nmp4lib.boxes.AudioSampleEntryBox.prototype.constructor = mp4lib.boxes.AudioSampleEntryBox;\n\nmp4lib.boxes.AudioSampleEntryBox.prototype.computeLength = function() {\n    mp4lib.boxes.SampleEntryBox.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_UINT16.getLength() * 4 + mp4lib.fields.FIELD_UINT32.getLength() * 3;\n};\n\nmp4lib.boxes.AudioSampleEntryBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.SampleEntryBox.prototype.read.call(this, data, pos, end);\n\n    this.reserved_2 = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT32, 2);\n    this.channelcount = this._readData(data, mp4lib.fields.FIELD_UINT16);\n    this.samplesize = this._readData(data, mp4lib.fields.FIELD_UINT16);\n    this.pre_defined = this._readData(data, mp4lib.fields.FIELD_UINT16);\n    this.reserved_3 = this._readData(data, mp4lib.fields.FIELD_UINT16);\n    this.samplerate = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    return this.localPos;\n};\n\nmp4lib.boxes.AudioSampleEntryBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.SampleEntryBox.prototype.write.call(this, data, pos);\n\n    this._writeArrayData(data, mp4lib.fields.FIELD_UINT32, this.reserved_2);\n    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.channelcount);\n    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.samplesize);\n    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.pre_defined);\n    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.reserved_3);\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.samplerate);\n    return this.localPos;\n};\n\n// --------------------------- abstract AudioSampleEntryContainer ----------------------------------\nmp4lib.boxes.AudioSampleEntryContainerBox = function(boxType, size) {\n    mp4lib.boxes.AudioSampleEntryBox.call(this, boxType, size);\n    this.boxes = [];\n};\n\nmp4lib.boxes.AudioSampleEntryContainerBox.prototype = Object.create(mp4lib.boxes.AudioSampleEntryBox.prototype);\nmp4lib.boxes.AudioSampleEntryContainerBox.prototype.constructor = mp4lib.boxes.AudioSampleEntryContainerBox;\n\nmp4lib.boxes.AudioSampleEntryContainerBox.prototype.computeLength = function() {\n    mp4lib.boxes.AudioSampleEntryBox.prototype.computeLength.call(this);\n    var i = 0;\n    for (i = 0; i < this.boxes.length; i++) {\n        this.boxes[i].computeLength();\n        this.size += this.boxes[i].size;\n    }\n};\n\nmp4lib.boxes.AudioSampleEntryContainerBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.AudioSampleEntryBox.prototype.read.call(this, data, pos, end);\n\n    var size = 0,\n        uuidFieldPos = 0,\n        uuid = null,\n        boxtype,\n        box;\n\n    while (this.localPos < this.localEnd) {\n        // Read box size\n        size = mp4lib.fields.FIELD_UINT32.read(data, this.localPos);\n\n        // Read boxtype\n        boxtype = mp4lib.fields.readString(data, this.localPos + 4, 4);\n\n        // Extented type?\n        if (boxtype == \"uuid\") {\n            uuidFieldPos = (size == 1) ? 16 : 8;\n            uuid = new mp4lib.fields.ArrayField(mp4lib.fields.FIELD_INT8, 16).read(data, this.localPos + uuidFieldPos, this.localPos + uuidFieldPos + 16);\n            uuid = JSON.stringify(uuid);\n        }\n\n        box = mp4lib.createBox(boxtype, size, uuid);\n        if (boxtype === \"uuid\") {\n            this.localPos = box.read(data, this.localPos + mp4lib.fields.FIELD_INT8.getLength() * 16 + 8, this.localPos + size);\n        } else {\n            this.localPos = box.read(data, this.localPos + 8, this.localPos + size);\n        }\n\n        // in debug mode, sourcebuffer is copied to each box,\n        // so any invalid deserializations may be found by comparing\n        // source buffer with serialized box\n        if (mp4lib.debug) {\n            box.__sourceBuffer = data.subarray(this.localPos - box.size, this.localPos);\n        }\n\n        this.boxes.push(box);\n\n        if (box.size <= 0 || box.size === null) {\n            throw new mp4lib.ParseException('Problem on size of box ' + box.boxtype +\n                ', parsing stopped to avoid infinite loop');\n        }\n\n        if (!box.boxtype) {\n            throw new mp4lib.ParseException('Problem on unknown box, parsing stopped to avoid infinite loop');\n        }\n    }\n    return this.localPos;\n};\n\nmp4lib.boxes.AudioSampleEntryContainerBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.AudioSampleEntryBox.prototype.write.call(this, data, pos);\n    var i = 0;\n\n    for (i = 0; i < this.boxes.length; i++) {\n        this.localPos = this.boxes[i].write(data, this.localPos);\n    }\n    return this.localPos;\n};\n\n// --------------------------- mp4a ----------------------------------\nmp4lib.boxes.MP4AudioSampleEntryBox = function(size) {\n    mp4lib.boxes.AudioSampleEntryContainerBox.call(this, 'mp4a', size);\n};\n\nmp4lib.boxes.MP4AudioSampleEntryBox.prototype = Object.create(mp4lib.boxes.AudioSampleEntryContainerBox.prototype);\nmp4lib.boxes.MP4AudioSampleEntryBox.prototype.constructor = mp4lib.boxes.MP4AudioSampleEntryBox;\n\n//-------------------------- enca ------------------------------------\nmp4lib.boxes.EncryptedAudioBox = function(size) {\n    mp4lib.boxes.AudioSampleEntryContainerBox.call(this, 'enca', size);\n};\n\nmp4lib.boxes.EncryptedAudioBox.prototype = Object.create(mp4lib.boxes.AudioSampleEntryContainerBox.prototype);\nmp4lib.boxes.EncryptedAudioBox.prototype.constructor = mp4lib.boxes.EncryptedAudioBox;\n\n// --------------------------- esds ----------------------------\nmp4lib.boxes.ESDBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'esds', size);\n};\n\nmp4lib.boxes.ESDBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.ESDBox.prototype.constructor = mp4lib.boxes.ESDBox;\n\nmp4lib.boxes.ESDBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_UINT8.getLength() * 2 + this.ES_length;\n};\n\nmp4lib.boxes.ESDBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    this.ES_tag = this._readData(data, mp4lib.fields.FIELD_UINT8);\n    this.ES_length = this._readData(data, mp4lib.fields.FIELD_UINT8);\n    this.ES_data = data.subarray(this.localPos, this.localPos + this.ES_length);\n    this.localPos += this.ES_length;\n    return this.localPos;\n};\n\nmp4lib.boxes.ESDBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n\n    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.ES_tag);\n    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.ES_length);\n    this._writeBuffer(data, this.ES_data, this.ES_length);\n    return this.localPos;\n};\n\n// --------------------------- stsz ----------------------------------\nmp4lib.boxes.SampleSizeBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'stsz', size);\n};\n\nmp4lib.boxes.SampleSizeBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.SampleSizeBox.prototype.constructor = mp4lib.boxes.SampleSizeBox;\n\nmp4lib.boxes.SampleSizeBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_UINT32.getLength() * 2 + mp4lib.fields.FIELD_UINT32.getLength() * this.sample_count;\n};\n\nmp4lib.boxes.SampleSizeBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    this.sample_size = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    this.sample_count = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    this.entries = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT32, this.sample_count);\n    return this.localPos;\n};\n\nmp4lib.boxes.SampleSizeBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n    var i = 0;\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.sample_size);\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.sample_count);\n    for (i = 0; i < this.sample_count; i++) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entries[i]);\n    }\n    return this.localPos;\n};\n\n// ------------------------- pssh ------------------------------------\nmp4lib.boxes.ProtectionSystemSpecificHeaderBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'pssh', size);\n};\n\nmp4lib.boxes.ProtectionSystemSpecificHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.ProtectionSystemSpecificHeaderBox.prototype.constructor = mp4lib.boxes.ProtectionSystemSpecificHeaderBox;\n\nmp4lib.boxes.ProtectionSystemSpecificHeaderBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n\n    this.size += mp4lib.fields.FIELD_UINT8.getLength() * 16;\n    this.size += mp4lib.fields.FIELD_UINT32.getLength();\n    this.size += mp4lib.fields.FIELD_UINT8.getLength() * this.DataSize;\n};\n\nmp4lib.boxes.ProtectionSystemSpecificHeaderBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    this.SystemID = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT8, 16);\n    this.DataSize = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    this.Data = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT8, this.DataSize);\n    return this.localPos;\n};\n\nmp4lib.boxes.ProtectionSystemSpecificHeaderBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n    var i = 0;\n\n    for (i = 0; i < 16; i++) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT8, this.SystemID[i]);\n    }\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.DataSize);\n    for (i = 0; i < this.DataSize; i++) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT8, this.Data[i]);\n    }\n    return this.localPos;\n};\n\n\n// --------------------------- senc ----------------------------------\nmp4lib.boxes.SampleEncryptionBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'senc', size);\n};\n\nmp4lib.boxes.SampleEncryptionBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.SampleEncryptionBox.prototype.constructor = mp4lib.boxes.SampleEncryptionBox;\n\nmp4lib.boxes.SampleEncryptionBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    var i = 0,\n        j = 0;\n\n    this.size += mp4lib.fields.FIELD_UINT32.getLength(); //sample_count size\n    if (this.flags & 1) {\n        this.size += mp4lib.fields.FIELD_UINT8.getLength(); //IV_size size\n    }\n    for (i = 0; i < this.sample_count; i++) {\n        this.size += 8; // InitializationVector size\n        if (this.flags & 2) {\n            this.size += mp4lib.fields.FIELD_UINT16.getLength(); // NumberOfEntries size\n            for (j = 0; j < this.entry[i].NumberOfEntries; j++) {\n                this.size += mp4lib.fields.FIELD_UINT16.getLength(); //BytesOfClearData size\n                this.size += mp4lib.fields.FIELD_UINT32.getLength(); //BytesOfEncryptedData size\n            }\n        }\n    }\n};\n\nmp4lib.boxes.SampleEncryptionBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n    var i = 0,\n        j = 0;\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.sample_count);\n    if (this.flags & 1) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT8, this.IV_size);\n    }\n    for (i = 0; i < this.sample_count; i++) {\n        this._writeBuffer(data, this.entry[i].InitializationVector, 8);\n\n        if (this.flags & 2) {\n            this._writeData(data, mp4lib.fields.FIELD_UINT16, this.entry[i].NumberOfEntries); // NumberOfEntries\n\n            for (j = 0; j < this.entry[i].NumberOfEntries; j++) {\n                this._writeData(data, mp4lib.fields.FIELD_UINT16, this.entry[i].clearAndCryptedData[j].BytesOfClearData); //BytesOfClearData\n                this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry[i].clearAndCryptedData[j].BytesOfEncryptedData); //BytesOfEncryptedData size\n            }\n        }\n    }\n    return this.localPos;\n};\n\nmp4lib.boxes.SampleEncryptionBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n    var i = 0,\n        j = 0,\n        clearAndCryptedStruct = {},\n        struct = {};\n    this.sample_count = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    if (this.flags & 1) {\n        this.IV_size = this._readData(data, mp4lib.fields.FIELD_UINT8);\n    }\n    this.entry = [];\n    for (i = 0; i < this.sample_count; i++) {\n        struct = {};\n        struct.InitializationVector = data.subarray(this.localPos, this.localPos + 8);\n        this.localPos += 8; //InitializationVector size\n\n        if (this.flags & 2) {\n            struct.NumberOfEntries = this._readData(data, mp4lib.fields.FIELD_UINT16); // NumberOfEntries\n            struct.clearAndCryptedData = [];\n            for (j = 0; j < struct.NumberOfEntries; j++) {\n                clearAndCryptedStruct = {};\n                clearAndCryptedStruct.BytesOfClearData = this._readData(data, mp4lib.fields.FIELD_UINT16); //BytesOfClearData\n                clearAndCryptedStruct.BytesOfEncryptedData = this._readData(data, mp4lib.fields.FIELD_UINT32); //BytesOfEncryptedData size\n                struct.clearAndCryptedData.push(clearAndCryptedStruct);\n            }\n        }\n        this.entry.push(struct);\n    }\n    return this.localPos;\n};\n\n// ------------------------- saiz ------------------------------------\nmp4lib.boxes.SampleAuxiliaryInformationSizesBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'saiz', size);\n};\n\nmp4lib.boxes.SampleAuxiliaryInformationSizesBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.SampleAuxiliaryInformationSizesBox.prototype.constructor = mp4lib.boxes.SampleAuxiliaryInformationSizesBox;\n\nmp4lib.boxes.SampleAuxiliaryInformationSizesBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n\n    if (this.flags & 1) {\n        this.size += mp4lib.fields.FIELD_UINT32.getLength() * 2;\n    }\n\n    this.size += mp4lib.fields.FIELD_UINT8.getLength() + mp4lib.fields.FIELD_UINT32.getLength();\n\n    if (this.default_sample_info_size === 0) {\n        this.size += mp4lib.fields.FIELD_UINT8.getLength() * this.sample_count;\n    }\n};\n\nmp4lib.boxes.SampleAuxiliaryInformationSizesBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    if (this.flags & 1) {\n        this.aux_info_type = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        this.aux_info_type_parameter = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    }\n    this.default_sample_info_size = this._readData(data, mp4lib.fields.FIELD_UINT8);\n    this.sample_count = this._readData(data, mp4lib.fields.FIELD_UINT32);\n\n    if (this.default_sample_info_size === 0) {\n        this.sample_info_size = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT8, this.sample_count);\n    }\n    return this.localPos;\n};\n\nmp4lib.boxes.SampleAuxiliaryInformationSizesBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n    var i = 0;\n    if (this.flags & 1) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.aux_info_type);\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.aux_info_type_parameter);\n    }\n    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.default_sample_info_size);\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.sample_count);\n    if (this.default_sample_info_size === 0) {\n        for (i = 0; i < this.sample_count; i++) {\n            this._writeData(data, mp4lib.fields.FIELD_UINT8, this.sample_info_size[i]);\n        }\n    }\n    return this.localPos;\n};\n\n//------------------------- saio ------------------------------------\nmp4lib.boxes.SampleAuxiliaryInformationOffsetsBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'saio', size);\n};\n\nmp4lib.boxes.SampleAuxiliaryInformationOffsetsBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.SampleAuxiliaryInformationOffsetsBox.prototype.constructor = mp4lib.boxes.SampleAuxiliaryInformationOffsetsBox;\n\nmp4lib.boxes.SampleAuxiliaryInformationOffsetsBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    if (this.flags & 1) {\n        this.size += mp4lib.fields.FIELD_UINT32.getLength() * 2;\n    }\n    this.size += mp4lib.fields.FIELD_UINT32.getLength(); /*entry_count size */\n    if (this.version === 0) {\n        this.size += mp4lib.fields.FIELD_UINT32.getLength() * this.entry_count;\n    } else {\n        this.size += mp4lib.fields.FIELD_UINT64.getLength() * this.entry_count;\n    }\n};\n\nmp4lib.boxes.SampleAuxiliaryInformationOffsetsBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    if (this.flags & 1) {\n        this.aux_info_type = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        this.aux_info_type_parameter = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    }\n\n    this.entry_count = this._readData(data, mp4lib.fields.FIELD_UINT32);\n\n    if (this.version === 0) {\n        this.offset = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT32, this.entry_count);\n    } else {\n        this.offset = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT64, this.entry_count);\n    }\n    return this.localPos;\n};\n\nmp4lib.boxes.SampleAuxiliaryInformationOffsetsBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n\n    var i = 0;\n    if (this.flags & 1) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.aux_info_type);\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.aux_info_type_parameter);\n    }\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry_count);\n    if (this.version === 0) {\n        for (i = 0; i < this.entry_count; i++) {\n            this._writeData(data, mp4lib.fields.FIELD_UINT32, this.offset[i]);\n        }\n    } else {\n        for (i = 0; i < this.entry_count; i++) {\n            this._writeData(data, mp4lib.fields.FIELD_UINT64, this.offset[i]);\n        }\n    }\n    return this.localPos;\n};\n\n//------------------------- sinf ------------------------------------\nmp4lib.boxes.ProtectionSchemeInformationBox = function(size) {\n    mp4lib.boxes.ContainerBox.call(this, 'sinf', size);\n};\n\nmp4lib.boxes.ProtectionSchemeInformationBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);\nmp4lib.boxes.ProtectionSchemeInformationBox.prototype.constructor = mp4lib.boxes.ProtectionSchemeInformationBox;\n\n//------------------------ schi --------------------------------------\nmp4lib.boxes.SchemeInformationBox = function(size) {\n    mp4lib.boxes.ContainerBox.call(this, 'schi', size);\n};\n\nmp4lib.boxes.SchemeInformationBox.prototype = Object.create(mp4lib.boxes.ContainerBox.prototype);\nmp4lib.boxes.SchemeInformationBox.prototype.constructor = mp4lib.boxes.SchemeInformationBox;\n\n//------------------------ tenc --------------------------------------\nmp4lib.boxes.TrackEncryptionBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'tenc', size);\n};\n\nmp4lib.boxes.TrackEncryptionBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.TrackEncryptionBox.prototype.constructor = mp4lib.boxes.TrackEncryptionBox;\n\nmp4lib.boxes.TrackEncryptionBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n\n    this.size += mp4lib.fields.FIELD_BIT24.getLength();\n    this.size += mp4lib.fields.FIELD_UINT8.getLength();\n    this.size += mp4lib.fields.FIELD_UINT8.getLength() * 16;\n};\n\nmp4lib.boxes.TrackEncryptionBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    this.default_IsEncrypted = this._readData(data, mp4lib.fields.FIELD_BIT24);\n    this.default_IV_size = this._readData(data, mp4lib.fields.FIELD_UINT8);\n    this.default_KID = this._readArrayFieldData(data, mp4lib.fields.FIELD_UINT8, 16);\n    return this.localPos;\n};\n\nmp4lib.boxes.TrackEncryptionBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n\n    this._writeData(data, mp4lib.fields.FIELD_BIT24, this.default_IsEncrypted);\n    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.default_IV_size);\n    this._writeArrayData(data, mp4lib.fields.FIELD_UINT8, this.default_KID);\n    return this.localPos;\n};\n\n//------------------------- schm -------------------------------------\nmp4lib.boxes.SchemeTypeBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'schm', size);\n};\n\nmp4lib.boxes.SchemeTypeBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.SchemeTypeBox.prototype.constructor = mp4lib.boxes.SchemeTypeBox;\n\nmp4lib.boxes.SchemeTypeBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n\n    this.size += mp4lib.fields.FIELD_UINT32.getLength() * 2;\n    if (this.flags & 0x000001) {\n        this.size += mp4lib.fields.FIELD_STRING.getLength(this.scheme_uri);\n    }\n};\n\nmp4lib.boxes.SchemeTypeBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    this.scheme_type = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    this.scheme_version = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    if (this.flags & 0x000001) {\n        this.scheme_uri = this._readData(data, mp4lib.fields.FIELD_STRING);\n    }\n    return this.localPos;\n};\n\nmp4lib.boxes.SchemeTypeBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.scheme_type);\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.scheme_version);\n    if (this.flags & 0x000001) {\n        this._writeData(data, mp4lib.fields.FIELD_STRING, this.scheme_uri);\n    }\n    return this.localPos;\n};\n\n// --------------------------- elst ----------------------------------\nmp4lib.boxes.EditListBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'elst', size);\n    this.entries = [];\n};\n\nmp4lib.boxes.EditListBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.EditListBox.prototype.constructor = mp4lib.boxes.EditListBox;\n\nmp4lib.boxes.EditListBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n\n    this.size += mp4lib.fields.FIELD_UINT32.getLength(); //entry_count size\n\n    if (this.version === 1) {\n        this.size += (mp4lib.fields.FIELD_UINT64.getLength() * 2 /*segment_duration and media_time size*/ +\n            mp4lib.fields.FIELD_UINT16.getLength() * 2 /*media_rate_integer and media_rate_fraction size)*/ ) * this.entry_count;\n    } else { // version==0\n        this.size += (mp4lib.fields.FIELD_UINT32.getLength() * 2 /*segment_duration and media_time size*/ +\n            mp4lib.fields.FIELD_UINT16.getLength() * 2 /*media_rate_integer and media_rate_fraction size)*/ ) * this.entry_count;\n    }\n};\n\nmp4lib.boxes.EditListBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n    var i = 0,\n        struct = {};\n    this.entry_count = this._readData(data, mp4lib.fields.FIELD_UINT32);\n\n    for (i = 0; i < this.entry_count; i++) {\n        struct = {};\n        if (this.version === 1) {\n            struct.segment_duration = this._readData(data, mp4lib.fields.FIELD_UINT64);\n            struct.media_time = this._readData(data, mp4lib.fields.FIELD_UINT64);\n        } else { // version==0\n            struct.segment_duration = this._readData(data, mp4lib.fields.FIELD_UINT32);\n            struct.media_time = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        }\n        struct.media_rate_integer = this._readData(data, mp4lib.fields.FIELD_UINT16);\n        struct.media_rate_fraction = this._readData(data, mp4lib.fields.FIELD_UINT16);\n        this.entries.push(struct);\n    }\n    return this.localPos;\n};\n\nmp4lib.boxes.EditListBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n    var i = 0;\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry_count);\n    for (i = 0; i < this.entry_count; i++) {\n\n        if (this.version === 1) {\n            this._writeData(data, mp4lib.fields.FIELD_UINT64, this.entries[i].segment_duration);\n            this._writeData(data, mp4lib.fields.FIELD_UINT64, this.entries[i].media_time);\n        } else { // version==0\n            this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entries[i].segment_duration);\n            this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entries[i].media_time);\n        }\n        this._writeData(data, mp4lib.fields.FIELD_UINT16, this.entries[i].media_rate_integer);\n        this._writeData(data, mp4lib.fields.FIELD_UINT16, this.entries[i].media_rate_fraction);\n    }\n    return this.localPos;\n};\n\n// --------------------------- hmhd ----------------------------------\nmp4lib.boxes.HintMediaHeaderBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'hmhd', size);\n};\n\nmp4lib.boxes.HintMediaHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.HintMediaHeaderBox.prototype.constructor = mp4lib.boxes.HintMediaHeaderBox;\n\nmp4lib.boxes.HintMediaHeaderBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n\n    this.size += mp4lib.fields.FIELD_UINT16.getLength() * 2; //maxPDUsize and avgPDUsize size\n    this.size += mp4lib.fields.FIELD_UINT32.getLength() * 3; //maxbitrate, avgbitrate and reserved size\n};\n\nmp4lib.boxes.HintMediaHeaderBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    this.maxPDUsize = this._readData(data, mp4lib.fields.FIELD_UINT16);\n    this.avgPDUsize = this._readData(data, mp4lib.fields.FIELD_UINT16);\n    this.maxbitrate = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    this.avgbitrate = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    this.reserved = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    return this.localPos;\n};\n\nmp4lib.boxes.HintMediaHeaderBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n\n    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.maxPDUsize);\n    this._writeData(data, mp4lib.fields.FIELD_UINT16, this.avgPDUsize);\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.maxbitrate);\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.avgbitrate);\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.reserved);\n    return this.localPos;\n};\n\n// --------------------------- nmhd ----------------------------------\nmp4lib.boxes.NullMediaHeaderBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'nmhd', size);\n};\n\nmp4lib.boxes.NullMediaHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.NullMediaHeaderBox.prototype.constructor = mp4lib.boxes.NullMediaHeaderBox;\n\n// --------------------------- ctts ----------------------------------\nmp4lib.boxes.CompositionOffsetBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'ctts', size);\n    this.entries = [];\n};\n\nmp4lib.boxes.CompositionOffsetBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.CompositionOffsetBox.prototype.constructor = mp4lib.boxes.CompositionOffsetBox;\n\nmp4lib.boxes.CompositionOffsetBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n\n    this.size += mp4lib.fields.FIELD_UINT32.getLength(); //entry_count size\n\n    if (this.version === 0) {\n        this.size += (mp4lib.fields.FIELD_UINT32.getLength() * 2 /*sample_count and sample_offset size*/ ) * this.entry_count;\n    } else { // version===1\n        this.size += (mp4lib.fields.FIELD_UINT32.getLength() /*sample_count size*/ + mp4lib.fields.FIELD_INT32.getLength()\n            /*sample_offset size*/\n        ) * this.entry_count;\n    }\n};\n\nmp4lib.boxes.CompositionOffsetBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n    var i = 0,\n        struct = {};\n    this.entry_count = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    for (i = 0; i < this.entry_count; i++) {\n        struct = {};\n\n        if (this.version === 0) {\n            struct.sample_count = this._readData(data, mp4lib.fields.FIELD_UINT32);\n            struct.sample_offset = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        } else { // version==1\n            struct.sample_count = this._readData(data, mp4lib.fields.FIELD_UINT32);\n            struct.sample_offset = this._readData(data, mp4lib.fields.FIELD_INT32);\n        }\n        this.entries.push(struct);\n    }\n    return this.localPos;\n};\n\nmp4lib.boxes.CompositionOffsetBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n    var i = 0;\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry_count);\n    for (i = 0; i < this.entry_count; i++) {\n        if (this.version === 0) {\n            this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entries[i].sample_count);\n            this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entries[i].sample_offset);\n        } else { // version==1\n            this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entries[i].sample_count);\n            this._writeData(data, mp4lib.fields.FIELD_INT32, this.entries[i].sample_offset);\n        }\n    }\n    return this.localPos;\n};\n\n// --------------------------- cslg ----------------------------------\nmp4lib.boxes.CompositionToDecodeBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'cslg', size);\n};\n\nmp4lib.boxes.CompositionToDecodeBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.CompositionToDecodeBox.prototype.constructor = mp4lib.boxes.CompositionToDecodeBox;\n\nmp4lib.boxes.CompositionToDecodeBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_INT32.getLength() * 5;\n};\n\nmp4lib.boxes.CompositionToDecodeBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    this.compositionToDTSShift = this._readData(data, mp4lib.fields.FIELD_INT32);\n    this.leastDecodeToDisplayDelta = this._readData(data, mp4lib.fields.FIELD_INT32);\n    this.greatestDecodeToDisplayDelta = this._readData(data, mp4lib.fields.FIELD_INT32);\n    this.compositionStartTime = this._readData(data, mp4lib.fields.FIELD_INT32);\n    this.compositionEndTime = this._readData(data, mp4lib.fields.FIELD_INT32);\n    return this.localPos;\n};\n\nmp4lib.boxes.CompositionToDecodeBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n\n    this._writeData(data, mp4lib.fields.FIELD_INT32, this.compositionToDTSShift);\n    this._writeData(data, mp4lib.fields.FIELD_INT32, this.leastDecodeToDisplayDelta);\n    this._writeData(data, mp4lib.fields.FIELD_INT32, this.greatestDecodeToDisplayDelta);\n    this._writeData(data, mp4lib.fields.FIELD_INT32, this.compositionStartTime);\n    this._writeData(data, mp4lib.fields.FIELD_INT32, this.compositionEndTime);\n    return this.localPos;\n};\n\n// --------------------------- stss ----------------------------------\nmp4lib.boxes.SyncSampleBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'stss', size);\n    this.entries = [];\n};\n\nmp4lib.boxes.SyncSampleBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.SyncSampleBox.prototype.constructor = mp4lib.boxes.SyncSampleBox;\n\nmp4lib.boxes.SyncSampleBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_UINT32.getLength(); //entry_count size\n    this.size += mp4lib.fields.FIELD_UINT32.getLength() * this.entry_count; //entries size\n};\n\nmp4lib.boxes.SyncSampleBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n    var i = 0,\n        struct = {};\n\n    this.entry_count = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    for (i = 0; i < this.entry_count; i++) {\n        struct = {};\n        struct.sample_number = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        this.entries.push(struct);\n    }\n    return this.localPos;\n};\n\nmp4lib.boxes.SyncSampleBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n    var i = 0;\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry_count);\n    for (i = 0; i < this.entry_count; i++) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entries[i].sample_number);\n    }\n    return this.localPos;\n};\n\n// --------------------------- tref ----------------------------------\nmp4lib.boxes.TrackReferenceBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'tref', size);\n};\n\nmp4lib.boxes.TrackReferenceBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.TrackReferenceBox.prototype.constructor = mp4lib.boxes.TrackReferenceBox;\n\nmp4lib.boxes.TrackReferenceBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_UINT32.getLength() * this.track_IDs.length;\n};\n\nmp4lib.boxes.TrackReferenceBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n    this.track_IDs = this._readArrayData(data, mp4lib.fields.FIELD_UINT32);\n    return this.localPos;\n};\n\nmp4lib.boxes.TrackReferenceBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n    this._writeArrayData(data, mp4lib.fields.FIELD_UINT32, this.track_IDs);\n    return this.localPos;\n};\n\n//---------------------------- frma ----------------------------------\nmp4lib.boxes.OriginalFormatBox = function(size) {\n    mp4lib.boxes.Box.call(this, 'frma', size);\n};\n\nmp4lib.boxes.OriginalFormatBox.prototype = Object.create(mp4lib.boxes.Box.prototype);\nmp4lib.boxes.OriginalFormatBox.prototype.constructor = mp4lib.boxes.OriginalFormatBox;\n\nmp4lib.boxes.OriginalFormatBox.prototype.computeLength = function() {\n    mp4lib.boxes.Box.prototype.computeLength.call(this);\n    this.size += mp4lib.fields.FIELD_UINT32.getLength();\n};\n\nmp4lib.boxes.OriginalFormatBox.prototype.read = function(data, pos, end) {\n    this.localPos = pos;\n    this.localEnd = end;\n    this.data_format = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    return this.localPos;\n};\n\nmp4lib.boxes.OriginalFormatBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.Box.prototype.write.call(this, data, pos);\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.data_format);\n    return this.localPos;\n};\n\n// -------------------------------------------------------------------\n// Microsoft Smooth Streaming specific boxes\n// -------------------------------------------------------------------\n\n// --------------------------- piff ----------------------------------\n//PIFF Sample Encryption box\nmp4lib.boxes.PiffSampleEncryptionBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'sepiff', size, [0xA2, 0x39, 0x4F, 0x52, 0x5A, 0x9B, 0x4F, 0x14, 0xA2, 0x44, 0x6C, 0x42, 0x7C, 0x64, 0x8D, 0xF4]);\n};\n\nmp4lib.boxes.PiffSampleEncryptionBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.PiffSampleEncryptionBox.prototype.constructor = mp4lib.boxes.PiffSampleEncryptionBox;\n\nmp4lib.boxes.PiffSampleEncryptionBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    var i = 0,\n        j = 0;\n\n    this.size += mp4lib.fields.FIELD_UINT32.getLength(); //sample_count size\n    if (this.flags & 1) {\n        this.size += mp4lib.fields.FIELD_UINT8.getLength(); //IV_size size\n    }\n    for (i = 0; i < this.sample_count; i++) {\n        this.size += 8; // InitializationVector size\n        if (this.flags & 2) {\n            this.size += mp4lib.fields.FIELD_UINT16.getLength(); // NumberOfEntries size\n            for (j = 0; j < this.entry[i].NumberOfEntries; j++) {\n                this.size += mp4lib.fields.FIELD_UINT16.getLength(); //BytesOfClearData size\n                this.size += mp4lib.fields.FIELD_UINT32.getLength(); //BytesOfEncryptedData size\n            }\n        }\n    }\n};\n\nmp4lib.boxes.PiffSampleEncryptionBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n    var i = 0,\n        j = 0;\n    this._writeData(data, mp4lib.fields.FIELD_UINT32, this.sample_count);\n    if (this.flags & 1) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT8, this.IV_size);\n    }\n    for (i = 0; i < this.sample_count; i++) {\n        this._writeBuffer(data, this.entry[i].InitializationVector, 8);\n\n        if (this.flags & 2) {\n            this._writeData(data, mp4lib.fields.FIELD_UINT16, this.entry[i].NumberOfEntries); // NumberOfEntries\n\n            for (j = 0; j < this.entry[i].NumberOfEntries; j++) {\n                this._writeData(data, mp4lib.fields.FIELD_UINT16, this.entry[i].clearAndCryptedData[j].BytesOfClearData); //BytesOfClearData\n                this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry[i].clearAndCryptedData[j].BytesOfEncryptedData); //BytesOfEncryptedData size\n            }\n        }\n    }\n    return this.localPos;\n};\n\nmp4lib.boxes.PiffSampleEncryptionBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n    var i = 0,\n        j = 0,\n        clearAndCryptedStruct = {},\n        struct = {};\n    this.sample_count = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    if (this.flags & 1) {\n        this.IV_size = this._readData(data, mp4lib.fields.FIELD_UINT8);\n    }\n    this.entry = [];\n    for (i = 0; i < this.sample_count; i++) {\n        struct = {};\n        struct.InitializationVector = data.subarray(this.localPos, this.localPos + 8);\n        this.localPos += 8; //InitializationVector size\n\n        if (this.flags & 2) {\n            struct.NumberOfEntries = this._readData(data, mp4lib.fields.FIELD_UINT16); // NumberOfEntries\n            struct.clearAndCryptedData = [];\n            for (j = 0; j < struct.NumberOfEntries; j++) {\n                clearAndCryptedStruct = {};\n                clearAndCryptedStruct.BytesOfClearData = this._readData(data, mp4lib.fields.FIELD_UINT16); //BytesOfClearData\n                clearAndCryptedStruct.BytesOfEncryptedData = this._readData(data, mp4lib.fields.FIELD_UINT32); //BytesOfEncryptedData size\n                struct.clearAndCryptedData.push(clearAndCryptedStruct);\n            }\n        }\n        this.entry.push(struct);\n    }\n    return this.localPos;\n};\n\n//PIFF Track Encryption Box\nmp4lib.boxes.PiffTrackEncryptionBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'tepiff', size, [0x89, 0x74, 0xDB, 0xCE, 0x7B, 0xE7, 0x4C, 0x51, 0x84, 0xF9, 0x71, 0x48, 0xF9, 0x88, 0x25, 0x54]);\n};\n\nmp4lib.boxes.PiffTrackEncryptionBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.PiffTrackEncryptionBox.prototype.constructor = mp4lib.boxes.PiffTrackEncryptionBox;\n\n//PIFF Protection System Specific Header Box\nmp4lib.boxes.PiffProtectionSystemSpecificHeaderBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'psshpiff', size, [0xD0, 0x8A, 0x4F, 0x18, 0x10, 0xF3, 0x4A, 0x82, 0xB6, 0xC8, 0x32, 0xD8, 0xAB, 0xA1, 0x83, 0xD3]);\n};\n\nmp4lib.boxes.PiffProtectionSystemSpecificHeaderBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.PiffProtectionSystemSpecificHeaderBox.prototype.constructor = mp4lib.boxes.PiffProtectionSystemSpecificHeaderBox;\n\n// --------------------------- tfdx -----------------------------\nmp4lib.boxes.TfxdBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'tfxd', size, [0x6D, 0x1D, 0x9B, 0x05, 0x42, 0xD5, 0x44, 0xE6, 0x80, 0xE2, 0x14, 0x1D, 0xAF, 0xF7, 0x57, 0xB2]);\n};\n\nmp4lib.boxes.TfxdBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.TfxdBox.prototype.constructor = mp4lib.boxes.TfxdBox;\n\nmp4lib.boxes.TfxdBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    if (this.version === 1) {\n        this.size += mp4lib.fields.FIELD_UINT64.getLength() * 2;\n    } else {\n        this.size += mp4lib.fields.FIELD_UINT32.getLength() * 2;\n    }\n};\n\nmp4lib.boxes.TfxdBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n\n    if (this.version === 1) {\n        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.fragment_absolute_time);\n        this._writeData(data, mp4lib.fields.FIELD_UINT64, this.fragment_duration);\n    } else {\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.fragment_absolute_time);\n        this._writeData(data, mp4lib.fields.FIELD_UINT32, this.fragment_duration);\n    }\n    return this.localPos;\n};\n\nmp4lib.boxes.TfxdBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n\n    if (this.version === 1) {\n        this.fragment_absolute_time = this._readData(data, mp4lib.fields.FIELD_UINT64);\n        this.fragment_duration = this._readData(data, mp4lib.fields.FIELD_UINT64);\n    } else {\n        this.fragment_absolute_time = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        this.fragment_duration = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    }\n    return this.localPos;\n};\n\n// --------------------------- tfrf -----------------------------\nmp4lib.boxes.TfrfBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'tfrf', size, [0xD4, 0x80, 0x7E, 0xF2, 0xCA, 0x39, 0x46, 0x95, 0x8E, 0x54, 0x26, 0xCB, 0x9E, 0x46, 0xA7, 0x9F]);\n};\n\nmp4lib.boxes.TfrfBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.TfrfBox.prototype.constructor = mp4lib.boxes.TfrfBox;\n\nmp4lib.boxes.TfrfBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n\n    this.size += mp4lib.fields.FIELD_UINT8.getLength(); //fragment_count size\n    if (this.version === 1) {\n        this.size += (mp4lib.fields.FIELD_UINT64.getLength() * 2 /*fragment_absolute_time and fragment_duration size*/ ) * this.fragment_count;\n    } else {\n        this.size += (mp4lib.fields.FIELD_UINT32.getLength() * 2 /*fragment_absolute_time and fragment_duration size*/ ) * this.fragment_count;\n    }\n};\n\nmp4lib.boxes.TfrfBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n    var i = 0;\n    this._writeData(data, mp4lib.fields.FIELD_UINT8, this.fragment_count);\n    for (i = 0; i < this.fragment_count; i++) {\n        if (this.version === 1) {\n            this._writeData(data, mp4lib.fields.FIELD_UINT64, this.entry[i].fragment_absolute_time);\n            this._writeData(data, mp4lib.fields.FIELD_UINT64, this.entry[i].fragment_duration);\n        } else {\n            this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry[i].fragment_absolute_time);\n            this._writeData(data, mp4lib.fields.FIELD_UINT32, this.entry[i].fragment_duration);\n        }\n    }\n    return this.localPos;\n};\n\nmp4lib.boxes.TfrfBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n    var i = 0,\n        struct = {};\n    this.fragment_count = this._readData(data, mp4lib.fields.FIELD_UINT8);\n    this.entry = [];\n    for (i = 0; i < this.fragment_count; i++) {\n        struct = {};\n        if (this.version === 1) {\n            struct.fragment_absolute_time = this._readData(data, mp4lib.fields.FIELD_UINT64);\n            struct.fragment_duration = this._readData(data, mp4lib.fields.FIELD_UINT64);\n        } else {\n            struct.fragment_absolute_time = this._readData(data, mp4lib.fields.FIELD_UINT32);\n            struct.fragment_duration = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        }\n        this.entry.push(struct);\n    }\n    return this.localPos;\n};\n\n// --------------------------- subs -----------------------------\nmp4lib.boxes.SubSampleInformationBox = function(size) {\n    mp4lib.boxes.FullBox.call(this, 'subs', size);\n};\n\nmp4lib.boxes.SubSampleInformationBox.prototype = Object.create(mp4lib.boxes.FullBox.prototype);\nmp4lib.boxes.SubSampleInformationBox.prototype.constructor = mp4lib.boxes.SubSampleInformationBox;\n\nmp4lib.boxes.SubSampleInformationBox.prototype.computeLength = function() {\n    mp4lib.boxes.FullBox.prototype.computeLength.call(this);\n    // To Define if needed\n};\n\nmp4lib.boxes.SubSampleInformationBox.prototype.read = function(data, pos, end) {\n    mp4lib.boxes.FullBox.prototype.read.call(this, data, pos, end);\n    var i = 0,\n        j = 0,\n        struct = {},\n        subSampleStruct = {};\n\n    this.entry_count = this._readData(data, mp4lib.fields.FIELD_UINT32);\n    this.entry = [];\n    for (i = 0; i < this.entry_count; i++) {\n        struct = {};\n        struct.sample_delta = this._readData(data, mp4lib.fields.FIELD_UINT32);\n        struct.subsample_count = this._readData(data, mp4lib.fields.FIELD_UINT16);\n        if (struct.subsample_count > 0) {\n            struct.subSampleEntries = [];\n            for (j=0; j < struct.subsample_count; j++) {\n                subSampleStruct = {};\n                if (this.version === 1) {\n                    subSampleStruct.subsample_size = this._readData(data, mp4lib.fields.FIELD_UINT32);\n                } else {\n                    subSampleStruct.subsample_size = this._readData(data, mp4lib.fields.FIELD_UINT16);\n                }\n                subSampleStruct.subsample_priority = this._readData(data, mp4lib.fields.FIELD_UINT8);\n                subSampleStruct.discardable = this._readData(data, mp4lib.fields.FIELD_UINT8);\n                subSampleStruct.reserved = this._readData(data, mp4lib.fields.FIELD_UINT32);\n                struct.subSampleEntries.push(subSampleStruct);\n            }\n        }\n        this.entry.push(struct);\n    }\n\n    return this.localPos;\n};\n\nmp4lib.boxes.SubSampleInformationBox.prototype.write = function(data, pos) {\n    mp4lib.boxes.FullBox.prototype.write.call(this, data, pos);\n    // To Define if needed\n};\n\nmp4lib.registerTypeBoxes();","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nvar mpegts = (function() {\n    return {\n        pes: {},\n        si: {},\n        binary: {},\n        ts: {},\n        Pts: {},\n        aac: {},\n        h264: {}\n    };\n}());\n\n// This module is intended to work both on node.js and inside browser.\n// Since these environments differ in a way modules are stored/accessed,\n// we need to export the module in the environment-dependant way\n\nif (typeof module !== 'undefined' && typeof module.exports !== 'undefined')\n    module.exports = mpegts; // node.js\nelse\n    window.mpegts = mpegts; // browser","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nmpegts.si.PSISection = function(table_id) {\n    this.m_table_id = table_id;\n    this.m_section_syntax_indicator = 1;\n    this.m_section_length = mpegts.si.PSISection.prototype.SECTION_LENGTH;\n    this.m_transport_stream_id = 0;\n    this.m_version_number = 0;\n    this.m_current_next_indicator = true;\n    this.m_section_number = 0;\n    this.m_last_section_number = 0;\n    this.m_bValid = null;\n};\n\nmpegts.si.PSISection.prototype.parse = function(data) {\n    this.m_bValid = false;\n\n    var id = 0;\n\n    var pointerField = data[id];\n\n    //if pointerField = 0 payload data start immediately otherwise, shift pointerField value\n    id = pointerField === 0 ? id + 1 : id + pointerField;\n\n    this.m_table_id = data[id];\n    id++;\n    this.m_section_syntax_indicator = mpegts.binary.getBitFromByte(data[id], 0);\n    this.m_section_length = mpegts.binary.getValueFrom2Bytes(data.subarray(id, id + 2), 4);\n    id += 2;\n    this.m_transport_stream_id = mpegts.binary.getValueFrom2Bytes(data.subarray(id, id + 2));\n    id += 2;\n    this.m_version_number = mpegts.binary.getValueFromByte(data[id], 2, 5);\n    this.m_current_next_indicator = mpegts.binary.getBitFromByte(data[id], 7);\n    id++;\n    this.m_section_number = data[id];\n    id++;\n    this.m_last_section_number = data[id];\n\n    /*if (nLength < (m_section_length + 3))\n\t{\n\t\tm_bComplete = false;\n\t\tSAFE_DELETE(m_pBytestream);\n\t\tm_pBytestream = new unsigned char[m_section_length + 3];\n\t\tmemcpy(m_pBytestream, pBytestream, nLength);\n\t\tm_nSectionIndex = nLength;\n\t\treturn;\n\t}\n\n\tm_nSectionIndex = 0;\n\tm_bComplete = true;*/\n    this.m_bValid = true;\n\n    return id;\n};\n\nmpegts.si.PSISection.prototype.getSectionLength = function() {\n    return this.m_section_length;\n};\n\nmpegts.si.PSISection.prototype.SECTION_LENGTH = 9;\nmpegts.si.PSISection.prototype.HEADER_LENGTH = 8;","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// Sampling frequency dependent on sampling_frequency_index\nmpegts.aac.SAMPLING_FREQUENCY = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n\nmpegts.aac.getAudioSpecificConfig = function(data) { // data as Uint8Array\n\n    // We need to parse the beginning of the adts_frame in order to get\n    // object type, sampling frequency and channel configuration\n    var profile = mpegts.binary.getValueFromByte(data[2], 0, 2);\n    var sampling_frequency_index = mpegts.binary.getValueFromByte(data[2], 2, 4);\n    var channel_configuration = mpegts.binary.getValueFrom2Bytes(data.subarray(2, 5), 7, 3);\n\n    var audioSpecificConfig = new Uint8Array(2);\n\n    // audioObjectType = profile = MPEG-4 Audio Object Type minus 1\n    audioSpecificConfig[0] = (profile + 1) << 3;\n\n    // samplingFrequencyIndex\n    audioSpecificConfig[0] |= (sampling_frequency_index & 0x0E) >> 1;\n    audioSpecificConfig[1] |= (sampling_frequency_index & 0x01) << 7;\n\n    // channelConfiguration\n    audioSpecificConfig[1] |= channel_configuration << 3;\n\n    /*  code for HE AAC v2 to be tested\n\n    var audioSpecificConfig = new Uint8Array(4);\n\n    // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\n    audioSpecificConfig[0] = 29 << 3;\n\n    // samplingFrequencyIndex\n    audioSpecificConfig[0] |= (sampling_frequency_index & 0x0E) >> 1;\n    audioSpecificConfig[1] |= (sampling_frequency_index & 0x01) << 7;\n\n    // channelConfiguration\n    audioSpecificConfig[1] |= channel_configuration << 3;\n    \n    var extensionSamplingFrequencyIndex = 5;// in HE AAC Extension Sampling frequence\n\n    audioSpecificConfig[1] |= extensionSamplingFrequencyIndex >> 1;\n       \n    audioSpecificConfig[2] = (extensionSamplingFrequencyIndex << 7) | ((profile+1) << 2);// origin object type equals to 2 => AAC Main Low Complexity\n    audioSpecificConfig[3] = 0x0; //alignment bits\n\n   */\n\n    return audioSpecificConfig;\n};\n\nmpegts.aac.parseADTS = function(data, cts) { // data as Uint8Array, cts as an array of cts for each frame index\n\n    var aacFrames = [],\n        adtsHeader = {},\n        aacFrame,\n        adtsFrameIndex,\n        i = 0;\n\n    while (i < data.length) {\n        // = adts_frame\n        adtsFrameIndex = i;\n\n        // == adts_fixed_header\n        adtsHeader.syncword = (data[i] << 4) + ((data[i + 1] & 0xF0) >> 4);\n        // adtsHeader.ID\n        // adtsHeader.layer\n        adtsHeader.protection_absent = data[i + 1] & 0x01;\n        // adtsHeader.profile\n        adtsHeader.sampling_frequency_index = (data[i + 2] & 0x3C) >> 2;\n        // adtsHeader.private_bit\n        adtsHeader.channel_configuration = ((data[i + 2] & 0x01) << 1) + ((data[i + 3] & 0xC0) >> 6);\n        // adtsHeader.original_copy\n        // adtsHeader.home\n\n        // == adts_variable_header\n        // adtsHeader.copyright_identification_bit\n        // adtsHeader.copyright_identification_start\n        adtsHeader.aac_frame_length = ((data[i + 3] & 0x03) << 11) + (data[i + 4] << 3) + ((data[i + 5] & 0xE0) >> 5);\n        // adtsHeader.adts_buffer_fullness\n        adtsHeader.number_of_raw_data_blocks_in_frame = (data[i + 6] & 0x03) >> 2;\n\n        i += 7;\n\n        if (adtsHeader.number_of_raw_data_blocks_in_frame === 0) {\n            // == adts_error_check()\n            if (adtsHeader.protection_absent === 0) {\n                i += 2;\n            }\n\n            // == raw_data_block() => create AAC frame\n            aacFrame = {};\n            aacFrame.offset = i;\n            aacFrame.length = adtsHeader.aac_frame_length - (i - adtsFrameIndex);\n\n            if (cts && cts[adtsFrameIndex]) {\n                aacFrame.cts = cts[adtsFrameIndex];\n            }\n\n            aacFrames.push(aacFrame);\n\n            i += aacFrame.length;\n        } else {\n            // == adts_header_error_check\n        }\n    }\n\n    return aacFrames;\n};","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nmpegts.ts.AdaptationField = function() {\n    /** adaptation field fields */\n    this.m_cAFLength = null;\n    this.m_bDiscontinuityInd = null;\n    this.m_bRAI = null;\n    this.m_bESPriority = null;\n\n    /** Optional fields flags */\n    this.m_bPCRFlag = null;\n    this.m_bOPCRFlag = null;\n    this.m_bSplicingPointFlag = null;\n    this.m_bPrivateDataFlag = null;\n    this.m_bAdaptationFieldExtFlag = null;\n};\n\nmpegts.ts.AdaptationField.prototype.getLength = function() {\n    return (this.m_cAFLength + 1);\n};\n\nmpegts.ts.AdaptationField.prototype.parse = function(data) {\n    this.m_cAFLength = data[0];\n\n    if (this.m_cAFLength === 0) {\n        // = exactly 1 stuffing byte\n        return;\n    }\n\n    var index = 1;\n\n    this.m_bDiscontinuityInd = mpegts.binary.getBitFromByte(data[index], 0);\n    this.m_bRAI = mpegts.binary.getBitFromByte(data[index], 1);\n    this.m_bESPriority = mpegts.binary.getBitFromByte(data[index], 2);\n    this.m_bPCRFlag = mpegts.binary.getBitFromByte(data[index], 3);\n    this.m_bOPCRFlag = mpegts.binary.getBitFromByte(data[index], 4);\n    this.m_bSplicingPointFlag = mpegts.binary.getBitFromByte(data[index], 5);\n    this.m_bPrivateDataFlag = mpegts.binary.getBitFromByte(data[index], 6);\n    this.m_bAdaptationFieldExtFlag = mpegts.binary.getBitFromByte(data[index], 7);\n\n    //other flags are not useful for the conversion HLS => MP4\n};","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nmpegts.binary.readBytes = function(buf, pos, nbBytes) {\n    var value = 0;\n    for (var i = 0; i < nbBytes; i++) {\n        value = value << 8;\n        value = value + buf[pos];\n        pos++;\n    }\n    return value;\n};\n\n/**\n * Returns a bit value from the given byte\n * @param data the input byte\n * @param bitIndex the bit index inside the byte (0=msb to 7=lsb)\n * @return the bit value as a boolean (0 => false, 1 => true)\n */\nmpegts.binary.getBitFromByte = function(data, bitIndex) {\n    var cMask = 0x00;\n    cMask += (1 << (7 - bitIndex));\n\n    return ((data & cMask) !== 0);\n};\n\n/**\n * Returns the value extracted from three consecutive bytes\n * @param pBytes the input bytes\n * @param msbIndex the index of the first bit to extract ( 0=msb to 15=lsb )\n * @param nbBits the number of bits to extract (if '-1' then extract up to the last bit)\n * @return the value of the extracted bits as an unsigned short, or 0xFFFFFFFF if a problem has occured\n */\nmpegts.binary.getValueFrom3Bytes = function(pBytes, msbIndex /* = 0*/ , nbBits /* = -1*/ ) {\n    if (typeof nbBits === \"undefined\") {\n        nbBits = -1;\n    }\n    if (typeof msbIndex === \"undefined\") {\n        msbIndex = 0;\n    }\n    var nbBits2 = nbBits == -1 ? -1 : (nbBits - (16 - msbIndex));\n    var nbLsbShift = nbBits == -1 ? 0 : (8 - nbBits2);\n    var cValue0 = mpegts.binary.getValueFromByte(pBytes[0], msbIndex);\n    var cValue1 = mpegts.binary.getValueFromByte(pBytes[1]);\n    var cValue2 = mpegts.binary.getValueFromByte(pBytes[2], 0, nbBits2, false);\n\n    return ((((cValue0 << 16) & 0x00FF0000) | ((cValue1 << 8) & 0x0000FF00) | (cValue2 & 0x000000FF)) >> nbLsbShift);\n};\n\n/**\n * Returns the value extracted from two consecutive bytes\n * @param data the input bytes\n * @param msbIndex the index of the first bit to extract ( 0=msb to 15=lsb )\n * @param nbBits the number of bits to extract (if '-1' then extract up to the last bit)\n * @return the value of the extracted bits as an unsigned short, or 0xFFFF if a problem has occured\n */\nmpegts.binary.getValueFrom2Bytes = function(data, msbIndex /* = 0*/ , nbBits /* = -1*/ ) {\n    if (typeof nbBits === \"undefined\") {\n        nbBits = -1;\n    }\n    if (typeof msbIndex === \"undefined\") {\n        msbIndex = 0;\n    }\n\n    var nbBits1 = nbBits == -1 ? -1 : (nbBits - (8 - msbIndex));\n    var nbLsbShift = nbBits == -1 ? 0 : (8 - nbBits1);\n    var cValue0 = mpegts.binary.getValueFromByte(data[0], msbIndex);\n    var cValue1 = mpegts.binary.getValueFromByte(data[1], 0, nbBits1, false);\n\n    return ((((cValue0 << 8) & 0xFF00) | (cValue1 & 0x00FF)) >> nbLsbShift);\n};\n\n/**\n * Returns the value extracted from the given byte\n * @param data the input byte\n * @param msbIndex the index of the first bit to extract ( 0=msb to 7=lsb )\n * @param nbBits the number of bits to extract (if '-1' then extract up to the last bit)\n * @param bShift true if the bits have to be shifted to the right\n * @return the value of the extracted bits as an unsigned char, or 0xFF if a problem has occurred\n */\nmpegts.binary.getValueFromByte = function(data, msbIndex /* = 0*/ , nbBits /* = -1*/ , bShift /* = true*/ ) {\n    var cMask = 0x00;\n    var i = 0;\n\n    if (typeof nbBits === \"undefined\") {\n        nbBits = -1;\n    }\n    if (typeof msbIndex === \"undefined\") {\n        msbIndex = 0;\n    }\n\n    var lsbIndex = (nbBits == -1) ? 7 : (msbIndex + nbBits - 1);\n    for (i = msbIndex; i <= lsbIndex; i++) {\n        cMask += (1 << (7 - i));\n    }\n\n    var cValue = data & cMask;\n    if (bShift || typeof bShift === \"undefined\") {\n        cValue >>= (7 - lsbIndex);\n    }\n    return cValue;\n};","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nmpegts.h264.getSequenceHeader = function(data) { // data as Uint8Array\n\n    var pos = -1,\n        length = -1,\n        i = 0,\n        naluType,\n        sequenceHeader = null,\n        width = 0,\n        height = 0;\n\n    while (i < data.length) {\n        if ((data[i] === 0x00) && (data[i + 1] === 0x00) && (data[i + 2] === 0x00) && (data[i + 3] === 0x01)) {\n\n            naluType = data[i + 4] & 0x1F;\n\n            // Start of SPS or PPS\n            if ((naluType >= mpegts.h264.NALUTYPE_SPS) && (naluType <= mpegts.h264.NALUTYPE_PPS)) {\n                // First NALU of this type => we start storing the sequence header\n                if (pos === -1) {\n                    pos = i;\n                }\n\n                // SPS => parse to get width and height\n                if (naluType === mpegts.h264.NALUTYPE_SPS) {\n                    var sps = mpegts.h264.parseSPS(data.subarray(i + 5)); // +5 => after nal_unit_type byte\n                    width = (sps.pic_width_in_mbs_minus1 + 1) << 4;\n                    height = (sps.pic_height_in_map_units_minus1 + 1) << 4;\n                }\n            } else if (pos > 0) {\n                length = i - pos;\n            }\n\n            // Start of coded picture NALU\n            if ((naluType === mpegts.h264.NALUTYPE_IDR) || (naluType === mpegts.h264.NALUTYPE_NONIDR)) {\n                break;\n            }\n\n            i += 4;\n        } else if ((data[i] === 0x00) && (data[i + 1] === 0x00) && (data[i + 2] === 0x01)) {\n            if (pos > 0) {\n                length = i - pos;\n            }\n            break;\n        } else {\n            i++;\n        }\n    }\n\n    if ((pos === -1) || (length === -1)) {\n        return null;\n    }\n\n    sequenceHeader = new Uint8Array(length);\n    sequenceHeader.set(data.subarray(pos, pos + length));\n\n    return {\n        bytes: sequenceHeader,\n        width: width,\n        height: height\n    };\n};\n\nmpegts.h264.read_ue = function(data, ctx) {\n\n    var value = 1,\n        temp = 0,\n        numZeros = 0;\n\n    ctx._bit = (ctx._byte >> ctx._bitPos) & 0x01;\n    ctx._bitPos--;\n    if (ctx._bitPos < 0) {\n        ctx._byte = data[ctx._bytePos];\n        ctx._bytePos++;\n        ctx._bitPos = 7;\n    }\n\n    while (ctx._bit === 0) {\n        numZeros++;\n        value = value << 1;\n        ctx._bit = (ctx._byte >> ctx._bitPos) & 0x01;\n        ctx._bitPos--;\n        if (ctx._bitPos < 0) {\n            ctx._byte = data[ctx._bytePos];\n            ctx._bytePos++;\n            ctx._bitPos = 7;\n        }\n    }\n\n    value -= 1;\n    temp = 0;\n    if (numZeros) {\n        while (numZeros > 0) {\n            ctx._bit = (ctx._byte >> ctx._bitPos) & 0x01;\n            ctx._bitPos--;\n            temp = (temp << 1) + ctx._bit;\n            numZeros--;\n            if (ctx._bitPos < 0) {\n                ctx._byte = data[ctx._bytePos];\n                ctx._bytePos++;\n                ctx._bitPos = 7;\n            }\n        }\n    }\n    value += temp;\n\n    return value;\n};\n\nmpegts.h264.read_flag = function(data, ctx) {\n\n    var value = 0;\n\n    ctx._bit = (ctx._byte >> ctx._bitPos) & 0x01;\n    ctx._bitPos--;\n    if (ctx._bitPos < 0) {\n        ctx._byte = data[ctx._bytePos];\n        ctx._bytePos++;\n        ctx._bitPos = 7;\n    }\n    value = ctx._bit;\n\n    return value;\n};\n\n\nmpegts.h264.parseSPS = function(data) {\n\n    var sps = {\n            profile_idc: 0,\n            constraint_set0_flag: 0,\n            constraint_set1_flag: 0,\n            constraint_set2_flag: 0,\n            constraint_set3_flag: 0,\n            level_idc: 0,\n            seq_parameter_set_id: 0,\n            chroma_format_idc: 0,\n            separate_colour_plane_flag: 0,\n            bit_depth_luma_minus8: 0,\n            bit_depth_chroma_minus8: 0,\n            qpprime_y_zero_transform_bypass_flag: 0,\n            seq_scaling_matrix_present_flag: 0,\n            log2_max_frame_num_minus4: 0,\n            pic_order_cnt_type: 0,\n            log2_max_pic_order_cnt_lsb_minus4: 0,\n            num_ref_frames: 0,\n            gaps_in_frame_num_value_allowed_flag: 0,\n            pic_width_in_mbs_minus1: 0,\n            pic_height_in_map_units_minus1: 0\n        },\n\n        ctx = {\n            _byte: 0,\n            _bit: 0,\n            _bytePos: 0,\n            _bitPos: 0\n        };\n\n\n    ctx._bytePos = ctx._bitPos = 0;\n\n    // profile_idc - u(8)\n    ctx._byte = data[ctx._bytePos];\n    ctx._bytePos++;\n    sps.profile_idc = ctx._byte;\n\n    // constraint_set_flag (0/1/2/3 + reserved bits) - u(8)\n    ctx._byte = data[ctx._bytePos];\n    ctx._bytePos++;\n    sps.constraint_set0_flag = (ctx._byte & 0x80) >> 7;\n    sps.constraint_set1_flag = (ctx._byte & 0x40) >> 6;\n    sps.constraint_set2_flag = (ctx._byte & 0x20) >> 5;\n    sps.constraint_set3_flag = (ctx._byte & 0x10) >> 4;\n\n    // level_idc - u(8)\n    ctx._byte = data[ctx._bytePos];\n    ctx._bytePos++;\n    sps.level_idc = ctx._byte;\n\n    // seq_parameter_set_id - ue(v)\n    ctx._byte = data[ctx._bytePos];\n    ctx._bytePos++;\n    ctx._bitPos = 7;\n    sps.seq_parameter_set_id = mpegts.h264.read_ue(data, ctx);\n\n    if ((sps.profile_idc === 100) ||\n        (sps.profile_idc === 110) ||\n        (sps.profile_idc === 122) ||\n        (sps.profile_idc === 244) ||\n        (sps.profile_idc === 44) ||\n        (sps.profile_idc === 83) ||\n        (sps.profile_idc === 86)) {\n\n        // chroma_format_idc - ue(v)\n        sps.chroma_format_idc = mpegts.h264.read_ue(data, ctx);\n\n        if (sps.chroma_format_idc === 3) {\n            // separate_colour_plane_flag - u(1)\n            sps.separate_colour_plane_flag = mpegts.h264.read_flag(data, ctx);\n        }\n\n        // bit_depth_luma_minus8 - ue(v)\n        sps.bit_depth_luma_minus8 = mpegts.h264.read_ue(data, ctx);\n\n        // bit_depth_chroma_minus8 - ue(v)\n        sps.bit_depth_chroma_minus8 = mpegts.h264.read_ue(data, ctx);\n\n        // qpprime_y_zero_transform_bypass_flag - u(1)\n        sps.qpprime_y_zero_transform_bypass_flag = mpegts.h264.read_flag(data, ctx);\n\n        // seq_scaling_matrix - u(1)\n        sps.seq_scaling_matrix_present_flag = mpegts.h264.read_flag(data, ctx);\n\n        if (sps.seq_scaling_matrix_present_flag === 1) {\n            // NOT IMPLEMENTED\n            //console.log(\"H.264 SPS parsing: (seq_scaling_matrix_present_flag = 1) not implemented\");\n        }\n    }\n\n    // log2_max_frame_num_minus4 - ue(v)\n    sps.log2_max_frame_num_minus4 = mpegts.h264.read_ue(data, ctx);\n\n    // pic_order_cnt_type - ue(v)\n    sps.pic_order_cnt_type = mpegts.h264.read_ue(data, ctx);\n\n    if (sps.pic_order_cnt_type === 0) {\n        // log2_max_pic_order_cnt_lsb_minus4 - ue(v)\n        sps.log2_max_pic_order_cnt_lsb_minus4 = mpegts.h264.read_ue(data, ctx);\n    } else if (sps.pic_order_cnt_type === 1) {\n        // NOT IMPLEMENTED\n        //console.log(\"H.264 SPS parsing: (log2_max_pic_order_cnt_lsb_minus4 = 1) not implemented\");\n    }\n\n    // num_ref_frames - ue(v)\n    sps.num_ref_frames = mpegts.h264.read_ue(data, ctx);\n\n    // gaps_in_frame_num_value_allowed_flag - u(1)\n    sps.gaps_in_frame_num_value_allowed_flag = mpegts.h264.read_flag(data, ctx);\n\n    // pic_width_in_mbs_minus1 - ue(v)\n    sps.pic_width_in_mbs_minus1 = mpegts.h264.read_ue(data, ctx);\n\n    // pic_height_in_map_units_minus1 - ue(v)\n    sps.pic_height_in_map_units_minus1 = mpegts.h264.read_ue(data, ctx);\n\n    return sps;\n};\n\nmpegts.h264.parseNALUs = function(data) { // data as Uint8Array\n\n    var i = 0,\n        length = data.length,\n        numZeroBytes = 0,\n        nalus = [],\n        nalu;\n\n    // console.log(\"[H264] PARSE NALUs ------------------------------------------\");\n    while (i < length) {\n        if (data[i] === 0) {\n            numZeroBytes++;\n        }\n        if ((data[i] === 1) && (numZeroBytes >= 2)) {\n            i++;\n            // Update previous NALU size\n            if (nalus.length > 0) {\n                nalus[nalus.length - 1].size = i - (numZeroBytes + 1) - nalus[nalus.length - 1].offset;\n            }\n\n            nalu = {};\n            nalu.type = data[i] & 0x1F;\n            nalu.offset = i;\n            nalus.push(nalu);\n\n            // console.log(\"[H264] NALU: SC = \" + (numZeroBytes + 1) + \", type = \" + nalu.type);\n            numZeroBytes = 0;\n        }\n        if (data[i]) {\n            numZeroBytes = 0;\n        }\n        i++;\n    }\n\n    // Update last NALU size\n    if (nalus.length > 0) {\n        nalus[nalus.length - 1].size = i - nalus[nalus.length - 1].offset;\n    }\n\n    return nalus;\n};\n\n\nmpegts.h264.bytestreamToMp4 = function(data) { // data as Uint8Array\n\n    var i = 0,\n        length = data.length,\n        startCodeIndex = -1,\n        naluSize = 0;\n\n    while (i < length) {\n        if ((data[i] === 0x00) && (data[i + 1] === 0x00) && (data[i + 2] === 0x00) && (data[i + 3] === 0x01)) {\n\n            if (startCodeIndex >= 0) {\n                naluSize = (i - startCodeIndex - 4); // 4 = start code length or NALU-size field length\n                data[startCodeIndex] = (naluSize & 0xFF000000) >> 24;\n                data[startCodeIndex + 1] = (naluSize & 0x00FF0000) >> 16;\n                data[startCodeIndex + 2] = (naluSize & 0x0000FF00) >> 8;\n                data[startCodeIndex + 3] = (naluSize & 0x000000FF);\n                // console.log(\"[H264] NALU: type = \" + (data[i + 4] & 0x1F) + \", size = \" + naluSize);\n            }\n\n            startCodeIndex = i;\n            i += 4;\n        } else {\n            i++;\n        }\n    }\n\n    // Last NAL unit\n    naluSize = (i - startCodeIndex - 4); // 4 = start code length or NALU-size field length\n    data[startCodeIndex] = (naluSize & 0xFF000000) >> 24;\n    data[startCodeIndex + 1] = (naluSize & 0x00FF0000) >> 16;\n    data[startCodeIndex + 2] = (naluSize & 0x0000FF00) >> 8;\n    data[startCodeIndex + 3] = (naluSize & 0x000000FF);\n    // console.log(\"[H264] NALU: type = \" + (data[i + 4] & 0x1F) + \", size = \" + naluSize);\n\n};\n\nmpegts.h264.isIDR = function(data) { // data as Uint8Array\n    var i = 0,\n        naluType;\n\n    while (i < data.length) {\n        if ((data[i] === 0x00) && (data[i + 1] === 0x00) && (data[i + 2] === 0x01)) {\n            naluType = data[i + 3] & 0x1F;\n            if (naluType === mpegts.h264.NALUTYPE_IDR) {\n                return true;\n            }\n            i += 3;\n        } else {\n            i++;\n        }\n    }\n    return false;\n};\n\nmpegts.h264.NALUTYPE_NONIDR = 1;\nmpegts.h264.NALUTYPE_IDR = 5;\nmpegts.h264.NALUTYPE_SEI = 6;\nmpegts.h264.NALUTYPE_SPS = 7;\nmpegts.h264.NALUTYPE_PPS = 8;\nmpegts.h264.NALUTYPE_AU_DELIMITER = 9;","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nmpegts.si.PAT = function() {\n    mpegts.si.PSISection.call(this, mpegts.si.PAT.prototype.TABLE_ID);\n    this.m_listOfProgramAssociation = [];\n    this.m_network_pid = null;\n};\n\nmpegts.si.PAT.prototype = Object.create(mpegts.si.PSISection.prototype);\nmpegts.si.PAT.prototype.constructor = mpegts.si.PAT;\n\nmpegts.si.PAT.prototype.parse = function(data) {\n    var id = mpegts.si.PSISection.prototype.parse.call(this, data);\n    id++;\n\n    if (!this.m_bValid) {\n        //console.log(\"PSI Parsing Problem during PAT parsing!\");\n        return;\n    }\n    this.m_bValid = false;\n\n    if (this.m_table_id !== this.TABLE_ID) {\n        return;\n    }\n\n    var remainingBytes = this.getSectionLength() - this.SECTION_LENGTH;\n\n    while (remainingBytes >= 4) {\n        var prog = new mpegts.si.ProgramAssociation(data.subarray(id, id + 4));\n\n        if (prog.getProgramNumber() === 0) {\n            // Network PID\n            this.m_network_pid = prog.getProgramMapPid();\n        } else {\n            this.m_listOfProgramAssociation.push(prog);\n        }\n        remainingBytes -= 4;\n        id += 4;\n    }\n\n    this.m_bValid = true;\n};\n\n/**\n * returns the PID of the PMT associated to the first program\n *\n * @return the PID of the PMT associated to the first program\n */\nmpegts.si.PAT.prototype.getPmtPid = function() {\n    var pid = mpegts.ts.TsPacket.prototype.UNDEFINED_PID;\n\n    if (this.m_listOfProgramAssociation.length >= 1) {\n        var prog = this.m_listOfProgramAssociation[0];\n        pid = prog.getProgramMapPid();\n    }\n\n    return pid;\n};\n\nmpegts.si.PAT.prototype.TABLE_ID = 0x00;\nmpegts.si.PAT.prototype.PID = 0x00;\n\n\nmpegts.si.ProgramAssociation = function(data) {\n    this.m_program_number = 0;\n    this.m_program_map_pid = 0;\n    this.parse(data);\n};\n\nmpegts.si.ProgramAssociation.prototype.getProgramNumber = function() {\n    return this.m_program_number;\n};\n\nmpegts.si.ProgramAssociation.prototype.getProgramMapPid = function() {\n    return this.m_program_map_pid;\n};\n\nmpegts.si.ProgramAssociation.prototype.getLength = function() {\n    return 4;\n};\n\n/**\n * Parse the ProgramAssociation from given stream\n */\nmpegts.si.ProgramAssociation.prototype.parse = function(data) {\n    this.m_program_number = mpegts.binary.getValueFrom2Bytes(data.subarray(0, 2));\n    this.m_program_map_pid = mpegts.binary.getValueFrom2Bytes(data.subarray(2, 4), 3, 13);\n};","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nmpegts.pes.PesPacket = function() {\n    this.m_cStreamID = null;\n    this.m_nPESPacketLength = null;\n    this.m_cPESScramblingCtrl = null;\n    this.m_bPESpriority = null;\n    this.m_bDataAlignement = null;\n    this.m_bCopyright = null;\n    this.m_bOriginalOrCopy = null;\n    this.m_cPES_header_data_length = null;\n    this.m_cPTS_DTS_flags = null;\n    this.m_bESCR_flag = null;\n    this.m_bES_rate_flag = null;\n    this.m_bDSM_trick_mode_flag = null;\n    this.m_bAdditional_copy_info_flag = null;\n    this.m_bPES_CRC_flag = null;\n    this.m_bPES_extension_flag = null;\n    this.m_pPTS = null;\n    this.m_pDTS = null;\n    this.m_pESCR = null;\n    this.m_ES_rate = null;\n    this.m_DSM_trick_mode = null;\n    this.m_Additional_copy_info = null;\n    this.m_PES_CRC = null;\n    this.m_cNbStuffingBytes = null;\n    this.m_pPESExtension = null;\n    this.m_pPrivateData = null;\n    this.m_payloadArray = null;\n    this.m_nPayloadLength = null;\n    this.m_bDirty = null;\n    this.m_bValid = false;\n};\n\nmpegts.pes.PesPacket.prototype.parse = function(data) {\n    var index = 0;\n    this.m_nLength = data.length;\n    // packet_start_code_prefix\n    var nStartCode = mpegts.binary.getValueFrom3Bytes(data.subarray(index, index + 3));\n    if (nStartCode !== this.START_CODE_PREFIX) {\n        //console.log(\"PES Packet start code not define!\");\n        return;\n    }\n\n    index = 3; // 3 = packet_start_code_prefix length\n\n    // stream_id\n    this.m_cStreamID = data[index];\n    index++;\n\n    // PES_packet_length\n    this.m_nPESPacketLength = mpegts.binary.getValueFrom2Bytes(data.subarray(index, index + 2));\n    index += 2;\n\n    // Padding bytes\n    if (this.m_cStreamID === mpegts.ts.TsPacket.prototype.STREAM_ID_PADDING_STREAM) {\n        // Padding bytes => no more field, no payload\n        this.m_bValid = true;\n        return;\n    }\n\n    // PES_packet_data_byte (no optional header)\n    if (!this.hasOptionalPESHeader()) {\n        //NAN => to Validate!!!!\n        // no more header field, only payload\n        this.m_payloadArray = data.subarray(index + mpegts.pes.PesPacket.prototype.FIXED_HEADER_LENGTH);\n        this.m_nPayloadLength = this.m_nLength - mpegts.pes.PesPacket.prototype.FIXED_HEADER_LENGTH;\n        this.m_bValid = true;\n        return;\n    }\n\n    // Optional PES header\n    var reserved = mpegts.binary.getValueFromByte(data[index], 0, 2);\n    if (reserved !== 0x02) {\n        return;\n    }\n    this.m_cPESScramblingCtrl = mpegts.binary.getValueFromByte(data[index], 2, 2);\n    this.m_bPESpriority = mpegts.binary.getBitFromByte(data[index], 4);\n    this.m_bDataAlignement = mpegts.binary.getBitFromByte(data[index], 5);\n    this.m_bCopyright = mpegts.binary.getBitFromByte(data[index], 6);\n    this.m_bOriginalOrCopy = mpegts.binary.getBitFromByte(data[index], 7);\n    index++;\n\n    // 7 flags\n    this.m_cPTS_DTS_flags = mpegts.binary.getValueFromByte(data[index], 0, 2);\n    this.m_bESCR_flag = mpegts.binary.getBitFromByte(data[index], 2);\n    this.m_bES_rate_flag = mpegts.binary.getBitFromByte(data[index], 3);\n    this.m_bDSM_trick_mode_flag = mpegts.binary.getBitFromByte(data[index], 4);\n    this.m_bAdditional_copy_info_flag = mpegts.binary.getBitFromByte(data[index], 5);\n    this.m_bPES_CRC_flag = mpegts.binary.getBitFromByte(data[index], 6);\n    this.m_bPES_extension_flag = mpegts.binary.getBitFromByte(data[index], 7);\n    index++;\n\n    // PES_header_data_length\n    this.m_cPES_header_data_length = (data[index] & 0xFF);\n    index++;\n\n    // PTS\n    if ((this.m_cPTS_DTS_flags & mpegts.pes.PesPacket.prototype.FLAG_PTS) == mpegts.pes.PesPacket.prototype.FLAG_PTS) {\n        this.m_pPTS = new mpegts.Pts(data.subarray(index, index + 5));\n        index += 5;\n    }\n\n    // DTS\n    if ((this.m_cPTS_DTS_flags & mpegts.pes.PesPacket.prototype.FLAG_DTS) == mpegts.pes.PesPacket.prototype.FLAG_DTS) {\n        this.m_pDTS = new mpegts.Pts(data.subarray(index, index + 5));\n        index += 5;\n    }\n\n    // ESCR\n    if (this.m_bESCR_flag) {\n        //NAN => to Complete\n        //this.m_pESCR = new PCR(m_pBytestream + index);\n        index += 6;\n    }\n\n    // ES_rate\t\n    if (this.m_bES_rate_flag) {\n        this.m_ES_rate = mpegts.binary.getValueFrom3Bytes(data.subarray(index, index + 3), 1, 22);\n        index += 3;\n    }\n\n    // DSM_trick_mode\n    if (this.m_bDSM_trick_mode_flag) {\n        this.m_DSM_trick_mode = data[index];\n        index++;\n    }\n\n    // Additional_copy_info\n    if (this.m_bAdditional_copy_info_flag) {\n        this.m_Additional_copy_info = data[index];\n        index++;\n    }\n\n    // PES_CRC\n    if (this.m_bPES_CRC_flag) {\n        this.m_PES_CRC = mpegts.binary.getValueFrom2Bytes(data.subarray(index, index + 2));\n        index += 2;\n    }\n\n    // PES_extension\n    if (this.m_bPES_extension_flag) {\n        //NAN => to Complete\n        //this.m_pPESExtension = new PESExtension(m_pBytestream + index, m_cPES_header_data_length);\n        //index += m_pPESExtension->getLength();\n    }\n\n    // Stuffing bytes\n    var uiHeaderLength = mpegts.pes.PesPacket.prototype.FIXED_HEADER_LENGTH + mpegts.pes.PesPacket.prototype.FIXED_OPTIONAL_HEADER_LENGTH + this.m_cPES_header_data_length;\n    this.m_cNbStuffingBytes = uiHeaderLength - index;\n    index += this.m_cNbStuffingBytes;\n\n    // Payload\n    this.m_nPayloadLength = this.m_nLength - uiHeaderLength;\n    this.m_payloadArray = data.subarray(uiHeaderLength, uiHeaderLength + this.m_nPayloadLength);\n\n    this.m_bValid = true;\n};\n\n\n/**\n * Returns true if header contains optional PES header.\n * @return true if header contains optional PES header\n */\nmpegts.pes.PesPacket.prototype.hasOptionalPESHeader = function() {\n\n    if ((this.m_cStreamID === mpegts.ts.TsPacket.prototype.STREAM_ID_PROGRAM_STREAM_MAP) ||\n        (this.m_cStreamID === mpegts.ts.TsPacket.prototype.STREAM_ID_PADDING_STREAM) ||\n        (this.m_cStreamID === mpegts.ts.TsPacket.prototype.STREAM_ID_PRIVATE_STREAM_2) ||\n        (this.m_cStreamID === mpegts.ts.TsPacket.prototype.STREAM_ID_ECM_STREAM) ||\n        (this.m_cStreamID === mpegts.ts.TsPacket.prototype.STREAM_ID_EMM_STREAM) ||\n        (this.m_cStreamID === mpegts.ts.TsPacket.prototype.STREAM_ID_PROGRAM_STREAM_DIRECTORY) ||\n        (this.m_cStreamID === mpegts.ts.TsPacket.prototype.STREAM_ID_DSMCC_STREAM) ||\n        (this.m_cStreamID === mpegts.ts.TsPacket.prototype.STREAM_ID_H2221_TYPE_E_STREAM)) {\n        return false;\n    }\n\n    return true;\n};\n\nmpegts.pes.PesPacket.prototype.getHeaderLength = function() {\n    return mpegts.pes.PesPacket.prototype.FIXED_HEADER_LENGTH +\n        mpegts.pes.PesPacket.prototype.FIXED_OPTIONAL_HEADER_LENGTH +\n        this.m_cPES_header_data_length;\n};\n\nmpegts.pes.PesPacket.prototype.getPayload = function() {\n    return this.m_payloadArray;\n};\n\nmpegts.pes.PesPacket.prototype.getPts = function() {\n    return this.m_pPTS;\n};\n\nmpegts.pes.PesPacket.prototype.getDts = function() {\n    return this.m_pDTS;\n};\n\n/** The start code prefix */\nmpegts.pes.PesPacket.prototype.START_CODE_PREFIX = 0x000001;\n/** The first fixed header fields length (start_code + stream_id + PES_packet_length fields) **/\nmpegts.pes.PesPacket.prototype.FIXED_HEADER_LENGTH = 6;\n/** The first optional fixed header fields length **/\nmpegts.pes.PesPacket.prototype.FIXED_OPTIONAL_HEADER_LENGTH = 3;\n/** PTS_DTS_flags possible values */\nmpegts.pes.PesPacket.prototype.FLAG_DTS = 0x01;\nmpegts.pes.PesPacket.prototype.FLAG_PTS = 0x02;","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nmpegts.si.PMT = function() {\n    mpegts.si.PSISection.call(this, mpegts.si.PMT.prototype.TABLE_ID);\n    this.m_listOfComponents = [];\n    this.m_PCR_PID = null;\n    this.m_program_info_length = null;\n};\n\nmpegts.si.PMT.prototype = Object.create(mpegts.si.PSISection.prototype);\nmpegts.si.PMT.prototype.constructor = mpegts.si.PMT;\n\nmpegts.si.PMT.prototype.parse = function(data) {\n    var id = mpegts.si.PSISection.prototype.parse.call(this, data);\n    id++;\n\n    if (!this.m_bValid) {\n        //console.log(\"PSI Parsing Problem during PMT parsing!\");\n        return;\n    }\n    this.m_bValid = false;\n\n    // Check table_id field value\n    if (this.m_table_id !== this.TABLE_ID) {\n        return;\n    }\n\n    var remainingBytes = this.getSectionLength() - this.SECTION_LENGTH;\n\n    // check if we have almost PCR_PID and program_info_length fields\n    if (remainingBytes < 4) {\n        return;\n    }\n\n    this.m_PCR_PID = mpegts.binary.getValueFrom2Bytes(data.subarray(id, id + 2), 3);\n    id += 2;\n    this.m_program_info_length = mpegts.binary.getValueFrom2Bytes(data.subarray(id, id + 2), 4);\n    id += 2;\n\n    // Parse program descriptors\n    id += this.m_program_info_length;\n\n    // Parse ES descriptions\n    remainingBytes = (this.m_section_length - this.SECTION_LENGTH - 4 - this.m_program_info_length);\n    var pESDescription = null;\n    while (remainingBytes > 0) {\n        pESDescription = new mpegts.si.ESDescription(data.subarray(id, id + remainingBytes));\n        this.m_listOfComponents.push(pESDescription);\n        remainingBytes -= pESDescription.getLength();\n        id += pESDescription.getLength();\n    }\n\n    this.m_bValid = true;\n};\n\nmpegts.si.PMT.prototype.TABLE_ID = 0x02;\n\nmpegts.si.PMT.prototype.gStreamTypes = [\n    /*  0 - 0x00 */\n    {\n        name: \"Reserved\",\n        value: 0x00,\n        desc: \"ITU-T | ISO/IEC Reserved\"\n    },\n    /*  1 - 0x01 */\n    {\n        name: \"MPEG1-Video\",\n        value: 0xE0,\n        desc: \"ISO/IEC 11172-2 Video\"\n    },\n    /*  2 - 0x02 */\n    {\n        name: \"MPEG2-Video\",\n        value: 0xE0,\n        desc: \"ITU-T Rec. H.262 | ISO/IEC 13818-2 Video or ISO/IEC 11172-2 constrained parameter video stream\"\n    },\n    /*  3 - 0x03 */\n    {\n        name: \"MPEG1-Audio\",\n        value: 0xC0,\n        desc: \"ISO/IEC 11172-3 Audio\"\n    },\n    /*  4 - 0x04 */\n    {\n        name: \"MPEG2-Audio\",\n        value: 0xC0,\n        desc: \"ISO/IEC 13818-3 Audio\"\n    },\n    /*  5 - 0x05 */\n    {\n        name: \"PRIVATE_SECTIONS\",\n        value: 0xBD,\n        desc: \"ITU-T Rec. H.222.0 | ISO/IEC 13818-1 private_sections\"\n    },\n    /*  6 - 0x06 */\n    {\n        name: \"PRIVATE\",\n        value: 0xBD,\n        desc: \"ITU-T Rec. H.222.0 | ISO/IEC 13818-1 PES packets containing private data\"\n    },\n    /*  7 - 0x07 */\n    {\n        name: \"MHEG\",\n        value: 0xF3,\n        desc: \"ISO/IEC 13522 MHEG\"\n    },\n    /*  8 - 0x08 */\n    {\n        name: \"MPEG1-DSM-CC\",\n        value: 0xF2,\n        desc: \"ITU-T Rec. H.222.0 | ISO/IEC 13818-1 Annex A DSM-CC\"\n    },\n    /*  9 - 0x09 */\n    {\n        name: \"H.222.1\",\n        value: 0xF4,\n        desc: \"ITU-T Rec. H.222.1\"\n    },\n    /* 10 - 0x0A */\n    {\n        name: \"DSM-CC_A\",\n        value: 0xF4,\n        desc: \"ISO/IEC 13818-6 type A\"\n    },\n    /* 11 - 0x0B */\n    {\n        name: \"DSM-CC_B\",\n        value: 0xF5,\n        desc: \"ISO/IEC 13818-6 type B\"\n    },\n    /* 12 - 0x0C */\n    {\n        name: \"DSM-CC_C\",\n        value: 0xF6,\n        desc: \"ISO/IEC 13818-6 type C\"\n    },\n    /* 13 - 0x0D */\n    {\n        name: \"DSM-CC_D\",\n        value: 0xF7,\n        desc: \"ISO/IEC 13818-6 type D\"\n    },\n    /* 14 - 0x0E */\n    {\n        name: \"Auxiliary\",\n        value: 0x00,\n        desc: \"ITU-T Rec. H.222.0 | ISO/IEC 13818-1 auxiliary\"\n    },\n    /* 15 - 0x0F */\n    {\n        name: \"MPEG2-AAC-ADTS\",\n        value: 0xC0,\n        desc: \"ISO/IEC 13818-7 Audio with ADTS transport syntax\"\n    },\n    /* 16 - 0x10 */\n    {\n        name: \"MPEG4-Video\",\n        value: 0xE0,\n        desc: \"ISO/IEC 14496-2 Visual\"\n    },\n    /* 17 - 0x11 */\n    {\n        name: \"MPEG4-AAC-LATM\",\n        value: 0xC0,\n        desc: \"ISO/IEC 14496-3 Audio with the LATM transport syntax as defined in ISO/IEC 14496-3/AMD-1\"\n    },\n    /* 18 - 0x12 */\n    {\n        name: \"MPEG4-SL\",\n        value: 0xFA,\n        desc: \"ISO/IEC 14496-1 SL-packetized stream or FlexMux stream carried in PES packets\"\n    },\n    /* 19 - 0x13 */\n    {\n        name: \"MPEG4-SL\",\n        value: 0xFA,\n        desc: \"ISO/IEC 14496-1 SL-packetized stream or FlexMux stream carried in ISO/IEC14496_sections\"\n    },\n    /* 20 - 0x14 */\n    {\n        name: \"DSM-CC_SDP\",\n        value: 0x00,\n        desc: \"ISO/IEC 13818-6 Synchronized Download Protocol\"\n    },\n    /* 21 - 0x15 */\n    {\n        name: \"META_PES\",\n        value: 0xFC,\n        desc: \"Metadata carried in PES packets\"\n    },\n    /* 22 - 0x16 */\n    {\n        name: \"META_SECTIONS\",\n        value: 0xFC,\n        desc: \"Metadata carried in metadata_sections\"\n    },\n    /* 23 - 0x17 */\n    {\n        name: \"META_DSM-CC\",\n        value: 0xFC,\n        desc: \"Metadata carried in ISO/IEC 13818-6 Data Carousel\"\n    },\n    /* 24 - 0x18 */\n    {\n        name: \"META_DSM-CC\",\n        value: 0xFC,\n        desc: \"Metadata carried in ISO/IEC 13818-6 Object Carousel\"\n    },\n    /* 25 - 0x19 */\n    {\n        name: \"META_DSM-CC\",\n        value: 0xFC,\n        desc: \"Metadata carried in ISO/IEC 13818-6 Synchronized Download Protocol\"\n    },\n    /* 26 - 0x1A */\n    {\n        name: \"MPEG2-IPMP\",\n        value: 0x00,\n        desc: \"IPMP stream (defined in ISO/IEC 13818-11, MPEG-2 IPMP)\"\n    },\n    /* 27 - 0x1B */\n    {\n        name: \"H.264\",\n        value: 0xE0,\n        desc: \"AVC video stream as defined in ITU-T Rec. H.264 | ISO/IEC 14496-10 Video\"\n    },\n    /* 28 - 0x1C */\n    {\n        name: \"MPEG4AAC\",\n        value: 0xC0,\n        desc: \"ISO/IEC 14496-3 Audio, without using any additional transport syntax, such as DST, ALS and SLS\"\n    },\n    /* 29 - 0x1D */\n    {\n        name: \"MPEG4Text\",\n        value: 0x00,\n        desc: \"ISO/IEC 14496-17 Text\"\n    },\n    /* 30 - 0x1E */\n    {\n        name: \"Aux. Video (23002-3)\",\n        value: 0x1E,\n        desc: \"Auxiliary video stream as defined in ISO/IEC 23002-3\"\n    },\n    /* 31 - 0x1F */\n    {\n        name: \"H.264-SVC\",\n        value: 0xE0,\n        desc: \"SVC video sub-bitstream of a video stream as defined in the Annex G of ITU-T Rec. H.264 | ISO/IEC 14496-10 Video\"\n    },\n    /* 32 - 0x20 */\n    {\n        name: \"H.264-MVC\",\n        value: 0xE0,\n        desc: \"MVC video sub-bitstream of a video stream as defined in the Annex H of ITU-T Rec. H.264 | ISO/IEC 14496-10 Video\"\n    },\n    /* 33 - 0x21 */\n    {\n        name: \"Reserved1\",\n        value: 0x00,\n        desc: \"TBC Reserved\"\n    },\n    /* 34 - 0x22 */\n    {\n        name: \"Reserved2\",\n        value: 0x00,\n        desc: \"TBC Reserved\"\n    },\n    /* 35 - 0x23 */\n    {\n        name: \"Reserved3\",\n        value: 0x00,\n        desc: \"TBC Reserved\"\n    },\n    /* 36 - 0x24 */\n    {\n        name: \"HEVC\",\n        value: 0xE0,\n        desc: \"ITU.-T Rec H.26x | ISO/IEC 23008-2 video stream\"\n    }\n];\n\nmpegts.si.PMT.prototype.MPEG2_VIDEO_STREAM_TYPE = 0x02;\nmpegts.si.PMT.prototype.AVC_VIDEO_STREAM_TYPE = 0x1B;\nmpegts.si.PMT.prototype.MPEG1_AUDIO_STREAM_TYPE = 0x03;\nmpegts.si.PMT.prototype.MPEG2_AUDIO_STREAM_TYPE = 0x04;\nmpegts.si.PMT.prototype.AAC_AUDIO_STREAM_TYPE = 0x11;\nmpegts.si.PMT.prototype.AC3_AUDIO_STREAM_TYPE = 0x06;\nmpegts.si.PMT.prototype.SUB_STREAM_TYPE = 0x06;\n\nmpegts.si.PMT.prototype.STREAM_TYPE_MP1V = 0x01;\nmpegts.si.PMT.prototype.STREAM_TYPE_MP2V = 0x02;\nmpegts.si.PMT.prototype.STREAM_TYPE_MP1A = 0x03;\nmpegts.si.PMT.prototype.STREAM_TYPE_MP2A = 0x04;\nmpegts.si.PMT.prototype.STREAM_TYPE_PRIVATE = 0x06;\nmpegts.si.PMT.prototype.STREAM_TYPE_TELETEXT = 0x06;\nmpegts.si.PMT.prototype.STREAM_TYPE_DVBSUBTITLE = 0x06;\nmpegts.si.PMT.prototype.STREAM_TYPE_AC3 = 0x06;\nmpegts.si.PMT.prototype.STREAM_TYPE_MP2AAC_ADTS = 0x0F;\nmpegts.si.PMT.prototype.STREAM_TYPE_MP4AAC_LATM = 0x11;\nmpegts.si.PMT.prototype.STREAM_TYPE_H264 = 0x1B;\nmpegts.si.PMT.prototype.STREAM_TYPE_MP4AAC = 0x1C;\nmpegts.si.PMT.prototype.STREAM_TYPE_AUX_23002_3 = 0x1E;\nmpegts.si.PMT.prototype.STREAM_TYPE_SVC = 0x1F;\nmpegts.si.PMT.prototype.STREAM_TYPE_MVC = 0x20;\nmpegts.si.PMT.prototype.STREAM_TYPE_HEVC = 0x24;\n\n\nmpegts.si.ESDescription = function(data) {\n    /** ES description fields */\n    this.m_stream_type = null;\n    this.m_elementary_PID = null;\n    this.m_ES_info_length = null;\n    this.parse(data);\n};\n\n/**\n * Gets the stream type associated to this ES\n * @return the stream type associated to this ES\n */\nmpegts.si.ESDescription.prototype.getStreamType = function() {\n    return this.m_stream_type;\n};\n\n/**\n * Gets the pid on which this ES may be found\n * @return the pid on which this ES may be found\n */\nmpegts.si.ESDescription.prototype.getPID = function() {\n    return this.m_elementary_PID;\n};\n\n/**\n * Returns the elementary stream description length\n * @return the elementary stream description length\n */\nmpegts.si.ESDescription.prototype.getLength = function() {\n    return 5 + this.m_ES_info_length;\n};\n\n/**\n * Parse the ESDescription from given bytestream\n * @param the bytestream to parse\n * @return the bytestream length\n */\nmpegts.si.ESDescription.prototype.parse = function(data) {\n    this.m_stream_type = data[0];\n    this.m_elementary_PID = mpegts.binary.getValueFrom2Bytes(data.subarray(1, 3), 3);\n    this.m_ES_info_length = mpegts.binary.getValueFrom2Bytes(data.subarray(3, 5), 4);\n};","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nmpegts.Pts = function(data) {\n\n    var low,\n        high;\n\n    //initialize an unsigned 64 bits long number\n    //this.m_lPTS = goog.math.Long.fromNumber(0);\n\n    //=> PTS is defined on 33 bits\n    //=> In the first byte, bit number 2 to 4 is useful\n    var bits3230 = data[0] >> 1 & 0x7;\n\n    //thirty-third bit in the high member\n    high = bits3230 >> 2;\n    //32 and 31 bits in th low member, shift by 30 bits\n    low = ((bits3230 & 0x3) << 30) >>> 0; //=> http://www.codeonastick.com/2013/06/javascript-convert-signed-integer-to.html unsigned int!!!!!!\n\n    //=> In the second byte, all the bits are useful\n    var bits2922 = data[1];\n    low = (low | (bits2922 << 22)) >>> 0; //=> http://www.codeonastick.com/2013/06/javascript-convert-signed-integer-to.html unsigned int!!!!!!\n\n    //=> In the third byte, bit number 2 to 8 is useful\n    var bits2115 = data[2] >> 1;\n    low = (low | (bits2115 << 15)) >>> 0; //=> http://www.codeonastick.com/2013/06/javascript-convert-signed-integer-to.html unsigned int!!!!!!\n\n    //=> In the fourth byte, all the bits are useful\n    var bits1407 = data[3];\n    low = (low | (bits1407 << 7)) >>> 0; //=> http://www.codeonastick.com/2013/06/javascript-convert-signed-integer-to.html unsigned int!!!!!!\n\n    //=> In the fifth byte, bit number 2 to 8 is useful\n    var bits0701 = data[4] >> 1;\n    low = (low | bits0701) >>> 0; //=> http://www.codeonastick.com/2013/06/javascript-convert-signed-integer-to.html unsigned int!!!!!!\n\n    this.m_lPTS = goog.math.Long.fromBits(low, high).toNumber();\n    this.m_fPTS = this.m_lPTS / mpegts.Pts.prototype.SYSTEM_CLOCK_FREQUENCY;\n};\n\n/**\n * Returns the PTS value in units of system clock frequency.\n * @return the PTS value in units of system clock frequency\n */\nmpegts.Pts.prototype.getValue = function() {\n    return this.m_lPTS;\n};\n\n/**\n * Returns the PTS value in seconds.\n * @return the PTS value in seconds\n */\nmpegts.Pts.prototype.getValueInSeconds = function() {\n    return this.m_fPTS;\n};\n\nmpegts.Pts.prototype.SYSTEM_CLOCK_FREQUENCY = 90000;","/*\n * The copyright in this software module is being made available under the BSD License, included below. This software module may be subject to other third party and/or contributor rights, including patent rights, and no such rights are granted under this license.\n * The whole software resulting from the execution of this software module together with its external dependent software modules from dash.js project may be subject to Orange and/or other third party rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2014, Orange\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n *   Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n *   Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n *   Neither the name of the Orange nor the names of its contributors may be used to endorse or promote products derived from this software module without specific prior written permission.\n *\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nmpegts.ts.TsPacket = function() {\n    this.m_cSync = null;\n    this.m_bTransportError = null;\n    this.m_bPUSI = null;\n    this.m_bTransportPriority = null;\n    this.m_nPID = null;\n    this.m_cTransportScramblingCtrl = null;\n    this.m_cAdaptationFieldCtrl = null;\n    this.m_cContinuityCounter = null;\n    this.m_pAdaptationField = null;\n    this.m_payloadArray = null;\n    this.m_cPayloadLength = null;\n    this.m_bDirty = null;\n    this.m_time = null;\n    this.m_arrivalTime = null;\n    this.m_bIgnored = null;\n};\n\nmpegts.ts.TsPacket.prototype.parse = function(data) {\n    var byteId = 0;\n    this.m_cSync = data[byteId];\n    if (this.m_cSync !== this.SYNC_WORD) {\n        //console.log(\"TS Packet Malformed!\");\n        return;\n    }\n\n    byteId++;\n\n    this.m_bTransportError = mpegts.binary.getBitFromByte(data[byteId], 0);\n    this.m_bPUSI = mpegts.binary.getBitFromByte(data[byteId], 1);\n    this.m_bTransportPriority = mpegts.binary.getBitFromByte(data[byteId], 2);\n    this.m_nPID = mpegts.binary.getValueFrom2Bytes(data.subarray(byteId, byteId + 2), 3, 13);\n\n    byteId += 2;\n\n    this.m_cTransportScramblingCtrl = mpegts.binary.getValueFromByte(data[byteId], 0, 2);\n    this.m_cAdaptationFieldCtrl = mpegts.binary.getValueFromByte(data[byteId], 2, 2);\n    this.m_cContinuityCounter = mpegts.binary.getValueFromByte(data[byteId], 4, 4);\n\n    byteId++;\n\n    // Adaptation field\n    // NAN => to Validate\n    if (this.m_cAdaptationFieldCtrl & 0x02) {\n        // Check adaptation field length before parsing\n        var cAFLength = data[byteId];\n        if ((cAFLength + byteId) >= this.TS_PACKET_SIZE) {\n            //console.log(\"TS Packet Size Problem!\");\n            return;\n        }\n        this.m_pAdaptationField = new mpegts.ts.AdaptationField();\n        this.m_pAdaptationField.parse(data.subarray(byteId));\n        byteId += this.m_pAdaptationField.getLength();\n    }\n\n    // Check packet validity\n    if (this.m_cAdaptationFieldCtrl === 0x00) {\n        //console.log(\"TS Packet is invalid!\");\n        return;\n    }\n\n    // Payload\n    if (this.m_cAdaptationFieldCtrl & 0x01) {\n        this.m_cPayloadLength = this.TS_PACKET_SIZE - byteId;\n        this.m_payloadArray = data.subarray(byteId, byteId + this.m_cPayloadLength);\n    }\n};\n\nmpegts.ts.TsPacket.prototype.checkSyncWord = function(data) {\n    var byteId = 0;\n    var sync = data[byteId];\n\n    return (sync === this.SYNC_WORD);\n};\n\nmpegts.ts.TsPacket.prototype.getPid = function() {\n    return this.m_nPID;\n};\n\nmpegts.ts.TsPacket.prototype.getPayload = function() {\n    return this.m_payloadArray;\n};\n\nmpegts.ts.TsPacket.prototype.getPayloadLength = function() {\n    return this.m_cPayloadLength;\n};\n\nmpegts.ts.TsPacket.prototype.getPusi = function() {\n    return this.m_bPUSI;\n};\n\nmpegts.ts.TsPacket.prototype.hasAdaptationFieldOnly = function() {\n    return (this.m_cAdaptationFieldCtrl === 0x02);\n};\n\nmpegts.ts.TsPacket.prototype.SYNC_WORD = 0x47;\nmpegts.ts.TsPacket.prototype.TS_PACKET_SIZE = 188;\nmpegts.ts.TsPacket.prototype.UNDEFINED_PID = 0xFFFF;\nmpegts.ts.TsPacket.prototype.PAT_PID = 0;\nmpegts.ts.TsPacket.prototype.STREAM_ID_PROGRAM_STREAM_MAP = 0xBC;\nmpegts.ts.TsPacket.prototype.STREAM_ID_PADDING_STREAM = 0xBE;\nmpegts.ts.TsPacket.prototype.STREAM_ID_PADDING_STREAM = 0xBE;\nmpegts.ts.TsPacket.prototype.STREAM_ID_PRIVATE_STREAM_2 = 0xBF;\nmpegts.ts.TsPacket.prototype.STREAM_ID_ECM_STREAM = 0xF0;\nmpegts.ts.TsPacket.prototype.STREAM_ID_EMM_STREAM = 0xF1;\nmpegts.ts.TsPacket.prototype.STREAM_ID_DSMCC_STREAM = 0xF2;\nmpegts.ts.TsPacket.prototype.STREAM_ID_H2221_TYPE_E_STREAM = 0xF8;\nmpegts.ts.TsPacket.prototype.STREAM_ID_PROGRAM_STREAM_DIRECTORY = 0xFF;\n","/*   Copyright (C) 2011,2012,2013,2014 John Kula */\n\n/*\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n    All trademarks and service marks contained within this document are\n    property of their respective owners.\n\n    Version 2014.07.23\n\n    Updates may be found at: http:\\\\www.darkwavetech.com\n\n*/\n\n/*jslint browser:true */\n\n/* This function returns the browser and version number by using the navigator.useragent object */\n\nfunction fingerprint_browser() {\n    \"use strict\";\n    var userAgent,\n        name,\n        version;\n\n    try {\n\n        userAgent = navigator.userAgent.toLowerCase();\n\n        if (/msie (\\d+\\.\\d+);/.test(userAgent)) { //test for MSIE x.x;\n            version = Number(RegExp.$1); // capture x.x portion and store as a number\n            if (userAgent.indexOf(\"trident/6\") > -1) {\n                version = 10;\n            }\n            if (userAgent.indexOf(\"trident/5\") > -1) {\n                version = 9;\n            }\n            if (userAgent.indexOf(\"trident/4\") > -1) {\n                version = 8;\n            }\n            name = \"Internet Explorer\";\n        } else if (userAgent.indexOf(\"trident/7\") > -1) { //IE 11+ gets rid of the legacy 'MSIE' in the user-agent string;\n            version = 11;\n            name = \"Internet Explorer\";\n        }  else if (/edge[\\/\\s](\\d+\\.\\d+)/.test(userAgent)) { //test for Firefox/x.x or Firefox x.x (ignoring remaining digits);\n            version = Number(RegExp.$1); // capture x.x portion and store as a number\n            name = \"Edge\";\n        }  else if (/firefox[\\/\\s](\\d+\\.\\d+)/.test(userAgent)) { //test for Firefox/x.x or Firefox x.x (ignoring remaining digits);\n            version = Number(RegExp.$1); // capture x.x portion and store as a number\n            name = \"Firefox\";\n        } else if (/opera[\\/\\s](\\d+\\.\\d+)/.test(userAgent)) { //test for Opera/x.x or Opera x.x (ignoring remaining decimal places);\n            version = Number(RegExp.$1); // capture x.x portion and store as a number\n            name = \"Opera\";\n        } else if (/chrome[\\/\\s](\\d+\\.\\d+)/.test(userAgent)) { //test for Chrome/x.x or Chrome x.x (ignoring remaining digits);\n            version = Number(RegExp.$1); // capture x.x portion and store as a number\n            name = \"Chrome\";\n        } else if (/version[\\/\\s](\\d+\\.\\d+)/.test(userAgent)) { //test for Version/x.x or Version x.x (ignoring remaining digits);\n            version = Number(RegExp.$1); // capture x.x portion and store as a number\n            name = \"Safari\";\n        } else if (/rv[\\/\\s](\\d+\\.\\d+)/.test(userAgent)) { //test for rv/x.x or rv x.x (ignoring remaining digits);\n            version = Number(RegExp.$1); // capture x.x portion and store as a number\n            name = \"Mozilla\";\n        } else if (/mozilla[\\/\\s](\\d+\\.\\d+)/.test(userAgent)) { //test for Mozilla/x.x or Mozilla x.x (ignoring remaining digits);\n            version = Number(RegExp.$1); // capture x.x portion and store as a number\n            name = \"Mozilla\";\n        } else if (/binget[\\/\\s](\\d+\\.\\d+)/.test(userAgent)) { //test for BinGet/x.x or BinGet x.x (ignoring remaining digits);\n            version = Number(RegExp.$1); // capture x.x portion and store as a number\n            name = \"Library (BinGet)\";\n        } else if (/curl[\\/\\s](\\d+\\.\\d+)/.test(userAgent)) { //test for Curl/x.x or Curl x.x (ignoring remaining digits);\n            version = Number(RegExp.$1); // capture x.x portion and store as a number\n            name = \"Library (cURL)\";\n        } else if (/java[\\/\\s](\\d+\\.\\d+)/.test(userAgent)) { //test for Java/x.x or Java x.x (ignoring remaining digits);\n            version = Number(RegExp.$1); // capture x.x portion and store as a number\n            name = \"Library (Java)\";\n        } else if (/libwww-perl[\\/\\s](\\d+\\.\\d+)/.test(userAgent)) { //test for libwww-perl/x.x or libwww-perl x.x (ignoring remaining digits);\n            version = Number(RegExp.$1); // capture x.x portion and store as a number\n            name = \"Library (libwww-perl)\";\n        } else if (/microsoft url control -[\\s](\\d+\\.\\d+)/.test(userAgent)) { //test for Microsoft URL Control - x.x (ignoring remaining digits);\n            version = Number(RegExp.$1); // capture x.x portion and store as a number\n            name = \"Library (Microsoft URL Control)\";\n        } else if (/peach[\\/\\s](\\d+\\.\\d+)/.test(userAgent)) { //test for Peach/x.x or Peach x.x (ignoring remaining digits);\n            version = Number(RegExp.$1); // capture x.x portion and store as a number\n            name = \"Library (Peach)\";\n        } else if (/php[\\/\\s](\\d+\\.\\d+)/.test(userAgent)) { //test for PHP/x.x or PHP x.x (ignoring remaining digits);\n            version = Number(RegExp.$1); // capture x.x portion and store as a number\n            name = \"Library (PHP)\";\n        } else if (/pxyscand[\\/\\s](\\d+\\.\\d+)/.test(userAgent)) { //test for pxyscand/x.x or pxyscand x.x (ignoring remaining digits);\n            version = Number(RegExp.$1); // capture x.x portion and store as a number\n            name = \"Library (pxyscand)\";\n        } else if (/pycurl[\\/\\s](\\d+\\.\\d+)/.test(userAgent)) { //test for pycurl/x.x or pycurl x.x (ignoring remaining digits);\n            version = Number(RegExp.$1); // capture x.x portion and store as a number\n            name = \"Library (PycURL)\";\n        } else if (/python-urllib[\\/\\s](\\d+\\.\\d+)/.test(userAgent)) { //test for python-urllib/x.x or python-urllib x.x (ignoring remaining digits);\n            version = Number(RegExp.$1); // capture x.x portion and store as a number\n            name = \"Library (Python URLlib)\";\n        } else if (/appengine-google/.test(userAgent)) { //test for AppEngine-Google;\n            version = Number(RegExp.$1); // capture x.x portion and store as a number\n            name = \"Cloud (Google AppEngine)\";\n        } else if (/trident/.test(userAgent)) { //test for Trident;\n            version = Number(RegExp.$1); // capture x.x portion and store as a number\n            name = \"Trident\";\n        } else if (/adventurer/.test(userAgent)) { //test for Orange Adventurer;\n            version = Number(RegExp.$1); // capture x.x portion and store as a number\n            name = \"Adventurer\";\n        } else {\n            version = \"unknown\";\n            name = \"unknown\";\n        }\n    } catch (err) {\n        name = \"error\";\n        version = \"error\";\n    }\n\n    return {\n        name: name.replace(/\\s+/g, ''),\n        version: version\n    };\n}","/*   Copyright (C) 2011,2012,2013,2014 John Kula */\n\n/*\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n    All trademarks and service marks contained within this document are\n    property of their respective owners.\n\n    Version 2014.07.23\n\n    Updates may be found at: http:\\\\www.darkwavetech.com\n\n*/\n\n/*jslint browser:true */\n\n/* This function returns the operating system and number of bits by looking at the navigator.useragent and navigator.platform objects */\n\nfunction fingerprint_os() {\n    \"use strict\";\n\n    var userAgent,\n        platform,\n        name,\n        bits,\n        os = {\n            name: \"\",\n            bits: \"\"\n        };\n\n    try {\n        /* navigator.userAgent is supported by all major browsers */\n        userAgent = navigator.userAgent.toLowerCase();\n\n        if (userAgent.indexOf(\"windows nt 10.0\") !== -1) {\n            name = \"Windows 10\";\n        } else if (userAgent.indexOf(\"windows nt 6.3\") !== -1) {\n            name = \"Windows 8.1\";\n        } else if (userAgent.indexOf(\"windows nt 6.2\") !== -1) {\n            name = \"Windows 8\";\n        } else if (userAgent.indexOf(\"windows nt 6.1\") !== -1) {\n            name = \"Windows 7\";\n        } else if (userAgent.indexOf(\"windows nt 6.0\") !== -1) {\n            name = \"Windows Vista/Windows Server 2008\";\n        } else if (userAgent.indexOf(\"windows nt 5.2\") !== -1) {\n            name = \"Windows XP x64/Windows Server 2003\";\n        } else if (userAgent.indexOf(\"windows nt 5.1\") !== -1) {\n            name = \"Windows XP\";\n        } else if (userAgent.indexOf(\"windows nt 5.01\") !== -1) {\n            name = \"Windows 2000, Service Pack 1 (SP1)\";\n        } else if (userAgent.indexOf(\"windows xp\") !== -1) {\n            name = \"Windows XP\";\n        } else if (userAgent.indexOf(\"windows 2000\") !== -1) {\n            name = \"Windows 2000\";\n        } else if (userAgent.indexOf(\"windows nt 5.0\") !== -1) {\n            name = \"Windows 2000\";\n        } else if (userAgent.indexOf(\"windows nt 4.0\") !== -1) {\n            name = \"Windows NT 4.0\";\n        } else if (userAgent.indexOf(\"windows nt\") !== -1) {\n            name = \"Windows NT 4.0\";\n        } else if (userAgent.indexOf(\"winnt4.0\") !== -1) {\n            name = \"Windows NT 4.0\";\n        } else if (userAgent.indexOf(\"winnt\") !== -1) {\n            name = \"Windows NT 4.0\";\n        } else if (userAgent.indexOf(\"windows me\") !== -1) {\n            name = \"Windows ME\";\n        } else if (userAgent.indexOf(\"win 9x 4.90\") !== -1) {\n            name = \"Windows ME\";\n        } else if (userAgent.indexOf(\"windows 98\") !== -1) {\n            name = \"Windows 98\";\n        } else if (userAgent.indexOf(\"win98\") !== -1) {\n            name = \"Windows 98\";\n        } else if (userAgent.indexOf(\"windows 95\") !== -1) {\n            name = \"Windows 95\";\n        } else if (userAgent.indexOf(\"windows_95\") !== -1) {\n            name = \"Windows 95\";\n        } else if (userAgent.indexOf(\"win95\") !== -1) {\n            name = \"Windows 95\";\n        } else if (userAgent.indexOf(\"ce\") !== -1) {\n            name = \"Windows CE\";\n        } else if (userAgent.indexOf(\"win16\") !== -1) {\n            name = \"Windows 3.11\";\n        } else if (userAgent.indexOf(\"iemobile\") !== -1) {\n            name = \"Windows Mobile\";\n        } else if (userAgent.indexOf(\"wm5 pie\") !== -1) {\n            name = \"Windows Mobile\";\n        } else if (userAgent.indexOf(\"windows phone 10.0\") !== -1) {\n            name = \"Windows Phone 10\";\n        } else if (userAgent.indexOf(\"windows\") !== -1) {\n            name = \"Windows (Unknown Version)\";\n        } else if (userAgent.indexOf(\"openbsd\") !== -1) {\n            name = \"Open BSD\";\n        } else if (userAgent.indexOf(\"sunos\") !== -1) {\n            name = \"Sun OS\";\n        } else if (userAgent.indexOf(\"ubuntu\") !== -1) {\n            name = \"Ubuntu\";\n        } else if (userAgent.indexOf(\"ipad\") !== -1) {\n            name = \"iOS (iPad)\";\n        } else if (userAgent.indexOf(\"ipod\") !== -1) {\n            name = \"iOS (iTouch)\";\n        } else if (userAgent.indexOf(\"iphone\") !== -1) {\n            name = \"iOS (iPhone)\";\n        } else if (userAgent.indexOf(\"mac os x beta\") !== -1) {\n            name = \"Mac O SX Beta\";\n        } else if (userAgent.indexOf(\"mac os x 10\") !== -1) {\n            if (/mac os x 10_(\\d+)\\_(\\d+)/.test(userAgent)) {\n                name = \"Mac OS X 10.\" + RegExp.$1;\n            } else {\n                name = \"Mac OS X 10\";\n            }\n        } else if (userAgent.indexOf(\"mac os x\") !== -1) {\n            name = \"Mac OS X\";\n        } else if (userAgent.indexOf(\"mac_68000\") !== -1) {\n            name = \"Mac OS Classic (68000)\";\n        } else if (userAgent.indexOf(\"68K\") !== -1) {\n            name = \"Mac OS Classic (68000)\";\n        } else if (userAgent.indexOf(\"mac_powerpc\") !== -1) {\n            name = \"Mac OS Classic (PowerPC)\";\n        } else if (userAgent.indexOf(\"ppc mac\") !== -1) {\n            name = \"Mac OS Classic (PowerPC)\";\n        } else if (userAgent.indexOf(\"macintosh\") !== -1) {\n            name = \"Mac OS Classic\";\n        } else if (userAgent.indexOf(\"googletv\") !== -1) {\n            name = \"Android (GoogleTV)\";\n        } else if (userAgent.indexOf(\"xoom\") !== -1) {\n            name = \"Android (Xoom)\";\n        } else if (userAgent.indexOf(\"htc_flyer\") !== -1) {\n            name = \"Android (HTC Flyer)\";\n        } else if (userAgent.indexOf(\"android\") !== -1) {\n            name = \"Android\";\n        } else if (userAgent.indexOf(\"symbian\") !== -1) {\n            name = \"Symbian\";\n        } else if (userAgent.indexOf(\"series60\") !== -1) {\n            name = \"Symbian (Series 60)\";\n        } else if (userAgent.indexOf(\"series70\") !== -1) {\n            name = \"Symbian (Series 70)\";\n        } else if (userAgent.indexOf(\"series80\") !== -1) {\n            name = \"Symbian (Series 80)\";\n        } else if (userAgent.indexOf(\"series90\") !== -1) {\n            name = \"Symbian (Series 90)\";\n        } else if (userAgent.indexOf(\"x11\") !== -1) {\n            name = \"UNIX\";\n        } else if (userAgent.indexOf(\"nix\") !== -1) {\n            name = \"UNIX\";\n        } else if (userAgent.indexOf(\"linux\") !== -1) {\n            name = \"Linux\";\n        } else if (userAgent.indexOf(\"qnx\") !== -1) {\n            name = \"QNX\";\n        } else if (userAgent.indexOf(\"os/2\") !== -1) {\n            name = \"IBM OS/2\";\n        } else if (userAgent.indexOf(\"beos\") !== -1) {\n            name = \"BeOS\";\n        } else if (userAgent.indexOf(\"blackberry95\") !== -1) {\n            name = \"Blackberry (Storm 1/2)\";\n        } else if (userAgent.indexOf(\"blackberry97\") !== -1) {\n            name = \"Blackberry (Bold)\";\n        } else if (userAgent.indexOf(\"blackberry96\") !== -1) {\n            name = \"Blackberry (Tour)\";\n        } else if (userAgent.indexOf(\"blackberry89\") !== -1) {\n            name = \"Blackberry (Curve 2)\";\n        } else if (userAgent.indexOf(\"blackberry98\") !== -1) {\n            name = \"Blackberry (Torch)\";\n        } else if (userAgent.indexOf(\"playbook\") !== -1) {\n            name = \"Blackberry (Playbook)\";\n        } else if (userAgent.indexOf(\"wnd.rim\") !== -1) {\n            name = \"Blackberry (IE/FF Emulator)\";\n        } else if (userAgent.indexOf(\"blackberry\") !== -1) {\n            name = \"Blackberry\";\n        } else if (userAgent.indexOf(\"palm\") !== -1) {\n            name = \"Palm OS\";\n        } else if (userAgent.indexOf(\"webos\") !== -1) {\n            name = \"WebOS\";\n        } else if (userAgent.indexOf(\"hpwos\") !== -1) {\n            name = \"WebOS (HP)\";\n        } else if (userAgent.indexOf(\"blazer\") !== -1) {\n            name = \"Palm OS (Blazer)\";\n        } else if (userAgent.indexOf(\"xiino\") !== -1) {\n            name = \"Palm OS (Xiino)\";\n        } else if (userAgent.indexOf(\"kindle\") !== -1) {\n            name = \"Kindle\";\n        } else if (userAgent.indexOf(\"wii\") !== -1) {\n            name = \"Nintendo (Wii)\";\n        } else if (userAgent.indexOf(\"nintendo ds\") !== -1) {\n            name = \"Nintendo (DS)\";\n        } else if (userAgent.indexOf(\"playstation 3\") !== -1) {\n            name = \"Sony (Playstation Console)\";\n        } else if (userAgent.indexOf(\"playstation portable\") !== -1) {\n            name = \"Sony (Playstation Portable)\";\n        } else if (userAgent.indexOf(\"webtv\") !== -1) {\n            name = \"MSN TV (WebTV)\";\n        } else if (userAgent.indexOf(\"inferno\") !== -1) {\n            name = \"Inferno\";\n        } else {\n            name = \"Unknown\";\n        }\n\n        /* navigator.platform is supported by all major browsers */\n        platform = navigator.platform.toLowerCase();\n\n        if (platform.indexOf(\"x64\") !== -1) {\n            bits = \"64\";\n        } else if (userAgent.indexOf(\"x86_64\") !== -1) {\n            bits = \"64\";\n        } else if (userAgent.indexOf(\"x86-64\") !== -1) {\n            bits = \"64\";\n        } else if (userAgent.indexOf(\"win64\") !== -1) {\n            bits = \"64\";\n        } else if (userAgent.indexOf(\"x64;\") !== -1) {\n            bits = \"64\";\n        } else if (userAgent.indexOf(\"amd64\") !== -1) {\n            bits = \"64\";\n        } else if (userAgent.indexOf(\"wow64\") !== -1) {\n            bits = \"64\";\n        } else if (userAgent.indexOf(\"x64_64\") !== -1) {\n            bits = \"64\";\n        } else if (userAgent.indexOf(\"ia65\") !== -1) {\n            bits = \"64\";\n        } else if (userAgent.indexOf(\"sparc64\") !== -1) {\n            bits = \"64\";\n        } else if (userAgent.indexOf(\"ppc64\") !== -1) {\n            bits = \"64\";\n        } else if (userAgent.indexOf(\"irix64\") !== -1) {\n            bits = \"64\";\n        } else if (userAgent.indexOf(\"irix64\") !== -1) {\n            bits = \"64\";\n        } else {\n            bits = \"32\";\n        }\n    } catch (err) {\n        name = \"error\";\n        bits = \"error\";\n    }\n\n    return {\n        name: name.replace(/\\s+/g, ''),\n        bits: \"x\" + bits\n    };\n}"]}